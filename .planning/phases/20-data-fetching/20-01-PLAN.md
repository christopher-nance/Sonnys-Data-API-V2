---
phase: 20-data-fetching
type: execute
---

<objective>
Add internal data fetching methods to StatsResource for efficient bulk retrieval of transactions and recurring data within a date range.

Purpose: Provide a clean internal API that downstream stat methods (Phases 21-25) call to get raw data — each method handles date conversion and delegates to the appropriate resource, so stat computations never deal with API plumbing directly.
Output: StatsResource with 4 private fetching methods (_fetch_transactions, _fetch_transactions_by_type, _fetch_transactions_v2, _fetch_recurring_status_changes).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-stats-foundation/19-01-SUMMARY.md
@.planning/phases/19-stats-foundation/19-02-SUMMARY.md

@src/sonnys_data_client/resources/_stats.py
@src/sonnys_data_client/resources/_transactions.py
@src/sonnys_data_client/resources/_recurring.py
@src/sonnys_data_client/types/_transactions.py
@src/sonnys_data_client/types/_recurring.py

**Tech stack available:** Pydantic v2, requests, existing resource framework
**Established patterns:**
- StatsResource as client-side computation layer — stat methods call existing resources and aggregate
- _resolve_dates() returns {"startDate": int, "endDate": int} dict matching API query parameter conventions
- client.stats cached_property follows identical pattern to other resources

**Constraining decisions:**
- [Phase 19-01]: Standalone _date_utils.py for shared date logic; parse_date_range() returns validated (datetime, datetime) tuple
- [Phase 19-02]: StatsResource extends BaseResource only — stats compute analytics, don't wrap API endpoints
- [Phase 19-02]: _resolve_dates() returns timestamp dict for API query params

**Key data model notes:**
- TransactionListItem: trans_number, trans_id, total, date (NO type field)
- TransactionV2ListItem: extends ListItem with is_recurring_plan_sale, is_recurring_plan_redemption, transaction_status
- list_by_type(item_type) provides type-filtered transaction queries
- RecurringAccounts has NO _convert_dates() — must pass pre-converted Unix timestamps
- Recurring status changes endpoint accepts startDate/endDate as Unix timestamps
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transaction data fetching methods to StatsResource</name>
  <files>src/sonnys_data_client/resources/_stats.py</files>
  <action>
Add three private methods to StatsResource that fetch transaction data for a date range:

1. `_fetch_transactions(self, start, end)` — calls `self._client.transactions.list(**self._resolve_dates(start, end))`, returns `list[TransactionListItem]`. Used by total_sales (sum of totals).

2. `_fetch_transactions_by_type(self, start, end, item_type)` — calls `self._client.transactions.list_by_type(item_type, **self._resolve_dates(start, end))`, returns `list[TransactionListItem]`. Used by total_washes, retail_wash_count.

3. `_fetch_transactions_v2(self, start, end)` — calls `self._client.transactions.list_v2(**self._resolve_dates(start, end))`, returns `list[TransactionV2ListItem]`. Used by report() for single-fetch efficiency (v2 has recurring flags for classification without separate type queries).

Each method: takes `start: str | datetime` and `end: str | datetime`, uses `_resolve_dates()` for validation and timestamp conversion, delegates to the existing resource method, returns the typed list. Add Google docstrings. Import TransactionListItem and TransactionV2ListItem from types.

Do NOT add any caching, memoization, or extra abstraction — keep these as thin, well-typed delegation methods. The "efficiency" comes from report() calling _fetch_transactions_v2() once rather than multiple targeted fetches, not from caching.
  </action>
  <verify>python -c "from sonnys_data_client.resources._stats import StatsResource; print('Import OK')"</verify>
  <done>StatsResource has _fetch_transactions, _fetch_transactions_by_type, _fetch_transactions_v2 methods with correct type annotations and docstrings</done>
</task>

<task type="auto">
  <name>Task 2: Add recurring data fetching method and verify complete layer</name>
  <files>src/sonnys_data_client/resources/_stats.py</files>
  <action>
Add one private method for recurring data:

1. `_fetch_recurring_status_changes(self, start, end)` — calls `self._client.recurring.list_status_changes(**self._resolve_dates(start, end))`, returns `list[RecurringStatusChange]`. Used by new_memberships_sold (filter status changes where new_status indicates activation).

Import RecurringStatusChange from types. Add Google docstring explaining this fetches status transition events (old_status → new_status with date, employee, site) for membership analytics.

Verify the complete data fetching layer:
- All 4 methods exist on StatsResource
- All type imports resolve
- Existing test suite still passes (no regressions)
  </action>
  <verify>python -c "from sonnys_data_client.resources._stats import StatsResource; [getattr(StatsResource, m) for m in ('_fetch_transactions', '_fetch_transactions_by_type', '_fetch_transactions_v2', '_fetch_recurring_status_changes')]; print('All 4 methods present')" && python -m pytest tests/ -q</verify>
  <done>All 4 _fetch_* methods present on StatsResource with correct signatures, type annotations, docstrings. Full test suite passes with zero regressions.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] All 4 _fetch_* methods exist on StatsResource
- [ ] Each method has correct return type annotation
- [ ] Each method has Google docstring
- [ ] `python -m pytest tests/ -q` passes with zero regressions
- [ ] `python -c "from sonnys_data_client.resources._stats import StatsResource"` succeeds
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or import issues introduced
- StatsResource has complete data fetching layer for Phases 21-25
- Each method delegates cleanly to existing resources via _resolve_dates()
</success_criteria>

<output>
After completion, create `.planning/phases/20-data-fetching/20-01-SUMMARY.md`
</output>
