---
phase: 06-standard-resources
plan: 01
type: execute
---

<objective>
Implement Customers and Items resource classes and wire them into SonnysClient.

Purpose: Provide `client.customers.list()`, `client.customers.get(id)`, and `client.items.list()` as the first concrete resources on the client.
Output: Two resource modules, SonnysClient properties, updated exports.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resource-framework/05-01-SUMMARY.md

# Key source files:
@src/sonnys_data_client/_resources.py
@src/sonnys_data_client/_client.py
@src/sonnys_data_client/__init__.py
@src/sonnys_data_client/resources/__init__.py
@src/sonnys_data_client/types/_customers.py
@src/sonnys_data_client/types/_items.py

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** mixin-based resource classes, TYPE_CHECKING guard for circular imports, underscore-prefixed internals, src-layout
**Constraining decisions:**
- Phase 05: ListableResource/GettableResource as independent mixins — concrete resources inherit one or both
- Phase 05: TYPE_CHECKING guard for circular imports in _resources.py
- Phase 01: Underscore-prefixed internals, public API via __init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Customers and Items resource classes</name>
  <files>src/sonnys_data_client/resources/_customers.py, src/sonnys_data_client/resources/_items.py</files>
  <action>
Create two resource modules following the mixin pattern from _resources.py:

**resources/_customers.py — Customers class:**
- Inherit from ListableResource AND GettableResource (both list + detail)
- `_path = "/customer"`
- `_items_key = "customers"`
- `_model = CustomerListItem` (from types._customers)
- `_default_limit = 100`
- `_paginated = True`
- `_detail_path = "/customer/{id}"`
- `_detail_model = Customer` (from types._customers)

**resources/_items.py — Items class:**
- Inherit from ListableResource only (list, no detail endpoint)
- `_path = "/item"`
- `_items_key = "items"`
- `_model = Item` (from types._items)
- `_default_limit = 100`
- `_paginated = True`

Import models from sonnys_data_client.types, import base classes from sonnys_data_client._resources. No docstrings beyond the class docstring. Keep classes minimal — just class attributes, no method overrides.
  </action>
  <verify>python -c "from sonnys_data_client.resources._customers import Customers; from sonnys_data_client.resources._items import Items; print('OK')"</verify>
  <done>Both resource classes importable, correct class attributes set, inherit from correct mixins</done>
</task>

<task type="auto">
  <name>Task 2: Wire Customers and Items into SonnysClient</name>
  <files>src/sonnys_data_client/_client.py, src/sonnys_data_client/resources/__init__.py, src/sonnys_data_client/__init__.py</files>
  <action>
**resources/__init__.py:**
Export Customers and Items classes:
```python
from sonnys_data_client.resources._customers import Customers
from sonnys_data_client.resources._items import Items
```

**_client.py:**
- Add `import functools` at top
- Add `customers` and `items` as `@functools.cached_property` on SonnysClient that return `Customers(self)` and `Items(self)` respectively
- Import resource classes inside the cached_property methods (lazy import) to avoid circular imports, OR use TYPE_CHECKING guard for type annotations + direct import in property body. Prefer: import at module level since resources import from _resources.py (not _client.py), so no circular dependency exists. But verify — if resources/__init__.py triggers _resources.py which uses TYPE_CHECKING for SonnysClient, then importing resources in _client.py is safe.

**__init__.py:**
Add Customers and Items to the public exports:
```python
from sonnys_data_client.resources import Customers, Items
```
Add both to __all__.

**Verify no circular imports** by running: `python -c "from sonnys_data_client import SonnysClient, Customers, Items"`
  </action>
  <verify>python -c "from sonnys_data_client import SonnysClient, Customers, Items; c = SonnysClient('x','y'); assert hasattr(c, 'customers'); assert hasattr(c, 'items'); print('OK')"</verify>
  <done>SonnysClient.customers returns Customers instance, SonnysClient.items returns Items instance, no circular import errors, both exported from package __init__.py</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from sonnys_data_client import SonnysClient, Customers, Items"` — no import errors
- [ ] `python -c "c = SonnysClient('x','y'); print(type(c.customers).__name__, type(c.items).__name__)"` — prints "Customers Items"
- [ ] `pytest tests/ -x -q` — all existing tests still pass
- [ ] No ruff lint errors: `ruff check src/sonnys_data_client/`
</verification>

<success_criteria>

- Customers resource supports list() and get() via inherited mixins
- Items resource supports list() via inherited mixin
- client.customers and client.items properties work
- No circular imports
- All prior tests pass
- No lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-standard-resources/06-01-SUMMARY.md`
</output>
