---
phase: 25-stats-report
type: execute
---

<objective>
Implement report() method returning all KPIs in one call with minimized API round-trips.

Purpose: Provide a single-call interface for dashboard-style analytics — fetch data efficiently, compute all stats, return a unified result model.
Output: StatsReport model and report() method on StatsResource.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Dependencies (all complete):
@.planning/phases/21-revenue-sales/21-01-SUMMARY.md
@.planning/phases/22-wash-analytics/22-01-SUMMARY.md
@.planning/phases/23-membership-analytics/23-01-SUMMARY.md
@.planning/phases/24-conversion-rate/24-01-SUMMARY.md

# Key source files:
@src/sonnys_data_client/resources/_stats.py
@src/sonnys_data_client/types/_stats.py
@src/sonnys_data_client/types/__init__.py
@src/sonnys_data_client/__init__.py
@tests/test_types.py

**Tech stack available:** pydantic, requests, pytest
**Established patterns:**
- SalesResult/WashResult/ConversionResult models in types/_stats.py extending SonnysModel
- Stat methods delegate to _fetch_* helpers for data retrieval
- Export wiring: types/_stats.py → types/__init__.py → __init__.py

**Constraining decisions:**
- [Phase 20]: "No caching or memoization — efficiency from report() calling _fetch_transactions_v2() once"
- [Phase 20]: _fetch_transactions_v2() returns enriched records with is_recurring_plan_sale, is_recurring_plan_redemption flags
- [Phase 21]: total_sales() uses single-pass categorization via v2 boolean flags
- [Phase 22]: total_washes() needs separate _fetch_transactions_by_type("wash") and ("prepaid-wash") calls — v2 lacks type field
- [Phase 22]: retail_wash_count() uses _fetch_transactions_by_type("wash") — same data as wash_count in total_washes()
- [Phase 23]: new_memberships_sold() filters _fetch_recurring_status_changes() for new_status == "Active"
- [Phase 24]: conversion_rate() composes retail_wash_count + new_memberships_sold

**Efficiency analysis:**
Individual method calls = 7 API round-trips:
- total_sales(): 1 (v2)
- total_washes(): 2 (wash + prepaid-wash)
- retail_wash_count(): 1 (wash) — duplicate
- new_memberships_sold(): 1 (recurring)
- conversion_rate(): 2 (wash + recurring) — duplicates

report() with shared fetching = 4 API round-trips:
1. _fetch_transactions_v2() → SalesResult computation
2. _fetch_transactions_by_type("wash") → wash_count + retail_wash_count
3. _fetch_transactions_by_type("prepaid-wash") → prepaid_wash_count
4. _fetch_recurring_status_changes() → new_memberships_sold
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StatsReport model and wire package exports</name>
  <files>src/sonnys_data_client/types/_stats.py, src/sonnys_data_client/types/__init__.py, src/sonnys_data_client/__init__.py, tests/test_types.py</files>
  <action>Add StatsReport class to types/_stats.py extending SonnysModel with five fields:
- sales: SalesResult (revenue breakdown from total_sales computation)
- washes: WashResult (wash volume breakdown from total_washes computation)
- new_memberships: int (count of membership activations)
- conversion: ConversionResult (conversion rate KPI)
- period_start: str (ISO-8601 start date of the report range)
- period_end: str (ISO-8601 end date of the report range)

Add Google-style docstring following existing model pattern: class docstring describing what report() returns, field semantics, note about efficiency (4 API calls vs 7 from individual methods).

Wire exports:
1. types/__init__.py: Add StatsReport import from _stats and to __all__
2. __init__.py: Add StatsReport import from types and to __all__
3. tests/test_types.py: Update __all__ count assertion from 33 to 34</action>
  <verify>python -c "from sonnys_data_client import StatsReport; print(StatsReport.__fields__)" succeeds. python -m pytest tests/test_types.py passes.</verify>
  <done>StatsReport importable from package root with 6 typed fields. __all__ count test passes at 34.</done>
</task>

<task type="auto">
  <name>Task 2: Implement report() on StatsResource with efficient shared fetching</name>
  <files>src/sonnys_data_client/resources/_stats.py</files>
  <action>Add report(start, end) method to StatsResource that fetches data efficiently and computes all KPIs:

1. Fetch data (4 API calls, not 7):
   - v2_transactions = self._fetch_transactions_v2(start, end)
   - wash_transactions = self._fetch_transactions_by_type(start, end, "wash")
   - prepaid_transactions = self._fetch_transactions_by_type(start, end, "prepaid-wash")
   - status_changes = self._fetch_recurring_status_changes(start, end)

2. Compute SalesResult from v2_transactions (same logic as total_sales — single-pass categorization by is_recurring_plan_sale / is_recurring_plan_redemption flags):
   - Iterate v2_transactions once, accumulate recurring_plan_sales, recurring_redemptions, retail buckets

3. Compute WashResult from wash_transactions + prepaid_transactions:
   - wash_count = len(wash_transactions)
   - prepaid_wash_count = len(prepaid_transactions)
   - total = wash_count + prepaid_wash_count

4. Compute new_memberships from status_changes:
   - activations = [c for c in status_changes if c.new_status == "Active"]
   - new_memberships = len(activations)

5. Compute ConversionResult from wash_count + new_memberships:
   - retail_washes = wash_count (reuse from step 3 — no extra API call)
   - total_opportunities = new_memberships + retail_washes
   - rate = new_memberships / total_opportunities if total_opportunities > 0 else 0.0

6. Resolve period dates for the report metadata:
   - start_dt, end_dt = parse_date_range(start, end)
   - period_start = start_dt.date().isoformat()
   - period_end = end_dt.date().isoformat()

7. Return StatsReport(sales=sales, washes=washes, new_memberships=new_memberships, conversion=conversion, period_start=period_start, period_end=period_end)

Add StatsReport to imports at top of file. Add parse_date_range to imports if not already present (it is already imported).

Add Google-style docstring following existing method patterns: describe efficiency benefit (4 API calls vs 7), Args (start, end), Returns (StatsReport), Raises (ValueError for bad dates), Example usage showing access to sub-results.</action>
  <verify>python -m pytest tests/ passes (all existing tests). Manual: python -c "from sonnys_data_client.resources._stats import StatsResource; print('report' in dir(StatsResource))" returns True.</verify>
  <done>report(start, end) returns StatsReport with all KPIs computed from 4 shared data fetches. All existing tests pass.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -m pytest tests/` — all tests pass
- [ ] `python -c "from sonnys_data_client import StatsReport"` — importable
- [ ] `python -c "from sonnys_data_client import SonnysClient; print('report' in dir(SonnysClient('x','y','z').stats))"` — method exists on client.stats
- [ ] StatsReport has sales, washes, new_memberships, conversion, period_start, period_end fields
- [ ] StatsReport.sales is SalesResult type
- [ ] StatsReport.washes is WashResult type
- [ ] StatsReport.conversion is ConversionResult type
- [ ] report() makes exactly 4 fetch calls (v2, wash, prepaid-wash, recurring status changes)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- report() efficiently composes all KPIs with shared data fetching
- StatsReport model nests existing result models for type-safe access
- Zero-division edge case handled in conversion computation
</success_criteria>

<output>
After completion, create `.planning/phases/25-stats-report/25-01-SUMMARY.md`
</output>
