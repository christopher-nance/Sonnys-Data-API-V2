---
phase: 04-response-models
plan: 01
type: execute
---

<objective>
Define the SonnysModel base class, all transaction-related Pydantic v2 models, and customer models.

Purpose: Establish the base model pattern (snake_case fields with camelCase aliases) and cover the two largest/most complex resource types — transactions (9 models) and customers (3 models).
Output: `_base.py`, `_transactions.py`, `_customers.py` under `src/sonnys_data_client/types/`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/sonnys_data_client/__init__.py
@src/sonnys_data_client/types/__init__.py
@bo-data-open-api.yml

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:**
- src layout: all package code under src/sonnys_data_client/
- Underscore-prefixed internals (_base.py, _transactions.py) — public API via __init__.py only
- Python 3.10+ native type syntax (str | None, not Optional[str])

**Constraining decisions:**
- Phase 1: Underscore-prefixed internals, Python 3.10+ native type syntax
- Phase 2: 5xx fallback to ServerError, defensive JSON parsing patterns

**Design decisions for this phase:**
- Base model `SonnysModel(BaseModel)` with `ConfigDict(populate_by_name=True, alias_generator=to_camel)` — enables snake_case Python fields with automatic camelCase JSON aliases
- Use `Literal[...]` for small fixed enums (TransType, TransactionStatus, tender types)
- Use `float` for API number/float fields, `int` for integer fields, `str` for string fields
- Nullable fields: `str | None = None` pattern
- Explicit `Field(alias="...")` only for non-standard camelCase fields (e.g., `siteID` instead of `siteId`)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SonnysModel base class and transaction sub-models</name>
  <files>src/sonnys_data_client/types/_base.py, src/sonnys_data_client/types/_transactions.py</files>
  <action>
**_base.py:**
Create `SonnysModel(BaseModel)` with:
```python
from pydantic import BaseModel, ConfigDict
from pydantic.alias_generators import to_camel

class SonnysModel(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
        alias_generator=to_camel,
    )
```

**_transactions.py — sub-models only (main models in Task 2):**

1. `TransactionTender(SonnysModel)` — fields from OpenAPI TransactionTenderObject:
   - tender: str (enum: Cash, Credit, Debit, Void, Alt-Currency, Check, Prepaid, Coupon, Paid On Account, Prepaid 3rd Party, Fleet, Prepaid Wash)
   - tender_sub_type: str | None = None (enum: Visa, MasterCard, Discover, Amex, Giftcard, Washbook, Washbook Recurring, RFID, RFID Recurring, XpressWash, Code, Hamilton Fleet, Hamilton Value, 3rd Party Interface, House Account Card, Voyager, Other, P-Card, House Account RFID, LPR, Debit)
   - amount: float
   - change: float
   - total: float
   - reference_number: str | None = None
   - credit_card_last_four: str | None = None
   - credit_card_expiration_date: str | None = None

2. `TransactionItem(SonnysModel)` — fields from OpenAPI TransactionItemObject:
   - name: str
   - sku: str | None = None
   - department: str
   - quantity: int
   - gross: float
   - net: float
   - discount: float
   - tax: float
   - additional_fee: float
   - is_voided: bool

3. `TransactionDiscount(SonnysModel)` — fields from OpenAPI TransactionDiscountObject:
   - discount_name: str
   - discount_sku: str | None = None
   - applied_to_item_name: str
   - discount: float
   - discount_code: str

Use `from __future__ import annotations` is NOT needed — use runtime types per Phase 1 decision.
  </action>
  <verify>python -c "from sonnys_data_client.types._base import SonnysModel; from sonnys_data_client.types._transactions import TransactionTender, TransactionItem, TransactionDiscount; print('OK')"</verify>
  <done>SonnysModel base class exists with ConfigDict. TransactionTender, TransactionItem, TransactionDiscount importable with correct fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create transaction main models</name>
  <files>src/sonnys_data_client/types/_transactions.py</files>
  <action>
Add to _transactions.py:

1. `TransactionListItem(SonnysModel)` — from OpenAPI TransactionListItemObject:
   - trans_number: int
   - trans_id: str
   - total: float
   - date: str

2. `TransactionV2ListItem(TransactionListItem)` — extends TransactionListItem, from OpenAPI TransactionListItemVersion2Object:
   - customer_id: str | None = None
   - is_recurring_plan_sale: bool
   - is_recurring_plan_redemption: bool
   - transaction_status: str (enum: Incomplete, In-Progress, Completed, Suspended, Voided, Recalled, Pre-Sell, N/A)

3. `Transaction(SonnysModel)` — from OpenAPI TransactionObject (the detail model):
   - id: str
   - number: int
   - type: str (enum: Sale, Return, Rewash)
   - complete_date: str
   - location_code: str
   - sales_device_name: str
   - total: float
   - tenders: list[TransactionTender]
   - items: list[TransactionItem]
   - customer_name: str | None = None
   - customer_id: str | None = None
   - vehicle_license_plate: str | None = None
   - employee_cashier: str | None = None
   - employee_greeter: str | None = None
   - discount: list[TransactionDiscount]
   - is_recurring_payment: bool
   - is_recurring_redemption: bool
   - is_recurring_sale: bool
   - is_prepaid_redemption: bool
   - is_prepaid_sale: bool

4. `TransactionJobItem(Transaction)` — extends Transaction, from OpenAPI TransactionListJobObject:
   - customer_id: str | None = None (already on Transaction, but re-declared per spec allOf)
   - is_recurring_plan_sale: bool
   - is_recurring_plan_redemption: bool
   - transaction_status: str

Note: TransactionJobItem extends Transaction (full detail) + adds v2 fields. This matches the OpenAPI allOf on TransactionObject.
  </action>
  <verify>python -c "from sonnys_data_client.types._transactions import TransactionListItem, TransactionV2ListItem, Transaction, TransactionJobItem; t = Transaction(id='1:2', number=1, type='Sale', complete_date='2020-01-01', location_code='MAIN', sales_device_name='POS1', total=10.0, tenders=[], items=[], discount=[], is_recurring_payment=False, is_recurring_redemption=False, is_recurring_sale=False, is_prepaid_redemption=False, is_prepaid_sale=False); print(t.model_dump_json(by_alias=True)[:80])"</verify>
  <done>All 4 transaction models importable. Transaction instantiates with nested sub-objects. model_dump_json produces camelCase keys.</done>
</task>

<task type="auto">
  <name>Task 3: Create customer models</name>
  <files>src/sonnys_data_client/types/_customers.py</files>
  <action>
Create _customers.py with:

1. `Address(SonnysModel)` — from OpenAPI AddressObject:
   - address1: str | None = None
   - address2: str | None = None
   - city: str | None = None
   - state: str | None = None
   - country: str | None = None
   - postal_code: str | None = None

2. `CustomerListItem(SonnysModel)` — from OpenAPI CustomerListItemObject:
   - customer_id: str
   - first_name: str
   - last_name: str
   - phone_number: str | None = None
   - customer_number: str | None = None
   - is_active: bool
   - created_date: str
   - modified_date: str

3. `Customer(SonnysModel)` — from OpenAPI CustomerObject (detail):
   - id: str
   - number: str
   - first_name: str
   - last_name: str
   - company_name: str
   - loyalty_number: str
   - address: Address
   - phone: str
   - email: str | None = None
   - birth_date: str | None = None
   - is_active: bool
   - allow_sms: bool
   - recurring_sms_signup_date: str | None = None
   - loyalty_sms_signup_date: str | None = None
   - modify_date: str
  </action>
  <verify>python -c "from sonnys_data_client.types._customers import Address, CustomerListItem, Customer; a = Address(); c = Customer(id='1:2', number='001', first_name='John', last_name='Doe', company_name='', loyalty_number='', address=a, phone='555', is_active=True, allow_sms=True, modify_date='2020-01-01'); print(c.model_dump(by_alias=True)['firstName'])"</verify>
  <done>Address, CustomerListItem, Customer importable. Customer.address is nested Address object. camelCase aliases work correctly.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from sonnys_data_client.types._base import SonnysModel"` succeeds
- [ ] `python -c "from sonnys_data_client.types._transactions import TransactionTender, TransactionItem, TransactionDiscount, TransactionListItem, TransactionV2ListItem, Transaction, TransactionJobItem"` succeeds
- [ ] `python -c "from sonnys_data_client.types._customers import Address, CustomerListItem, Customer"` succeeds
- [ ] camelCase alias generation works: `SonnysModel` subclass with `some_field` produces `someField` in JSON output
- [ ] Nested objects work: `Transaction.tenders` accepts list of `TransactionTender` dicts
- [ ] Nullable fields accept None: `Address()` creates instance with all None fields
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- 12 models defined across 3 files (_base.py, _transactions.py, _customers.py)
- camelCase JSON serialization works via alias_generator
- No import errors or type issues
</success_criteria>

<output>
After completion, create `.planning/phases/04-response-models/04-01-SUMMARY.md`
</output>
