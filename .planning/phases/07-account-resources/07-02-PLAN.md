---
phase: 07-account-resources
plan: 02
type: execute
---

<objective>
Implement Recurring resource class with all 5 API endpoints and wire into SonnysClient, completing Phase 7.

Purpose: Provide `client.recurring.list()`, `client.recurring.get(id)`, `client.recurring.list_status_changes()`, `client.recurring.list_modifications()`, and `client.recurring.list_details()` — finishing all account resources.
Output: Recurring resource module with custom paginated methods, updated SonnysClient with all 7 resource properties, full Phase 7 verification.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-account-resources/07-01-SUMMARY.md

# Key source files:
@src/sonnys_data_client/_resources.py
@src/sonnys_data_client/_client.py
@src/sonnys_data_client/__init__.py
@src/sonnys_data_client/resources/__init__.py
@src/sonnys_data_client/resources/_employees.py
@src/sonnys_data_client/types/_recurring.py

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** mixin-based resource classes, cached_property wiring, custom resource methods (see Employees.get_clock_entries for precedent)
**Constraining decisions:**
- Phase 05: ListableResource/GettableResource as independent mixins
- Phase 06-01: cached_property pattern for wiring resources
- Phase 06-02: Custom resource methods pattern for non-standard API shapes (get_clock_entries)
- Phase 04: RecurringStatusChange has alias_generator=None (API returns snake_case for this endpoint)
- Phase 04: RecurringModification extends Recurring with modifications list
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Recurring resource class with all endpoints</name>
  <files>src/sonnys_data_client/resources/_recurring.py</files>
  <action>
Create a Recurring resource class that covers all 5 API endpoints.

**Standard list + get (via mixins):**
- Inherit from ListableResource AND GettableResource
- `_path = "/recurring/account/list"`
- `_items_key = "accounts"`
- `_model = RecurringListItem` (from types._recurring)
- `_default_limit = 100`
- `_paginated = True`
- `_detail_path = "/recurring/account/{id}/detail"`
- `_detail_model = Recurring` (from types._recurring)

**Private pagination helper:**
Add a `_paginated_fetch` method to avoid duplicating the pagination loop across 3 custom methods:

```python
def _paginated_fetch(
    self,
    path: str,
    items_key: str,
    model: type[SonnysModel],
    limit: int = 100,
    **params: object,
) -> list[SonnysModel]:
```
- Same pagination logic as ListableResource._list_paginated: offset starts at 1, increments by limit, stops when offset > total
- Calls `self._client._request("GET", path, params={...})` with limit, offset, and **params
- Returns list of validated model instances
- Import SonnysModel from types._base for the type annotation

**Custom method 1 — list_status_changes:**
```python
def list_status_changes(self, **params: object) -> list[RecurringStatusChange]:
```
- Calls `self._paginated_fetch("/recurring/account/status-list", "accounts", RecurringStatusChange, **params)`
- Returns flat list of RecurringStatusChange instances
- NOTE: RecurringStatusChange has alias_generator=None (API returns snake_case for this endpoint — Phase 4 decision)

**Custom method 2 — list_modifications:**
```python
def list_modifications(self, **params: object) -> list[RecurringModification]:
```
- Calls `self._paginated_fetch("/recurring/account/modifications", "accounts", RecurringModification, **params)`
- Returns flat list of RecurringModification instances (which extend Recurring with modifications list)

**Custom method 3 — list_details:**
```python
def list_details(self, **params: object) -> list[Recurring]:
```
- Calls `self._paginated_fetch("/recurring/account/details/list", "accounts", Recurring, **params)`
- Returns flat list of full Recurring detail objects
- This is different from list() which returns RecurringListItem (summary objects)

**Imports needed:**
- `from sonnys_data_client._resources import GettableResource, ListableResource`
- `from sonnys_data_client.types._base import SonnysModel`
- `from sonnys_data_client.types._recurring import Recurring, RecurringListItem, RecurringModification, RecurringStatusChange`

Follow existing module conventions: `from __future__ import annotations`, module docstring, imports, class.
  </action>
  <verify>python -c "from sonnys_data_client.resources._recurring import RecurringAccounts; r = None; print([m for m in dir(RecurringAccounts) if not m.startswith('__')])"</verify>
  <done>RecurringAccounts class has list(), get(), list_status_changes(), list_modifications(), list_details() methods. Importable without errors. _paginated_fetch helper exists as private method.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Recurring into SonnysClient and complete Phase 7</name>
  <files>src/sonnys_data_client/_client.py, src/sonnys_data_client/resources/__init__.py, src/sonnys_data_client/__init__.py</files>
  <action>
**resources/__init__.py:**
Add RecurringAccounts export alongside existing resource classes. Add to __all__.

**_client.py:**
- Import RecurringAccounts at module level from sonnys_data_client.resources
- Add `recurring` as `@functools.cached_property` on SonnysClient returning `RecurringAccounts(self)`

**__init__.py:**
Add RecurringAccounts to imports from sonnys_data_client.resources and to __all__.

**Class name note:** Use `RecurringAccounts` (not `Recurring`) to avoid name collision with the `Recurring` Pydantic model from types._recurring. This follows the pattern of distinguishing resource classes from model classes — all other resources happen to not collide, but this one does.

Verify complete resource surface after wiring:
- client.customers → Customers (list + get)
- client.items → Items (list)
- client.employees → Employees (list + get + get_clock_entries)
- client.sites → Sites (list, non-paginated)
- client.giftcards → Giftcards (list)
- client.washbooks → Washbooks (list + get)
- client.recurring → RecurringAccounts (list + get + list_status_changes + list_modifications + list_details)
  </action>
  <verify>python -c "from sonnys_data_client import SonnysClient, RecurringAccounts; c = SonnysClient('x','y'); print(type(c.recurring).__name__); print([m for m in dir(c.recurring) if not m.startswith('_')])"</verify>
  <done>All 7 resources accessible as client properties, all exported from package, no import errors, all prior tests pass, no lint errors. Phase 7 complete.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from sonnys_data_client import SonnysClient, Giftcards, Washbooks, RecurringAccounts"` — no import errors
- [ ] `python -c "c = SonnysClient('x','y'); print(type(c.giftcards).__name__, type(c.washbooks).__name__, type(c.recurring).__name__)"` — prints "Giftcards Washbooks RecurringAccounts"
- [ ] `python -c "r = type('', (), {'recurring': property(lambda s: __import__('sonnys_data_client.resources._recurring', fromlist=['RecurringAccounts']).RecurringAccounts)})(); print([m for m in dir(__import__('sonnys_data_client.resources._recurring', fromlist=['RecurringAccounts']).RecurringAccounts) if not m.startswith('_')])"` — shows list, get, list_status_changes, list_modifications, list_details
- [ ] `pytest tests/ -x -q` — all tests pass
- [ ] `ruff check src/sonnys_data_client/` — no lint errors
- [ ] Phase 7 complete: all 3 account resources implemented
</verification>

<success_criteria>

- RecurringAccounts resource supports list(), get(), list_status_changes(), list_modifications(), list_details()
- _paginated_fetch helper avoids pagination loop duplication
- All 7 resources wired into SonnysClient
- All verification checks pass
- No circular imports
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-account-resources/07-02-SUMMARY.md`
</output>
