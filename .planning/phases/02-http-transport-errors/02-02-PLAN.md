---
phase: 02-http-transport-errors
plan: 02
type: tdd
---

<objective>
Implement error body parsing and status-code-to-exception mapping via TDD.

Purpose: The error mapping logic is the core business logic of Phase 2 — it transforms raw HTTP responses into typed exceptions. TDD ensures every error path (13 Sonny's error types across 5 status codes, plus edge cases) is verified before and after implementation.
Output: Working, tested `parse_error_body()` and `make_status_error()` functions in `_exceptions.py`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-http-transport-errors/02-RESEARCH.md
@src/sonnys_data_client/_exceptions.py
@src/sonnys_data_client/__init__.py

# Prior plan in this phase:
@.planning/phases/02-http-transport-errors/02-01-SUMMARY.md

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** src layout, underscore-prefixed internals

**Constraining decisions:**
- Phase 2 Research: Flat JSON error bodies with `type` field (no envelope)
- Phase 2 Research: `PayloadValidationError` uses `messages` (plural, array) not `message`
- Phase 2 Research: `ServerUnexpectedFailure` has extra `code` field
- Phase 2 Research: Status code dispatch first, store `error_type` string for sub-type discrimination
</context>

<feature>
  <name>Error body parsing and status-code-to-exception mapping</name>
  <files>src/sonnys_data_client/_exceptions.py, tests/test_exceptions.py</files>
  <behavior>
    Two functions added to `_exceptions.py`:

    **`parse_error_body(response: requests.Response) -> dict`**
    - JSON body with dict → return dict as-is
    - JSON body with non-dict (string, array) → return `{"type": "Unknown", "message": str(body)}`
    - Non-JSON body (HTML, empty) → return `{"type": "Unknown", "message": response.text or "HTTP {status_code}"}`

    **`make_status_error(response: requests.Response) -> APIStatusError`**
    - 403 → AuthError with error_type from body
    - 429 → RateLimitError with error_type from body
    - 400 → ValidationError
    - 422 → ValidationError (PayloadValidationError uses `messages` array joined with "; ")
    - 404 → NotFoundError
    - 500 → ServerError
    - Other 5xx → ServerError
    - Other status → APIStatusError (fallback)
    - All exceptions store: message, status_code, body dict, error_type string

    Test cases (input → expected):
    - `{"type": "BadClientCredentialsError", "message": "Invalid credentials"}` + 403 → AuthError(message="Invalid credentials", error_type="BadClientCredentialsError")
    - `{"type": "RequestRateExceedError", "message": "Rate exceeded"}` + 429 → RateLimitError
    - `{"type": "PayloadValidationError", "messages": ["Field X invalid", "Field Y required"]}` + 422 → ValidationError(message="Field X invalid; Field Y required")
    - `{"type": "EntityNotFoundError", "message": "Not found"}` + 404 → NotFoundError
    - `{"type": "ServerUnexpectedFailure", "message": "Error", "code": "SCEC0001"}` + 500 → ServerError(body has code field)
    - `{"type": "InvalidPayloadRequestTimestampError", "message": "Bad timestamp"}` + 400 → ValidationError
    - `{"type": "UnexpectedFailure", "message": "Something went wrong"}` + 400 → ValidationError
    - HTML response body + 502 → ServerError(message contains response text)
    - Empty body + 503 → ServerError(message="HTTP 503")
    - Unknown status 418 → APIStatusError (base class fallback)
  </behavior>
  <implementation>
    Add to `_exceptions.py`:

    1. `_STATUS_MAP: dict[int, type[APIStatusError]]` — maps 400, 403, 404, 422, 429, 500 to exception classes.

    2. `parse_error_body(response)` — try `response.json()`, catch `ValueError`/`JSONDecodeError`, fall back to text. Return dict always.

    3. `make_status_error(response)` — call `parse_error_body`, extract `type` and `message`/`messages` fields, look up exception class from `_STATUS_MAP`, construct and return.

    Import `requests` at top of file (already a dependency). Use `requests.exceptions.JSONDecodeError` for catch (available in requests 2.28+, our version is 2.32.5).

    These are module-level functions (not methods on SonnysClient) — they take a `requests.Response` and return an exception. This makes them directly testable and keeps `_exceptions.py` self-contained.
  </implementation>
</feature>

<verification>
pytest tests/test_exceptions.py -v passes with all test cases green.
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed (REFACTOR)
- All 2-3 commits present
- `parse_error_body` handles JSON, non-JSON, and edge cases
- `make_status_error` maps all 5 status codes to correct exception types
- `error_type` and `body` preserved on every exception
</success_criteria>

<output>
After completion, create `.planning/phases/02-http-transport-errors/02-02-SUMMARY.md` with:
- RED: What tests were written, why they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
