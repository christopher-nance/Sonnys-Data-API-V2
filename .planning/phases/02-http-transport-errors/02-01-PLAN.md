---
phase: 02-http-transport-errors
plan: 01
type: execute
---

<objective>
Create the complete exception hierarchy for the Sonny's Data Client SDK.

Purpose: Establish typed exception classes that enable callers to catch specific error categories (auth, rate limit, validation, not found, server) with a clean two-branch tree — `APIConnectionError` for network failures, `APIStatusError` for HTTP error responses.
Output: `_exceptions.py` module with 8 exception classes, exported via `__init__.py`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-http-transport-errors/02-RESEARCH.md
@src/sonnys_data_client/_client.py
@src/sonnys_data_client/__init__.py

# Auto-selected based on dependency graph:
@.planning/phases/01-project-foundation/01-01-SUMMARY.md

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** src layout, underscore-prefixed internals, public API via __init__.py
**Constraining decisions:**
- Phase 1: Underscore-prefixed internals (_client.py, _version.py) — public API exposed only via __init__.py
- Phase 1: Python 3.10+ native type syntax (str | None) — no typing module imports
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception hierarchy module</name>
  <files>src/sonnys_data_client/_exceptions.py</files>
  <action>
Create `_exceptions.py` with the OpenAI two-branch exception hierarchy:

```
SonnysError (root)
├── APIError (all API interaction errors)
│   ├── APIConnectionError (no response received)
│   │   └── APITimeoutError (timeout specifically)
│   └── APIStatusError (HTTP error response received)
│       ├── AuthError (403)
│       ├── RateLimitError (429)
│       ├── ValidationError (400/422)
│       ├── NotFoundError (404)
│       └── ServerError (500)
```

Implementation details:
- `SonnysError(Exception)`: Root. Just `pass` body — standard exception `args` is sufficient.
- `APIError(SonnysError)`: Store `message: str` attribute. Call `super().__init__(message)`.
- `APIConnectionError(APIError)`: Default message `"Connection error."`. No extra fields.
- `APITimeoutError(APIConnectionError)`: Default message `"Request timed out."`. No extra fields.
- `APIStatusError(APIError)`: Store `status_code: int`, `body: dict | None`, `error_type: str | None`. The `error_type` field holds the Sonny's API `type` string (e.g., `"MissingClientCredentialsError"`) for callers who need sub-type discrimination within a status code.
- Leaf exceptions (`AuthError`, `RateLimitError`, `ValidationError`, `NotFoundError`, `ServerError`): Inherit from `APIStatusError`. No extra fields — just class identity for `except` dispatch.

Use Python 3.10+ type syntax (`dict | None`, not `Optional[dict]`). No `from __future__ import annotations` — use real runtime types so exception attributes are introspectable.

Do NOT add `__str__` or `__repr__` overrides — the default `Exception.__str__` returns the message, which is correct.
  </action>
  <verify>python -c "from sonnys_data_client._exceptions import SonnysError, APIError, APIConnectionError, APITimeoutError, APIStatusError, AuthError, RateLimitError, ValidationError, NotFoundError, ServerError; e = AuthError('test', status_code=403, body=None, error_type='BadClientCredentialsError'); assert isinstance(e, APIStatusError); assert isinstance(e, APIError); assert isinstance(e, SonnysError); assert e.status_code == 403; assert e.error_type == 'BadClientCredentialsError'; print('OK')"</verify>
  <done>All 8 exception classes exist with correct inheritance chain. APIStatusError stores status_code, body, and error_type. Leaf exceptions are catchable by parent type.</done>
</task>

<task type="auto">
  <name>Task 2: Export exception classes from public API</name>
  <files>src/sonnys_data_client/__init__.py</files>
  <action>
Update `__init__.py` to import and export all exception classes. Add them to `__all__`.

Import all 8 exceptions from `_exceptions`:
- SonnysError, APIError, APIConnectionError, APITimeoutError, APIStatusError
- AuthError, RateLimitError, ValidationError, NotFoundError, ServerError

Add all to `__all__` list alongside existing `SonnysClient` and `__version__`.

Keep existing imports. Add a blank line between the client import and exceptions import for readability.
  </action>
  <verify>python -c "from sonnys_data_client import SonnysClient, AuthError, RateLimitError, ValidationError, NotFoundError, ServerError, APIConnectionError, APITimeoutError, APIStatusError, APIError, SonnysError; print('All exports OK')"</verify>
  <done>`__init__.py` exports all 10 public names (SonnysClient, __version__, 8 exceptions). All importable from top-level package.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "import sonnys_data_client"` succeeds
- [ ] All 8 exception classes importable from `sonnys_data_client`
- [ ] Inheritance chain correct: `AuthError → APIStatusError → APIError → SonnysError → Exception`
- [ ] `APIStatusError` instances have `status_code`, `body`, `error_type` attributes
- [ ] `ruff check src/sonnys_data_client/_exceptions.py` passes (if ruff installed)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No import errors
- Exception hierarchy matches the two-branch tree design from research
</success_criteria>

<output>
After completion, create `.planning/phases/02-http-transport-errors/02-01-SUMMARY.md`
</output>
