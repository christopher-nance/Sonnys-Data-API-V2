---
phase: 02-http-transport-errors
plan: 03
type: execute
---

<objective>
Add the `_request()` HTTP transport method to SonnysClient, completing the Phase 2 transport layer.

Purpose: `_request()` is the single entry point for all HTTP communication — every resource class (Phase 5+) will call `self._client._request()`. It handles URL construction, timeouts, debug logging, connection error wrapping, and error response mapping.
Output: SonnysClient with a working `_request()` method that returns parsed JSON on success or raises typed exceptions on failure.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-http-transport-errors/02-RESEARCH.md
@src/sonnys_data_client/_client.py
@src/sonnys_data_client/_exceptions.py
@src/sonnys_data_client/__init__.py

# Prior plans in this phase:
@.planning/phases/02-http-transport-errors/02-01-SUMMARY.md
@.planning/phases/02-http-transport-errors/02-02-SUMMARY.md

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** src layout, underscore-prefixed internals, context manager protocol, auth headers via Session

**Constraining decisions:**
- Phase 1: Auth headers set on Session at init — `_request()` does NOT touch auth
- Phase 2 Research: Default timeout `(3.05, 30)` — connect aligns with TCP retransmission, 30s read
- Phase 2 Research: Use `logging.getLogger("sonnys_data_client")` for debug logs
- Phase 2 Research: Do NOT use `raise_for_status()` — need body for error mapping
- Phase 2 Research: Catch `requests.Timeout` → `APITimeoutError`, `requests.ConnectionError` → `APIConnectionError`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout parameter and _request() method</name>
  <files>src/sonnys_data_client/_client.py</files>
  <action>
Modify `SonnysClient` in `_client.py`:

1. **Add imports at top:**
   - `from __future__ import annotations` (already present)
   - `import logging`
   - `from typing import Any`
   - `from sonnys_data_client._exceptions import APIConnectionError, APITimeoutError, make_status_error`

2. **Add module-level logger:**
   ```python
   log = logging.getLogger("sonnys_data_client")
   ```

3. **Add class constant:**
   ```python
   DEFAULT_TIMEOUT: tuple[float, float] = (3.05, 30)
   ```

4. **Update `__init__` signature** — add `timeout` parameter:
   ```python
   def __init__(
       self,
       api_id: str,
       api_key: str,
       site_code: str | None = None,
       timeout: float | tuple[float, float] | None = None,
   ) -> None:
   ```
   Store as `self._timeout = timeout or self.DEFAULT_TIMEOUT`.

5. **Add `_request()` method:**
   ```python
   def _request(
       self,
       method: str,
       path: str,
       *,
       params: dict[str, Any] | None = None,
       json: dict[str, Any] | None = None,
       timeout: float | tuple[float, float] | None = None,
   ) -> dict[str, Any]:
   ```
   Implementation:
   - Build URL: `f"{self.BASE_URL}/{path.lstrip('/')}"`
   - Resolve timeout: `timeout or self._timeout`
   - Log request: `log.debug("%s %s", method, url)`
   - Send via `self._session.request(method, url, params=params, json=json, timeout=effective_timeout)`
   - Catch `requests.Timeout` → raise `APITimeoutError()` from err
   - Catch `requests.ConnectionError` → raise `APIConnectionError(str(err))` from err
   - Log response: `log.debug("Response %s %s", response.status_code, url)`
   - If status not 2xx: `raise make_status_error(response)`
   - Return `response.json()`

Do NOT add retry logic here — that's Phase 3 (Rate Limiting). Keep `_request()` simple: send, check, return or raise.

Do NOT wrap `response.json()` on success in try/except — if a 200 response has invalid JSON, that's a genuine bug that should surface immediately, not be silently swallowed.
  </action>
  <verify>python -c "from sonnys_data_client import SonnysClient; c = SonnysClient('test', 'test'); assert hasattr(c, '_request'); assert c._timeout == (3.05, 30); print('OK')"</verify>
  <done>`_request()` method exists on SonnysClient with correct signature. Default timeout is (3.05, 30). Logger configured as "sonnys_data_client".</done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end error handling paths</name>
  <files>tests/test_client.py</files>
  <action>
Create `tests/test_client.py` with focused tests verifying `_request()` integrates correctly with the exception hierarchy. Use `unittest.mock.patch` to mock `self._session.request`.

Tests to write:

1. **test_request_success** — Mock response with status 200 and JSON body `{"data": {"id": 1}}`. Assert `_request("GET", "/test")` returns the parsed dict.

2. **test_request_auth_error** — Mock response with status 403 and JSON body `{"type": "BadClientCredentialsError", "message": "Invalid"}`. Assert `_request` raises `AuthError` with correct `status_code`, `error_type`, and `message`.

3. **test_request_timeout** — Mock `session.request` to raise `requests.Timeout`. Assert `_request` raises `APITimeoutError`.

4. **test_request_connection_error** — Mock `session.request` to raise `requests.ConnectionError("DNS failed")`. Assert `_request` raises `APIConnectionError` with message containing "DNS failed".

5. **test_request_custom_timeout** — Create client with `timeout=10`. Assert `c._timeout == 10`. Create client with default. Assert `c._timeout == (3.05, 30)`.

Use `pytest` style (functions, not classes). Import from `sonnys_data_client` (public API) for exception types. Access `_request` directly on client instance.

Mock target: `sonnys_data_client._client.requests.Session.request` or patch `client._session.request` directly on the instance.
  </action>
  <verify>pytest tests/test_client.py -v — all 5 tests pass</verify>
  <done>All 5 integration tests pass. `_request()` correctly returns JSON on success, raises typed exceptions on HTTP errors, wraps connection/timeout errors. Phase 2 complete.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pytest tests/ -v` — all tests pass (test_exceptions.py from 02-02 + test_client.py from 02-03)
- [ ] `python -c "from sonnys_data_client import SonnysClient, AuthError, RateLimitError"` — imports work
- [ ] `ruff check src/sonnys_data_client/` passes (if ruff available)
- [ ] No circular imports between `_client.py` and `_exceptions.py`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- `_request()` handles: success (return JSON), HTTP errors (typed exceptions), timeouts, connection failures
- No retry logic added (that's Phase 3)
- Phase 2 complete — transport layer and error handling fully operational
</success_criteria>

<output>
After completion, create `.planning/phases/02-http-transport-errors/02-03-SUMMARY.md`:

Include "Phase 2 complete" in the Next Step section since this is the last plan in the phase.
</output>
