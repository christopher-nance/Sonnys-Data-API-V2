---
phase: 22-wash-analytics
plan: 01
type: execute
---

<objective>
Implement `client.stats.total_washes(start, end)` and `client.stats.retail_wash_count(start, end)` using transaction type filtering.

Purpose: Deliver wash volume analytics — total washes by payment type and retail-only count for conversion rate denominator (Phase 24).
Output: WashResult Pydantic model, two public methods on StatsResource, package exports wired.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph:
@.planning/phases/19-stats-foundation/19-02-SUMMARY.md
@.planning/phases/20-data-fetching/20-01-SUMMARY.md
@.planning/phases/21-revenue-sales/21-01-SUMMARY.md

# Key files:
@src/sonnys_data_client/resources/_stats.py
@src/sonnys_data_client/types/_stats.py
@src/sonnys_data_client/types/__init__.py
@src/sonnys_data_client/__init__.py

**Tech stack available:** Pydantic v2 models, BaseResource, StatsResource computation layer
**Established patterns:**
- StatsResource as client-side computation layer — stat methods call _fetch_* and aggregate
- _resolve_dates() for validated date range → Unix timestamp dict
- _fetch_transactions_by_type(start, end, item_type) returns list[TransactionListItem] filtered by type
- SalesResult pattern: dedicated Pydantic model per stat method with breakdown fields
- SonnysModel base class for all models
- types/_stats.py for stat result models, types/__init__.py + package __init__.py re-exports

**Constraining decisions:**
- Phase 19: StatsResource extends BaseResource only — computation layer, not API-wrapping
- Phase 20: No caching/memoization — efficiency from report() calling _fetch_transactions_v2() once in Phase 25
- Phase 20: _fetch_transactions_by_type() delegates to transactions.list_by_type() with date validation
- Phase 21: Stat methods return dedicated result models (SalesResult pattern), not raw dicts or tuples
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WashResult model and wire package exports</name>
  <files>src/sonnys_data_client/types/_stats.py, src/sonnys_data_client/types/__init__.py, src/sonnys_data_client/__init__.py</files>
  <action>
Add a `WashResult` Pydantic model to `src/sonnys_data_client/types/_stats.py` (below existing SalesResult), extending `SonnysModel`:

Fields:
- `total: int` — total wash count (wash_count + prepaid_wash_count)
- `wash_count: int` — retail wash transactions (type "wash")
- `prepaid_wash_count: int` — prepaid wash transactions (type "prepaid-wash")

Add Google-style docstring: "Wash volume breakdown returned by ``client.stats.total_washes()``." Explain the two wash categories.

Do NOT add camelCase aliases — these are computed results, not API response fields.

Wire exports:
- Add `WashResult` to the import from `sonnys_data_client.types._stats` in `types/__init__.py`
- Add `"WashResult"` to types/__init__.py `__all__` list (after "SalesResult", alphabetical)
- Add `WashResult` to the import from `sonnys_data_client.types` in package-level `__init__.py`
- Add `"WashResult"` to package __init__.py `__all__` list (after "SalesResult", alphabetical)
  </action>
  <verify>python -c "from sonnys_data_client import WashResult; r = WashResult(total=150, wash_count=100, prepaid_wash_count=50); print(r)"</verify>
  <done>WashResult importable from both sonnys_data_client.types and sonnys_data_client, all 3 fields validated by Pydantic</done>
</task>

<task type="auto">
  <name>Task 2: Implement total_washes() and retail_wash_count() on StatsResource</name>
  <files>src/sonnys_data_client/resources/_stats.py</files>
  <action>
Import WashResult from types._stats at the top of the file (alongside existing SalesResult import).

**Method 1: `total_washes(self, start, end) -> WashResult`**

1. Call `self._fetch_transactions_by_type(start, end, "wash")` → retail wash transactions
2. Call `self._fetch_transactions_by_type(start, end, "prepaid-wash")` → prepaid wash transactions
3. Count each list with len()
4. Return WashResult(total=wash_count + prepaid_wash_count, wash_count=wash_count, prepaid_wash_count=prepaid_wash_count)

Add Google-style docstring with Args (start, end), Returns (WashResult), Raises (ValueError), and Example:
```python
result = client.stats.total_washes("2026-01-01", "2026-01-31")
print(f"Total washes: {result.total}")
print(f"Retail: {result.wash_count}, Prepaid: {result.prepaid_wash_count}")
```

**Method 2: `retail_wash_count(self, start, end) -> int`**

1. Call `self._fetch_transactions_by_type(start, end, "wash")` → retail wash transactions
2. Return len(transactions)

Add Google-style docstring with Args (start, end), Returns (int), Raises (ValueError), and Example:
```python
count = client.stats.retail_wash_count("2026-01-01", "2026-01-31")
print(f"Retail washes: {count}")
```

Note: retail_wash_count() makes its own API call rather than calling total_washes() — each method is independently usable. Efficiency optimization deferred to report() in Phase 25.

Place both methods after total_sales(), alphabetically (retail_wash_count before total_sales won't work — place total_washes after total_sales, retail_wash_count before total_sales).
  </action>
  <verify>python -c "from sonnys_data_client.resources._stats import StatsResource; print('total_washes' in dir(StatsResource) and 'retail_wash_count' in dir(StatsResource))"</verify>
  <done>Both methods exist on StatsResource with correct signatures, return types, and docstrings</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from sonnys_data_client import WashResult, StatsResource"` succeeds
- [ ] `python -c "from sonnys_data_client.types import WashResult"` succeeds
- [ ] WashResult model validates all 3 fields correctly
- [ ] total_washes() and retail_wash_count() methods exist on StatsResource
- [ ] No import errors or circular dependencies
- [ ] Existing tests still pass
</verification>

<success_criteria>
- WashResult Pydantic model created with 3 fields (total, wash_count, prepaid_wash_count)
- total_washes() uses _fetch_transactions_by_type() for "wash" and "prepaid-wash" types
- retail_wash_count() uses _fetch_transactions_by_type() for "wash" type, returns int
- All exports wired (types/__init__.py + package __init__.py)
- Google-style docstrings on model and both methods
- No regressions in existing tests
- Phase 22 complete
</success_criteria>

<output>
After completion, create `.planning/phases/22-wash-analytics/22-01-SUMMARY.md`
</output>
