---
phase: 21-revenue-sales
plan: 01
type: execute
---

<objective>
Implement `client.stats.total_sales(start, end)` returning a SalesResult model with grand total and revenue breakdown by transaction category.

Purpose: First public stat method — delivers actionable revenue analytics from transaction data.
Output: SalesResult Pydantic model, total_sales() method on StatsResource, package exports wired.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph:
@.planning/phases/19-stats-foundation/19-02-SUMMARY.md
@.planning/phases/20-data-fetching/20-01-SUMMARY.md

# Key files:
@src/sonnys_data_client/resources/_stats.py
@src/sonnys_data_client/types/__init__.py
@src/sonnys_data_client/__init__.py
@src/sonnys_data_client/types/_transactions.py
@src/sonnys_data_client/types/_base.py

**Tech stack available:** Pydantic v2 models, BaseResource, StatsResource computation layer
**Established patterns:**
- StatsResource as client-side computation layer — stat methods call _fetch_* and aggregate
- _resolve_dates() for validated date range → Unix timestamp dict
- _fetch_transactions_v2() returns list[TransactionV2ListItem] with is_recurring_plan_sale, is_recurring_plan_redemption, transaction_status flags
- SonnysModel base class with camelCase aliases for all models
- types/ module per domain (e.g. _transactions.py, _recurring.py) with __init__.py re-exports

**Constraining decisions:**
- Phase 19: StatsResource extends BaseResource only — computation layer, not API-wrapping
- Phase 20: No caching/memoization — efficiency from report() calling _fetch_transactions_v2() once in Phase 25
- Phase 20: Thin delegation — _fetch_* validates dates and delegates to existing resource
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SalesResult model and wire package exports</name>
  <files>src/sonnys_data_client/types/_stats.py, src/sonnys_data_client/types/__init__.py, src/sonnys_data_client/__init__.py</files>
  <action>
Create `src/sonnys_data_client/types/_stats.py` with a `SalesResult` Pydantic model extending `SonnysModel`:

Fields (all float/int):
- `total: float` — grand total revenue (sum of all transaction totals)
- `count: int` — total number of transactions
- `recurring_plan_sales: float` — revenue from transactions where is_recurring_plan_sale=True
- `recurring_plan_sales_count: int` — count of those transactions
- `recurring_redemptions: float` — revenue from transactions where is_recurring_plan_redemption=True
- `recurring_redemptions_count: int` — count of those transactions
- `retail: float` — revenue from transactions where neither recurring flag is True
- `retail_count: int` — count of those transactions

Add Google-style docstring matching established convention (see types/_transactions.py models for style).

Wire exports:
- Add `from sonnys_data_client.types._stats import SalesResult` to `types/__init__.py` (after the _sites import, alphabetical)
- Add `"SalesResult"` to types/__init__.py `__all__` list
- Add `SalesResult` import and `__all__` entry to package-level `__init__.py` (import from types, add to __all__ after "Site")

Do NOT add aliases or camelCase field mapping — these are computed results, not API response fields.
  </action>
  <verify>python -c "from sonnys_data_client.types import SalesResult; r = SalesResult(total=100.0, count=5, recurring_plan_sales=60.0, recurring_plan_sales_count=2, recurring_redemptions=10.0, recurring_redemptions_count=1, retail=30.0, retail_count=2); print(r)"</verify>
  <done>SalesResult importable from both sonnys_data_client.types and sonnys_data_client, all 8 fields validated by Pydantic</done>
</task>

<task type="auto">
  <name>Task 2: Implement total_sales() method on StatsResource</name>
  <files>src/sonnys_data_client/resources/_stats.py</files>
  <action>
Add `total_sales(self, start, end) -> SalesResult` public method to StatsResource:

1. Import SalesResult from types._stats
2. Call `self._fetch_transactions_v2(start, end)` to get all v2 transactions in one fetch
3. Categorize each transaction using v2 boolean flags:
   - `is_recurring_plan_sale == True` → recurring_plan_sales bucket
   - `is_recurring_plan_redemption == True` → recurring_redemptions bucket
   - Neither flag True → retail bucket
   - Note: if both flags are somehow True, prioritize is_recurring_plan_sale (sale trumps redemption)
4. Sum `total` field for each bucket, count transactions per bucket
5. Return SalesResult with grand total (sum of all totals), total count, and per-bucket values

Add Google-style docstring with Args (start, end), Returns (SalesResult), Raises (ValueError for invalid dates), and an Example section showing usage:
```python
result = client.stats.total_sales("2026-01-01", "2026-01-31")
print(f"Total: ${result.total:.2f}")
print(f"Memberships: ${result.recurring_plan_sales:.2f}")
```

Keep implementation simple — single pass over the transaction list, no unnecessary abstractions.
  </action>
  <verify>python -c "from sonnys_data_client.resources._stats import StatsResource; print('total_sales' in dir(StatsResource))"</verify>
  <done>total_sales() method exists on StatsResource, accepts (start, end), returns SalesResult with correct categorization logic</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from sonnys_data_client import SalesResult, StatsResource"` succeeds
- [ ] `python -c "from sonnys_data_client.types import SalesResult"` succeeds
- [ ] SalesResult model validates all 8 fields correctly
- [ ] total_sales() method exists on StatsResource with proper signature
- [ ] No import errors or circular dependencies
</verification>

<success_criteria>
- SalesResult Pydantic model created with 8 fields (total, count, 3 category pairs)
- total_sales() method on StatsResource uses _fetch_transactions_v2() for single-fetch efficiency
- Transaction categorization via is_recurring_plan_sale / is_recurring_plan_redemption flags
- All exports wired (types/__init__.py + package __init__.py)
- Google-style docstrings on both model and method
- No regressions in existing tests
- Phase 21 complete
</success_criteria>

<output>
After completion, create `.planning/phases/21-revenue-sales/21-01-SUMMARY.md`
</output>
