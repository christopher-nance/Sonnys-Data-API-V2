---
phase: 03-rate-limiting
plan: 02
type: tdd
---

<objective>
Implement the `_request()` method on SonnysClient that integrates rate limiting, error handling, and 429 retry with exponential backoff.

Purpose: This is the core HTTP transport method — every API call flows through `_request()`. It ties together the rate limiter (Plan 03-01), exception mapping (Phase 2), and retry logic into one reliable request pipeline.
Output: Working, tested `_request()` method with full retry and rate limiting behavior.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-rate-limiting/03-01-SUMMARY.md

@src/sonnys_data_client/_client.py
@src/sonnys_data_client/_exceptions.py
@src/sonnys_data_client/_rate_limiter.py
@src/sonnys_data_client/__init__.py

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** src-layout, underscore-prefixed internals, keyword-only-args, mock-response-testing
**Constraining decisions:**
- Phase 02: `make_status_error(response)` maps HTTP responses to typed exceptions
- Phase 02: `parse_error_body(response)` extracts structured error info
- Plan 03-01: `RateLimiter.acquire()` returns wait time (0.0 or positive float)
- Phase 02: 429 → RateLimitError, 5xx fallback → ServerError
</context>

<feature>
  <name>HTTP request method with rate limiting and 429 retry</name>
  <files>src/sonnys_data_client/_client.py, tests/test_client.py</files>
  <behavior>
    SonnysClient._request(method, path, params=None) -> requests.Response

    Request pipeline:
    1. Rate limit: call self._rate_limiter.acquire(). If > 0, sleep that duration.
    2. Send: self._session.request(method, self.BASE_URL + path, params=params)
    3. Handle transport errors:
       - requests.ConnectionError → raise APIConnectionError
       - requests.Timeout → raise APITimeoutError
    4. Handle success: response.status_code < 400 → return response
    5. Handle 429 (rate limited by server):
       - If retries remaining: sleep with exponential backoff (1s, 2s, 4s), retry from step 1
       - If max retries exceeded: raise RateLimitError via make_status_error()
    6. Handle other errors: raise via make_status_error(response)

    Constructor changes to SonnysClient.__init__:
    - Create self._rate_limiter = RateLimiter() (per-instance, default 20/15s)
    - Add max_retries parameter (default 3) stored as self._max_retries

    Retry backoff: base_delay * (2 ** attempt) where base_delay=1.0
    - Attempt 0: 1s, Attempt 1: 2s, Attempt 2: 4s

    Test cases (all using mocked session, mocked time.sleep, mocked rate limiter):
    - Successful GET: returns response when status < 400
    - Params forwarded: params dict passed to session.request
    - Connection error: requests.ConnectionError → APIConnectionError
    - Timeout error: requests.Timeout → APITimeoutError
    - 403 error: raises AuthError via make_status_error
    - 404 error: raises NotFoundError via make_status_error
    - 500 error: raises ServerError via make_status_error
    - 429 retry success: first call 429, second call 200 → returns response (1 retry)
    - 429 retry exhausted: all calls 429 → raises RateLimitError after max_retries
    - 429 backoff timing: verify sleep called with 1, 2, 4 seconds
    - Rate limiter integration: acquire() called before each request
    - Rate limiter wait: when acquire() returns > 0, sleep is called with that value
  </behavior>
  <implementation>
    Modify `_client.py`:
    - Import: `from sonnys_data_client._rate_limiter import RateLimiter`
    - Import: `from sonnys_data_client._exceptions import (APIConnectionError, APITimeoutError, make_status_error, RateLimitError)`
    - Import: `import time`
    - Add `max_retries: int = 3` parameter to `__init__` (keyword-only, after site_code)
    - Create `self._rate_limiter = RateLimiter()` in `__init__`
    - Store `self._max_retries = max_retries`

    Add `_request` method:
    ```
    def _request(self, method: str, path: str, *, params: dict | None = None) -> requests.Response:
    ```
    - params is keyword-only (consistent with Phase 2 pattern)
    - Retry loop: `for attempt in range(self._max_retries + 1)`
    - Rate limit check: `wait = self._rate_limiter.acquire(); if wait > 0: time.sleep(wait)`
    - Try/except around session.request for ConnectionError and Timeout
    - Check response.status_code >= 400
    - Special case 429: if attempt < self._max_retries, sleep backoff and continue loop
    - Other errors: raise make_status_error(response) immediately (no retry)
    - Success: return response

    Testing approach:
    - Mock `self._session.request` to return controlled Response objects
    - Mock `time.sleep` to verify backoff timing without real delays
    - Mock `self._rate_limiter.acquire` to control rate limiter behavior
    - Use `requests.models.Response` with `_content` injection (established pattern from Phase 2 tests)
    - Create helper to build mock responses with status code and body
  </implementation>
</feature>

<verification>
pytest tests/test_client.py -v passes all tests
pytest tests/ -v passes ALL tests (including test_rate_limiter.py and test_exceptions.py)
ruff check src/sonnys_data_client/ passes
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- _request() implementation passes all tests (GREEN)
- Refactor if needed (REFACTOR)
- All 2-3 commits present
- _request() integrates rate limiter, error mapping, and 429 retry
- Exponential backoff verified (1s, 2s, 4s)
- Transport errors (ConnectionError, Timeout) mapped correctly
- All prior tests still pass (no regressions)
- Phase 3 complete — rate limiting fully operational
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limiting/03-02-SUMMARY.md` with:
- RED: What tests were written, how they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
- Note: Phase 3 complete — ready for Phase 4
</output>
