---
phase: 03-rate-limiting
plan: 01
type: tdd
---

<objective>
Implement a sliding window rate limiter that enforces the Sonny's API limit of 20 requests per 15-second window.

Purpose: Per-instance rate limiting prevents 429 responses proactively — the client self-throttles before hitting the API limit.
Output: Working, tested `RateLimiter` class in `_rate_limiter.py`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/01-project-foundation/01-01-SUMMARY.md
@.planning/phases/02-http-transport-errors/02-02-SUMMARY.md

@src/sonnys_data_client/_client.py
@src/sonnys_data_client/__init__.py

**Tech stack available:** hatchling, requests, pydantic, pytest, ruff
**Established patterns:** src-layout, underscore-prefixed internals, context-manager-protocol, keyword-only-args
**Constraining decisions:**
- Phase 01: Underscore-prefixed internals — `_rate_limiter.py` follows convention
- Phase 02: RateLimitError exists for 429 responses — rate limiter prevents hitting that path
</context>

<feature>
  <name>Sliding window rate limiter</name>
  <files>src/sonnys_data_client/_rate_limiter.py, tests/test_rate_limiter.py</files>
  <behavior>
    RateLimiter enforces a maximum number of requests within a sliding time window.

    Constructor: RateLimiter(max_requests=20, window_seconds=15.0)
    - Uses time.monotonic for clock (not wall clock — immune to system clock changes)
    - Stores timestamps in collections.deque for O(1) popleft

    Method: acquire() -> float
    - Purges timestamps older than window_seconds from front of deque
    - If len(timestamps) < max_requests: records current time, returns 0.0 (no wait needed)
    - If len(timestamps) >= max_requests: returns seconds until oldest timestamp exits window (positive float, does NOT sleep — caller decides)

    Method: reset() -> None
    - Clears all recorded timestamps (useful for testing or client reset)

    Property: available -> int
    - Returns number of requests available in current window (max_requests - active count after purge)

    Test cases:
    - acquire() returns 0.0 when under limit
    - acquire() returns 0.0 for exactly max_requests calls (boundary)
    - acquire() returns positive float when at limit (21st call)
    - After window elapses, acquire() returns 0.0 again (window slides)
    - reset() clears state, acquire() returns 0.0
    - available property reflects correct count
    - Constructor defaults: max_requests=20, window_seconds=15.0
    - Custom constructor values work (e.g., max_requests=3, window_seconds=1.0 for fast tests)
  </behavior>
  <implementation>
    Create `_rate_limiter.py` with:
    - `from collections import deque` and `import time`
    - `RateLimiter` class with `__init__`, `acquire`, `reset`, `available` property
    - Use `time.monotonic` (not `time.time`) — monotonic is immune to NTP adjustments and system clock changes
    - `acquire()` does NOT call `time.sleep()` — it returns the wait duration. The caller (_request method in Plan 03-02) handles sleeping. This keeps the rate limiter pure and testable.
    - Deque stores float timestamps from `time.monotonic()`
    - Purge logic: `while self._timestamps and self._timestamps[0] <= now - self._window_seconds`

    Testing approach:
    - Use `unittest.mock.patch("time.monotonic")` to control time in tests
    - Set monotonic to return controlled values, advance manually
    - Use small window (1.0s) and small max_requests (3) for fast, readable tests
    - Do NOT use real sleeps in tests — mock time completely
  </implementation>
</feature>

<verification>
pytest tests/test_rate_limiter.py -v passes all tests
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- RateLimiter implementation passes all tests (GREEN)
- Refactor if needed (REFACTOR)
- All 2-3 commits present
- acquire() returns 0.0 under limit, positive float at limit
- Window sliding works correctly
- No real time.sleep in tests — fully mocked
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limiting/03-01-SUMMARY.md` with:
- RED: What tests were written, how they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
