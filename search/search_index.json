{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Sonny's Data Client","text":"<p>A typed Python SDK for the Sonny's Carwash Controls Data API.</p> <p><code>sonnys-data-client</code> wraps the Sonny's Carwash Controls REST API with a resource-based interface. Every response is returned as a validated Pydantic v2 model, list calls auto-paginate transparently, and a built-in rate limiter keeps your application within the API's request window.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>8 resource types -- Customers, Employees, Giftcards, Items, Recurring Accounts, Sites, Transactions, and Washbooks</li> <li>Auto-pagination -- <code>.list()</code> calls transparently fetch all pages</li> <li>Rate limiting -- Built-in rate limiter with exponential-backoff retry</li> <li>Pydantic v2 models -- Fully typed responses with validation</li> <li>Batch jobs -- Long-running export operations with polling support</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/christopher-nance/Sonnys-Data-API-V2.git\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list(\n        startDate=\"2024-01-01\", endDate=\"2024-01-31\"\n    )\n    for txn in transactions:\n        print(txn.transaction_id, txn.total)\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Client -- <code>SonnysClient</code> constructor and configuration</li> <li>Resources -- Resource classes for each API endpoint</li> <li>Models -- Pydantic response models</li> <li>Exceptions -- Error types and exception hierarchy</li> </ul>"},{"location":"api/client/","title":"Client","text":""},{"location":"api/client/#sonnys_data_client.SonnysClient","title":"SonnysClient","text":"<pre><code>SonnysClient(\n    api_id: str,\n    api_key: str,\n    site_code: str | None = None,\n    *,\n    max_retries: int = 3,\n)\n</code></pre> <p>Client for the Sonny's Carwash Controls Data API.</p> <p>Manages authentication and HTTP session lifecycle. Use as a context manager or call :meth:<code>close</code> explicitly when done.</p> <p>Parameters:</p> Name Type Description Default <code>api_id</code> <code>str</code> <p>Sonny's API ID credential.</p> required <code>api_key</code> <code>str</code> <p>Sonny's API key credential.</p> required <code>site_code</code> <code>str | None</code> <p>Optional site code to scope requests to a specific site.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>Maximum number of retries for 429 responses.</p> <code>3</code>"},{"location":"api/client/#sonnys_data_client.SonnysClient.customers","title":"customers  <code>cached</code> <code>property</code>","text":"<pre><code>customers: Customers\n</code></pre> <p>Access the Customers resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.items","title":"items  <code>cached</code> <code>property</code>","text":"<pre><code>items: Items\n</code></pre> <p>Access the Items resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.employees","title":"employees  <code>cached</code> <code>property</code>","text":"<pre><code>employees: Employees\n</code></pre> <p>Access the Employees resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.giftcards","title":"giftcards  <code>cached</code> <code>property</code>","text":"<pre><code>giftcards: Giftcards\n</code></pre> <p>Access the Giftcards resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.sites","title":"sites  <code>cached</code> <code>property</code>","text":"<pre><code>sites: Sites\n</code></pre> <p>Access the Sites resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.transactions","title":"transactions  <code>cached</code> <code>property</code>","text":"<pre><code>transactions: Transactions\n</code></pre> <p>Access the Transactions resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.washbooks","title":"washbooks  <code>cached</code> <code>property</code>","text":"<pre><code>washbooks: Washbooks\n</code></pre> <p>Access the Washbooks resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.recurring","title":"recurring  <code>cached</code> <code>property</code>","text":"<pre><code>recurring: RecurringAccounts\n</code></pre> <p>Access the Recurring Accounts resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the underlying HTTP session.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; SonnysClient\n</code></pre>"},{"location":"api/client/#sonnys_data_client.SonnysClient.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: object) -&gt; None\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>All exceptions raised by the SDK inherit from <code>SonnysError</code>. The hierarchy is:</p> <pre><code>SonnysError\n  APIError\n    APIConnectionError\n      APITimeoutError\n    APIStatusError\n      AuthError\n      RateLimitError\n      ValidationError\n      NotFoundError\n      ServerError\n</code></pre> <p>Catch <code>SonnysError</code> to handle any SDK error, or catch specific subclasses for fine-grained control:</p> <pre><code>from sonnys_data_client import SonnysClient, AuthError, RateLimitError, SonnysError\n\ntry:\n    client.customers.list()\nexcept AuthError:\n    print(\"Invalid credentials\")\nexcept RateLimitError:\n    print(\"Too many requests\")\nexcept SonnysError:\n    print(\"Something else went wrong\")\n</code></pre>"},{"location":"api/exceptions/#sonnys_data_client.SonnysError","title":"SonnysError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/exceptions/#sonnys_data_client.APIError","title":"APIError","text":"<pre><code>APIError(message: str)\n</code></pre> <p>               Bases: <code>SonnysError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.APIConnectionError","title":"APIConnectionError","text":"<pre><code>APIConnectionError(message: str = 'Connection error.')\n</code></pre> <p>               Bases: <code>APIError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.APITimeoutError","title":"APITimeoutError","text":"<pre><code>APITimeoutError(message: str = 'Request timed out.')\n</code></pre> <p>               Bases: <code>APIConnectionError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.APIStatusError","title":"APIStatusError","text":"<pre><code>APIStatusError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.AuthError","title":"AuthError","text":"<pre><code>AuthError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.RateLimitError","title":"RateLimitError","text":"<pre><code>RateLimitError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.NotFoundError","title":"NotFoundError","text":"<pre><code>NotFoundError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p>"},{"location":"api/exceptions/#sonnys_data_client.ServerError","title":"ServerError","text":"<pre><code>ServerError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p>"},{"location":"api/models/","title":"Models","text":"<p>All response models are Pydantic v2 <code>BaseModel</code> subclasses. The API returns camelCase field names; each model uses <code>alias_generator = to_camel</code> so you can access fields with Pythonic snake_case attributes.</p> <pre><code>customer = client.customers.get(\"12345\")\nprint(customer.first_name)   # snake_case attribute\nprint(customer.model_dump(by_alias=True))  # camelCase dict\n</code></pre>"},{"location":"api/models/#customers","title":"Customers","text":""},{"location":"api/models/#sonnys_data_client.types.CustomerListItem","title":"CustomerListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.Customer","title":"Customer","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#items","title":"Items","text":""},{"location":"api/models/#sonnys_data_client.types.Item","title":"Item","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#employees","title":"Employees","text":""},{"location":"api/models/#sonnys_data_client.types.EmployeeListItem","title":"EmployeeListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.Employee","title":"Employee","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.ClockEntry","title":"ClockEntry","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sites","title":"Sites","text":""},{"location":"api/models/#sonnys_data_client.types.Site","title":"Site","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#giftcards","title":"Giftcards","text":""},{"location":"api/models/#sonnys_data_client.types.GiftcardListItem","title":"GiftcardListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#washbooks","title":"Washbooks","text":""},{"location":"api/models/#sonnys_data_client.types.WashbookListItem","title":"WashbookListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.Washbook","title":"Washbook","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.WashbookTag","title":"WashbookTag","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.WashbookVehicle","title":"WashbookVehicle","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#recurring","title":"Recurring","text":""},{"location":"api/models/#sonnys_data_client.types.RecurringListItem","title":"RecurringListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.Recurring","title":"Recurring","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.RecurringStatusChange","title":"RecurringStatusChange","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.RecurringModification","title":"RecurringModification","text":"<p>               Bases: <code>Recurring</code></p>"},{"location":"api/models/#transactions","title":"Transactions","text":""},{"location":"api/models/#sonnys_data_client.types.TransactionListItem","title":"TransactionListItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.TransactionV2ListItem","title":"TransactionV2ListItem","text":"<p>               Bases: <code>TransactionListItem</code></p>"},{"location":"api/models/#sonnys_data_client.types.Transaction","title":"Transaction","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.TransactionJobItem","title":"TransactionJobItem","text":"<p>               Bases: <code>Transaction</code></p>"},{"location":"api/models/#sonnys_data_client.types.TransactionTender","title":"TransactionTender","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.TransactionItem","title":"TransactionItem","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/models/#sonnys_data_client.types.TransactionDiscount","title":"TransactionDiscount","text":"<p>               Bases: <code>SonnysModel</code></p>"},{"location":"api/resources/","title":"Resources","text":"<p>Resources are the primary interface for interacting with the Sonny's Data API. Each resource is accessed as a property on the <code>SonnysClient</code> and exposes methods like <code>list()</code>, <code>get()</code>, and resource-specific operations.</p> <pre><code>with SonnysClient(api_id, api_key) as client:\n    customers = client.customers.list()\n    customer  = client.customers.get(\"12345\")\n</code></pre>"},{"location":"api/resources/#base-classes","title":"Base Classes","text":""},{"location":"api/resources/#sonnys_data_client._resources.BaseResource","title":"BaseResource","text":"<pre><code>BaseResource(client: SonnysClient)\n</code></pre> <p>Base class for all API resources.</p> <p>Stores a reference to the parent :class:<code>SonnysClient</code> so that subclasses can issue HTTP requests via <code>self._client._request()</code>.</p>"},{"location":"api/resources/#sonnys_data_client._resources.ListableResource","title":"ListableResource","text":"<pre><code>ListableResource(client: SonnysClient)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> <p>Mixin for resources that support a paginated (or non-paginated) list endpoint.</p> <p>Subclasses must define the following class attributes:</p> <ul> <li><code>_path</code>: URL path for the list endpoint (e.g., <code>\"/customer\"</code>).</li> <li><code>_items_key</code>: Key inside <code>data</code> that holds the items array   (e.g., <code>\"customers\"</code>).</li> <li><code>_model</code>: Pydantic model class to validate each item against.</li> <li><code>_default_limit</code>: Page size for paginated requests (default <code>100</code>).</li> <li><code>_paginated</code>: Whether the endpoint supports offset/limit pagination   (default <code>True</code>).  Set to <code>False</code> for endpoints like <code>/site</code> that   return all records in a single response.</li> </ul>"},{"location":"api/resources/#sonnys_data_client._resources.ListableResource.list","title":"list","text":"<pre><code>list(**params: object) -&gt; list[SonnysModel]\n</code></pre> <p>Fetch all items from the list endpoint.</p> <p>For paginated endpoints, automatically pages through all results using offset-based pagination (offset starts at 1 per API spec).</p> <p>For non-paginated endpoints (<code>_paginated=False</code>), makes a single request and returns all items.</p> <p>Parameters:</p> Name Type Description Default <code>**params</code> <code>object</code> <p>Extra query parameters forwarded to every request (e.g., <code>first_name=\"John\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[SonnysModel]</code> <p>A list of validated Pydantic model instances.</p>"},{"location":"api/resources/#sonnys_data_client._resources.GettableResource","title":"GettableResource","text":"<pre><code>GettableResource(client: SonnysClient)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> <p>Mixin for resources that support a detail (get-by-ID) endpoint.</p> <p>Subclasses must define the following class attributes:</p> <ul> <li><code>_detail_path</code>: URL path template with <code>{id}</code> placeholder   (e.g., <code>\"/customer/{id}\"</code>).</li> <li><code>_detail_model</code>: Pydantic model class to validate the detail   response against.</li> </ul>"},{"location":"api/resources/#sonnys_data_client._resources.GettableResource.get","title":"get","text":"<pre><code>get(id: str) -&gt; SonnysModel\n</code></pre> <p>Fetch a single resource by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The resource identifier, substituted into <code>_detail_path</code>.</p> required <p>Returns:</p> Type Description <code>SonnysModel</code> <p>A validated Pydantic model instance.</p>"},{"location":"api/resources/#concrete-resources","title":"Concrete Resources","text":""},{"location":"api/resources/#sonnys_data_client.resources.Customers","title":"Customers","text":"<pre><code>Customers(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /customer list and detail endpoints.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Items","title":"Items","text":"<pre><code>Items(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /item list endpoint.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Employees","title":"Employees","text":"<pre><code>Employees(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /employee list and detail endpoints.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Employees.get_clock_entries","title":"get_clock_entries","text":"<pre><code>get_clock_entries(\n    employee_id: int | str,\n    *,\n    start_date: str | None = None,\n    end_date: str | None = None,\n) -&gt; list[ClockEntry]\n</code></pre> <p>Fetch clock entries for an employee.</p> <p>The API returns a nested <code>data.weeks[]</code> structure where each week contains a <code>clockEntries[]</code> array.  This method flattens them into a single list.</p> <p>Parameters:</p> Name Type Description Default <code>employee_id</code> <code>int | str</code> <p>The employee identifier.</p> required <code>start_date</code> <code>str | None</code> <p>Optional start date filter (passed as <code>startDate</code>).</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>Optional end date filter (passed as <code>endDate</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ClockEntry]</code> <p>A flat list of validated :class:<code>ClockEntry</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Sites","title":"Sites","text":"<pre><code>Sites(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /site/list endpoint.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Giftcards","title":"Giftcards","text":"<pre><code>Giftcards(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /giftcard-liablilty list endpoint.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Washbooks","title":"Washbooks","text":"<pre><code>Washbooks(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /washbook/account list and detail endpoints.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts","title":"RecurringAccounts","text":"<pre><code>RecurringAccounts(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /recurring/account list, detail, and custom endpoints.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_status_changes","title":"list_status_changes","text":"<pre><code>list_status_changes(\n    **params: object,\n) -&gt; list[RecurringStatusChange]\n</code></pre> <p>Fetch all recurring account status changes.</p> <p>Returns:</p> Type Description <code>list[RecurringStatusChange]</code> <p>A flat list of :class:<code>RecurringStatusChange</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_modifications","title":"list_modifications","text":"<pre><code>list_modifications(\n    **params: object,\n) -&gt; list[RecurringModification]\n</code></pre> <p>Fetch all recurring account modifications.</p> <p>Returns:</p> Type Description <code>list[RecurringModification]</code> <p>A flat list of :class:<code>RecurringModification</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_details","title":"list_details","text":"<pre><code>list_details(**params: object) -&gt; list[Recurring]\n</code></pre> <p>Fetch all recurring accounts with full detail.</p> <p>Unlike :meth:<code>list</code> which returns summary :class:<code>RecurringListItem</code> objects, this method returns full :class:<code>Recurring</code> detail objects.</p> <p>Returns:</p> Type Description <code>list[Recurring]</code> <p>A flat list of :class:<code>Recurring</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions","title":"Transactions","text":"<pre><code>Transactions(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /transaction list, detail, and by-type endpoints.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.list_by_type","title":"list_by_type","text":"<pre><code>list_by_type(\n    item_type: str, **params: object\n) -&gt; list[TransactionListItem]\n</code></pre> <p>Fetch all transactions of a specific type.</p> <p>Valid types include: wash, prepaid-wash, recurring, washbook, giftcard, merchandise, house-account. The API validates the type parameter.</p> <p>Parameters:</p> Name Type Description Default <code>item_type</code> <code>str</code> <p>The transaction type to filter by.</p> required <code>**params</code> <code>object</code> <p>Extra query parameters forwarded to every request (e.g., <code>startDate</code>, <code>endDate</code>, <code>site</code>, <code>region</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[TransactionListItem]</code> <p>A flat list of :class:<code>TransactionListItem</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.list_v2","title":"list_v2","text":"<pre><code>list_v2(**params: object) -&gt; list[TransactionV2ListItem]\n</code></pre> <p>Fetch all transactions using the v2 endpoint.</p> <p>The v2 endpoint returns enriched list items with <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, and <code>transaction_status</code> fields.</p> <p>Note: The API caches v2 responses for 10 minutes per reporting criteria.</p> <p>Returns:</p> Type Description <code>list[TransactionV2ListItem]</code> <p>A flat list of :class:<code>TransactionV2ListItem</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.load_job","title":"load_job","text":"<pre><code>load_job(\n    *,\n    poll_interval: float = 2.0,\n    timeout: float = 300.0,\n    **params: object,\n) -&gt; list[TransactionJobItem]\n</code></pre> <p>Submit batch jobs and auto-paginate through all results.</p> <p>Pagination happens at the job submission level: each call to <code>/transaction/load-job</code> with a different <code>offset</code> fetches one page. The method submits as many jobs as needed to retrieve all records.</p> <p>Note: The API caches job data for 20 minutes and limits the date range to a maximum of 24 hours.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>Seconds between poll attempts (default 2.0).</p> <code>2.0</code> <code>timeout</code> <code>float</code> <p>Max seconds to wait for each job (default 300.0).</p> <code>300.0</code> <code>**params</code> <code>object</code> <p>Query parameters (<code>startDate</code>, <code>endDate</code>, <code>site</code>, <code>limit</code>, <code>offset</code>, etc.).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[TransactionJobItem]</code> <p>A list of :class:<code>TransactionJobItem</code> instances.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If any job status is <code>\"fail\"</code>.</p> <code>APITimeoutError</code> <p>If any job does not complete within timeout.</p>"},{"location":"guides/customers/","title":"Customers","text":"<p>The Customers resource provides access to car wash customer records. Each customer includes contact information, loyalty data, and an optional mailing address. Use this resource to retrieve customer lists or fetch full details for a single customer by ID.</p>"},{"location":"guides/customers/#methods","title":"Methods","text":""},{"location":"guides/customers/#listparams-listcustomerlistitem","title":"<code>list(**params) -&gt; list[CustomerListItem]</code>","text":"<p>Fetch all customers. Returns a list of <code>CustomerListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>customers = client.customers.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>customers = client.customers.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/customers/#getcustomer_id-customer","title":"<code>get(customer_id) -&gt; Customer</code>","text":"<p>Fetch full details for a single customer by their ID. Returns a <code>Customer</code> object with all fields including address, email, loyalty number, and SMS preferences.</p> <pre><code>customer = client.customers.get(\"12345\")\n</code></pre>"},{"location":"guides/customers/#examples","title":"Examples","text":""},{"location":"guides/customers/#list-all-customers","title":"List all customers","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customers = client.customers.list()\n\n    for c in customers:\n        print(f\"{c.first_name} {c.last_name} (ID: {c.customer_id})\")\n</code></pre>"},{"location":"guides/customers/#filter-customers-by-date-range","title":"Filter customers by date range","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    recent = client.customers.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(recent)} customers modified in June 2025\")\n</code></pre>"},{"location":"guides/customers/#get-customer-detail-by-id","title":"Get customer detail by ID","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customer = client.customers.get(\"12345\")\n\n    print(f\"Name:    {customer.first_name} {customer.last_name}\")\n    print(f\"Email:   {customer.email}\")\n    print(f\"Phone:   {customer.phone}\")\n    print(f\"Loyalty: {customer.loyalty_number}\")\n    print(f\"Active:  {customer.is_active}\")\n</code></pre>"},{"location":"guides/customers/#access-nested-address-fields","title":"Access nested address fields","text":"<p>The <code>Customer</code> detail model includes an <code>Address</code> object with full mailing address fields:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customer = client.customers.get(\"12345\")\n\n    addr = customer.address\n    print(f\"{addr.address1}\")\n    print(f\"{addr.city}, {addr.state} {addr.postal_code}\")\n</code></pre>"},{"location":"guides/customers/#models","title":"Models","text":""},{"location":"guides/customers/#customerlistitem","title":"<code>CustomerListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each customer.</p> Field Type Description <code>customer_id</code> <code>str</code> Unique customer identifier <code>first_name</code> <code>str</code> Customer first name <code>last_name</code> <code>str</code> Customer last name <code>phone_number</code> <code>str \\| None</code> Phone number <code>customer_number</code> <code>str \\| None</code> Customer account number <code>is_active</code> <code>bool</code> Whether the customer is active <code>created_date</code> <code>str</code> Date the record was created <code>modified_date</code> <code>str \\| None</code> Date the record was last modified"},{"location":"guides/customers/#customer","title":"<code>Customer</code>","text":"<p>Returned by <code>get()</code>. Contains full customer details including address.</p> Field Type Description <code>id</code> <code>str</code> Unique customer identifier <code>number</code> <code>str</code> Customer account number <code>first_name</code> <code>str</code> Customer first name <code>last_name</code> <code>str</code> Customer last name <code>company_name</code> <code>str \\| None</code> Company name <code>loyalty_number</code> <code>str \\| None</code> Loyalty program number <code>address</code> <code>Address</code> Nested address object (see below) <code>phone</code> <code>str</code> Phone number <code>email</code> <code>str \\| None</code> Email address <code>birth_date</code> <code>str \\| None</code> Date of birth <code>is_active</code> <code>bool</code> Whether the customer is active <code>allow_sms</code> <code>bool</code> SMS opt-in status <code>recurring_sms_signup_date</code> <code>str \\| None</code> Date of recurring SMS signup <code>loyalty_sms_signup_date</code> <code>str \\| None</code> Date of loyalty SMS signup <code>modify_date</code> <code>str</code> Date the record was last modified"},{"location":"guides/customers/#address","title":"<code>Address</code>","text":"<p>Nested inside the <code>Customer</code> model.</p> Field Type Description <code>address1</code> <code>str \\| None</code> Street address <code>address2</code> <code>str \\| None</code> Suite / unit <code>city</code> <code>str \\| None</code> City <code>state</code> <code>str \\| None</code> State <code>country</code> <code>str \\| None</code> Country <code>postal_code</code> <code>str \\| None</code> ZIP / postal code <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/employees/","title":"Employees","text":"<p>The Employees resource provides access to employee records and their clock entry history. Beyond the standard <code>list()</code> and <code>get()</code> methods, this resource includes a dedicated <code>get_clock_entries()</code> method for retrieving time-tracking data with date range filtering.</p>"},{"location":"guides/employees/#methods","title":"Methods","text":""},{"location":"guides/employees/#listparams-listemployeelistitem","title":"<code>list(**params) -&gt; list[EmployeeListItem]</code>","text":"<p>Fetch all employees. Returns a list of <code>EmployeeListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>employees = client.employees.list()\n</code></pre>"},{"location":"guides/employees/#getemployee_id-employee","title":"<code>get(employee_id) -&gt; Employee</code>","text":"<p>Fetch full details for a single employee by their ID. Returns an <code>Employee</code> object with all fields including active status, start date, phone, and email.</p> <pre><code>employee = client.employees.get(\"42\")\n</code></pre>"},{"location":"guides/employees/#get_clock_entriesemployee_id-start_datenone-end_datenone-listclockentry","title":"<code>get_clock_entries(employee_id, *, start_date=None, end_date=None) -&gt; list[ClockEntry]</code>","text":"<p>Fetch clock entries for a specific employee. Returns a flat list of <code>ClockEntry</code> objects. Optionally filter by date range using <code>start_date</code> and <code>end_date</code>.</p> <pre><code>entries = client.employees.get_clock_entries(\n    \"42\",\n    start_date=\"2025-01-01\",\n    end_date=\"2025-01-31\",\n)\n</code></pre> <p>Keyword-only arguments</p> <p><code>start_date</code> and <code>end_date</code> are keyword-only arguments. They must be passed by name, not by position. These are passed to the API as <code>startDate</code> and <code>endDate</code> query parameters.</p>"},{"location":"guides/employees/#examples","title":"Examples","text":""},{"location":"guides/employees/#list-all-employees","title":"List all employees","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    employees = client.employees.list()\n\n    for emp in employees:\n        print(f\"{emp.first_name} {emp.last_name} (ID: {emp.employee_id})\")\n</code></pre>"},{"location":"guides/employees/#get-employee-detail","title":"Get employee detail","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    emp = client.employees.get(\"42\")\n\n    print(f\"Name:       {emp.first_name} {emp.last_name}\")\n    print(f\"Active:     {emp.active}\")\n    print(f\"Start Date: {emp.start_date}\")\n    print(f\"Phone:      {emp.phone}\")\n    print(f\"Email:      {emp.email}\")\n</code></pre>"},{"location":"guides/employees/#fetch-clock-entries-for-a-date-range","title":"Fetch clock entries for a date range","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    entries = client.employees.get_clock_entries(\n        \"42\",\n        start_date=\"2025-06-01\",\n        end_date=\"2025-06-14\",\n    )\n\n    print(f\"Found {len(entries)} clock entries\\n\")\n\n    for entry in entries:\n        print(f\"Site:     {entry.site_code}\")\n        print(f\"Clock In: {entry.clock_in}\")\n        print(f\"Clock Out:{entry.clock_out}\")\n        print(f\"Regular:  {entry.regular_hours}h @ ${entry.regular_rate}/h\")\n        print(f\"Overtime: {entry.overtime_hours}h @ ${entry.overtime_rate}/h\")\n        print(f\"Modified: {entry.was_modified}\")\n        print()\n</code></pre>"},{"location":"guides/employees/#summarize-hours-for-all-employees","title":"Summarize hours for all employees","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    employees = client.employees.list()\n\n    for emp in employees:\n        entries = client.employees.get_clock_entries(\n            str(emp.employee_id),\n            start_date=\"2025-06-01\",\n            end_date=\"2025-06-14\",\n        )\n\n        total_regular = sum(e.regular_hours for e in entries)\n        total_overtime = sum(e.overtime_hours for e in entries)\n\n        print(\n            f\"{emp.first_name} {emp.last_name}: \"\n            f\"{total_regular:.1f}h regular, {total_overtime:.1f}h overtime\"\n        )\n</code></pre>"},{"location":"guides/employees/#models","title":"Models","text":""},{"location":"guides/employees/#employeelistitem","title":"<code>EmployeeListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each employee.</p> Field Type Description <code>first_name</code> <code>str</code> Employee first name <code>last_name</code> <code>str</code> Employee last name <code>employee_id</code> <code>int</code> Unique employee identifier"},{"location":"guides/employees/#employee","title":"<code>Employee</code>","text":"<p>Returned by <code>get()</code>. Contains full employee details.</p> Field Type Description <code>employee_id</code> <code>int</code> Unique employee identifier <code>first_name</code> <code>str</code> Employee first name <code>last_name</code> <code>str</code> Employee last name <code>active</code> <code>bool</code> Whether the employee is active <code>start_date</code> <code>str</code> Employment start date <code>start_date_change</code> <code>str \\| None</code> Date the start date was changed <code>phone</code> <code>str \\| None</code> Phone number <code>email</code> <code>str \\| None</code> Email address"},{"location":"guides/employees/#clockentry","title":"<code>ClockEntry</code>","text":"<p>Returned by <code>get_clock_entries()</code>. Represents a single clock-in/clock-out record.</p> Field Type Description <code>clock_in</code> <code>str \\| None</code> Clock-in timestamp <code>clock_out</code> <code>str \\| None</code> Clock-out timestamp <code>regular_rate</code> <code>float</code> Hourly pay rate for regular hours <code>regular_hours</code> <code>float</code> Number of regular hours worked <code>overtime_eligible</code> <code>bool</code> Whether the employee is OT-eligible <code>overtime_rate</code> <code>float</code> Hourly pay rate for overtime hours <code>overtime_hours</code> <code>float</code> Number of overtime hours worked <code>was_modified</code> <code>bool</code> Whether the entry was manually edited <code>modification_timestamp</code> <code>str \\| None</code> When the entry was modified <code>was_created_in_back_office</code> <code>bool</code> Whether the entry was created in back office <code>site_code</code> <code>str</code> Site code where the shift occurred <p>Flattened response</p> <p>The Sonny's API returns clock entries in a nested <code>weeks[].clockEntries[]</code> structure. The <code>get_clock_entries()</code> method automatically flattens this into a single list of <code>ClockEntry</code> objects for easier iteration.</p> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>The SDK raises typed exceptions for every failure mode so your code can react precisely to each problem. Every exception inherits from <code>SonnysError</code>, letting you catch broadly or narrow down to specific error types depending on your needs.</p>"},{"location":"guides/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All SDK exceptions follow this inheritance tree. Catching a parent class also catches all of its children.</p> <pre><code>SonnysError                     # Base for all SDK errors\n  APIError                      # Base for API-related errors\n    APIConnectionError          # Network failures (DNS, refused, etc.)\n      APITimeoutError           # Request timed out before a response\n    APIStatusError              # HTTP error responses (4xx / 5xx)\n      AuthError                 # 403 -- credential or authorization problem\n      RateLimitError            # 429 -- rate limit exceeded\n      ValidationError           # 400 / 422 -- bad request parameters\n      NotFoundError             # 404 -- resource not found\n      ServerError               # 5xx -- server-side failure\n</code></pre>"},{"location":"guides/error-handling/#catching-errors","title":"Catching Errors","text":""},{"location":"guides/error-handling/#catch-all","title":"Catch-all","text":"<p>The simplest approach catches <code>SonnysError</code> to handle any SDK failure in one place:</p> <pre><code>from sonnys_data_client import SonnysClient, SonnysError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except SonnysError as e:\n        print(f\"SDK error: {e}\")\n</code></pre>"},{"location":"guides/error-handling/#catch-by-category","title":"Catch by category","text":"<p>Separate network problems from HTTP errors to apply different recovery strategies:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    APIConnectionError,\n    APIStatusError,\n    SonnysError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        customers = client.customers.list()\n    except APIConnectionError:\n        print(\"Network problem -- check your connection\")\n    except APIStatusError as e:\n        print(f\"HTTP {e.status_code}: {e.message}\")\n    except SonnysError as e:\n        print(f\"Other SDK error: {e}\")\n</code></pre>"},{"location":"guides/error-handling/#catch-specific-exceptions","title":"Catch specific exceptions","text":"<p>For fine-grained control, catch each exception type individually:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    AuthError,\n    NotFoundError,\n    RateLimitError,\n    ServerError,\n    ValidationError,\n    SonnysError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        customer = client.customers.get(\"12345\")\n    except AuthError:\n        print(\"Invalid credentials or unauthorized site\")\n    except NotFoundError:\n        print(\"Customer not found\")\n    except RateLimitError:\n        print(\"Rate limit exceeded after retries\")\n    except ValidationError as e:\n        print(f\"Bad request: {e.message}\")\n    except ServerError:\n        print(\"Server error -- try again later\")\n    except SonnysError as e:\n        print(f\"Unexpected SDK error: {e}\")\n</code></pre> <p>Tip</p> <p>Order specific exceptions before general ones -- Python matches the first <code>except</code> clause. Place <code>AuthError</code> before <code>APIStatusError</code>, and <code>APIStatusError</code> before <code>SonnysError</code>.</p>"},{"location":"guides/error-handling/#error-attributes","title":"Error Attributes","text":"<p>All <code>APIStatusError</code> subclasses (<code>AuthError</code>, <code>RateLimitError</code>, <code>ValidationError</code>, <code>NotFoundError</code>, <code>ServerError</code>) expose these attributes:</p> Attribute Type Description <code>message</code> <code>str</code> Human-readable error description from the API <code>status_code</code> <code>int</code> HTTP status code (e.g., 403, 404, 429) <code>body</code> <code>dict \\| None</code> Full parsed JSON response body from the API <code>error_type</code> <code>str \\| None</code> Sonny's API error type string (e.g., <code>\"BadClientCredentialsError\"</code>) <p>Access these attributes in your <code>except</code> block to log details or branch on the specific error type:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIStatusError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except APIStatusError as e:\n        print(f\"Status:     {e.status_code}\")\n        print(f\"Message:    {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n        print(f\"Body:       {e.body}\")\n</code></pre> <p>API error_type values</p> <p>The <code>error_type</code> attribute contains the raw error type string returned by the Sonny's API. The SDK maps these to exception classes automatically:</p> API <code>error_type</code> HTTP Status SDK Exception <code>MissingClientCredentialsError</code> 403 <code>AuthError</code> <code>BadClientCredentialsError</code> 403 <code>AuthError</code> <code>MismatchCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedError</code> 403 <code>AuthError</code> <code>BadSiteCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedSiteCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedSiteArgsError</code> 403 <code>AuthError</code> <code>RequestRateExceedError</code> 429 <code>RateLimitError</code> <code>PayloadValidationError</code> 422 <code>ValidationError</code> <code>InvalidPayloadRequestTimestampError</code> 400 <code>ValidationError</code> <code>EntityNotFoundError</code> 404 <code>NotFoundError</code> <code>UnexpectedFailure</code> 400 <code>APIError</code> <code>ServerUnexpectedFailure</code> 500 <code>ServerError</code>"},{"location":"guides/error-handling/#per-exception-type-guidance","title":"Per-Exception-Type Guidance","text":""},{"location":"guides/error-handling/#autherror","title":"AuthError","text":"<p>When it is raised: The API returns HTTP 403 for any credential or authorization problem.</p> <p>Common causes:</p> <ul> <li>Wrong <code>api_id</code> or <code>api_key</code> values (e.g., copied from the wrong environment or database)</li> <li><code>site_code</code> not authorized for the given API ID -- each API ID is provisioned for specific sites, and using a site code from a different organization triggers <code>NotAuthorizedSiteCredentialsError</code></li> <li>Missing credentials -- forgetting to pass <code>api_id</code> or <code>api_key</code> to the constructor</li> <li>API ID/key pair mismatch -- using the API ID from one database (e.g., WashU) with the API key from another (e.g., Icon)</li> <li>Passing <code>site</code> as a query parameter instead of using the <code>site_code</code> constructor argument</li> </ul> <p>Recommended handling: Do not retry -- fix your credentials or site code configuration. Check that your <code>api_id</code>, <code>api_key</code>, and <code>site_code</code> match what was provisioned by Sonny's. Use <code>error_type</code> to pinpoint the exact problem.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import AuthError\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"SITE01\",\n) as client:\n    try:\n        sites = client.sites.list()\n    except AuthError as e:\n        print(f\"Auth failed: {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n\n        # Branch on the specific auth failure\n        if e.error_type == \"BadClientCredentialsError\":\n            print(\"Check your api_id and api_key values\")\n        elif e.error_type == \"NotAuthorizedSiteCredentialsError\":\n            print(\"This site_code is not authorized for your API ID\")\n        elif e.error_type == \"MissingClientCredentialsError\":\n            print(\"Credentials were not provided\")\n        elif e.error_type == \"MismatchCredentialsError\":\n            print(\"API ID and key do not belong to the same account\")\n</code></pre> <p>Warning</p> <p>If you operate multiple databases (e.g., WashU and Icon) with separate credentials, double-check that you are not mixing API IDs and keys across client instances. A <code>MismatchCredentialsError</code> means the ID and key belong to different accounts.</p>"},{"location":"guides/error-handling/#ratelimiterror","title":"RateLimitError","text":"<p>When it is raised: The API returns HTTP 429 and all built-in retries have been exhausted (default: 3 attempts with exponential backoff).</p> <p>Common causes:</p> <ul> <li>Running an analytics script while a scheduled cron job is also pulling data against the same API ID</li> <li>Bulk-exporting transactions for multiple sites in a tight loop without pausing between sites</li> <li>Multiple <code>SonnysClient</code> instances sharing the same <code>api_id</code> -- each instance has its own rate limiter, but the API enforces a single 20 req/15s limit per API ID</li> <li>Burst traffic from a loop that calls <code>client.transactions.get()</code> for hundreds of individual transaction IDs</li> </ul> <p>Recommended handling: The SDK already retries 429 responses with exponential backoff (see Built-in Retry Behavior). If this exception reaches your code, the situation is severe. Back off for a longer period before retrying, or stagger your scripts.</p> <pre><code>import time\nimport logging\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import RateLimitError\n\n# Enable logging to see when 429 retries happen internally\nlogging.basicConfig(level=logging.WARNING)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except RateLimitError as e:\n        print(f\"Rate limited after retries: {e.message}\")\n        # All 3 built-in retries failed -- back off for 30 seconds\n        time.sleep(30)\n</code></pre> <p>Tip</p> <p>If you regularly hit rate limits, check whether multiple processes share the same API ID. Stagger scheduled jobs by at least 60 seconds, or increase <code>max_retries</code> on the client to allow more backoff time.</p>"},{"location":"guides/error-handling/#validationerror","title":"ValidationError","text":"<p>When it is raised: The API returns HTTP 400 or 422 for invalid request parameters.</p> <p>Common causes:</p> <ul> <li>Date format <code>\"06/01/2025\"</code> instead of the required <code>\"2025-06-01\"</code> (ISO 8601) -- this is the most common validation error and triggers <code>InvalidPayloadRequestTimestampError</code></li> <li>Passing a transaction type string that does not exist to <code>list_by_type()</code> (e.g., <code>\"membership\"</code> instead of <code>\"recurring\"</code>)</li> <li>Sending <code>endDate</code> earlier than <code>startDate</code></li> <li>Malformed JSON in the request body (rare with the SDK, but possible if you modify internals)</li> <li>Missing required parameters on endpoints that enforce them</li> </ul> <p>Recommended handling: Do not retry -- fix the request parameters. Check date formats (<code>YYYY-MM-DD</code>), parameter names, and allowed values. Use <code>error_type</code> to distinguish between timestamp errors and general payload errors.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ValidationError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"06/01/2025\",  # Wrong format!\n            endDate=\"06/30/2025\",\n        )\n    except ValidationError as e:\n        print(f\"Validation error: {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n\n        if e.error_type == \"InvalidPayloadRequestTimestampError\":\n            print(\"Fix date format to YYYY-MM-DD\")\n        elif e.error_type == \"PayloadValidationError\":\n            print(\"Check parameter names and values\")\n</code></pre> <p>Info</p> <p>The <code>PayloadValidationError</code> type may return multiple error messages in the response body. The SDK joins them into a single <code>message</code> string separated by semicolons. Check <code>e.body</code> for the original <code>\"messages\"</code> array if you need to inspect each validation failure individually.</p>"},{"location":"guides/error-handling/#notfounderror","title":"NotFoundError","text":"<p>When it is raised: The API returns HTTP 404 when the requested resource does not exist.</p> <p>Common causes:</p> <ul> <li>Transaction ID from a different site than the one configured via <code>site_code</code> -- IDs are scoped per site</li> <li>Customer ID that was valid in one database but does not exist in another (e.g., looking up a WashU customer ID against the Icon database)</li> <li>Deleted recurring account or gift card that no longer exists in the system</li> <li>Typo or truncated ID string</li> </ul> <p>Recommended handling: Verify the ID is correct and belongs to the configured site. In batch workflows where you iterate over a list of IDs, catch <code>NotFoundError</code> and skip or log the missing record rather than aborting the entire loop.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import NotFoundError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Gracefully handle missing records in a batch lookup\n    customer_ids = [\"12345\", \"99999\", \"67890\"]\n    found = []\n\n    for cid in customer_ids:\n        try:\n            customer = client.customers.get(cid)\n            found.append(customer)\n        except NotFoundError:\n            print(f\"Customer {cid} not found, skipping\")\n            # e.error_type will be \"EntityNotFoundError\"\n\n    print(f\"Found {len(found)} of {len(customer_ids)} customers\")\n</code></pre>"},{"location":"guides/error-handling/#servererror","title":"ServerError","text":"<p>When it is raised: The API returns HTTP 5xx indicating a server-side failure.</p> <p>Common causes:</p> <ul> <li>Sonny's API scheduled maintenance window -- the API may return 500 or 503 during planned updates</li> <li>Intermittent 500 errors on large date-range queries or <code>load_job()</code> requests that stress the backend</li> <li><code>ServerUnexpectedFailure</code> -- an unexpected crash on the API side</li> <li>502/503 responses from upstream infrastructure (load balancer, gateway)</li> </ul> <p>Recommended handling: Retry after a delay. Server errors are often transient. If they persist beyond a few minutes, check with Sonny's support for known outages. For automated pipelines, implement retry with backoff (see Custom Retry Patterns).</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ServerError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    max_attempts = 3\n    for attempt in range(max_attempts):\n        try:\n            transactions = client.transactions.list(\n                startDate=\"2025-06-01\",\n                endDate=\"2025-06-30\",\n            )\n            break  # Success\n        except ServerError as e:\n            print(f\"Server error ({e.status_code}): {e.message}\")\n            if attempt &lt; max_attempts - 1:\n                delay = 5 * (2 ** attempt)\n                print(f\"Retrying in {delay}s...\")\n                time.sleep(delay)\n            else:\n                print(\"All retries exhausted\")\n                raise\n</code></pre>"},{"location":"guides/error-handling/#apiconnectionerror","title":"APIConnectionError","text":"<p>When it is raised: The HTTP request fails before reaching the server -- no response is received.</p> <p>Common causes:</p> <ul> <li>No internet connection on the machine running the script</li> <li>DNS resolution failure for <code>trigonapi.sonnyscontrols.com</code> -- common on new server deployments where DNS is not yet configured</li> <li>Corporate firewall or proxy blocking outbound HTTPS traffic to the Sonny's API domain</li> <li>VPN disconnection mid-request</li> <li>Running inside a Docker container or CI environment without outbound network access</li> </ul> <p>Recommended handling: Check network connectivity. This error does not have <code>status_code</code> or <code>body</code> attributes since no HTTP response was received. For automated pipelines, retry a few times with a delay -- the network issue may be transient.</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        sites = client.sites.list()\n    except APIConnectionError as e:\n        print(f\"Connection failed: {e.message}\")\n        print(\"Troubleshooting steps:\")\n        print(\"  1. Check internet connectivity\")\n        print(\"  2. Verify DNS resolves: nslookup trigonapi.sonnyscontrols.com\")\n        print(\"  3. Check firewall allows HTTPS to trigonapi.sonnyscontrols.com\")\n        print(\"  4. If behind a proxy, configure requests proxy settings\")\n</code></pre>"},{"location":"guides/error-handling/#apitimeouterror","title":"APITimeoutError","text":"<p>When it is raised: The HTTP request was sent but no response arrived within the timeout period. Also raised when <code>load_job()</code> polling exceeds the configured <code>timeout</code>.</p> <p>Common causes:</p> <ul> <li><code>load_job()</code> on a high-volume site with a full day of transactions -- the batch job takes longer than the default 300-second timeout to complete</li> <li>Very large <code>list()</code> or <code>list_v2()</code> queries spanning months of data at a busy site</li> <li>Network congestion or high latency between your server and <code>trigonapi.sonnyscontrols.com</code></li> <li>API under heavy load from other consumers during peak hours</li> </ul> <p>Recommended handling: For <code>load_job()</code>, increase the <code>timeout</code> parameter or use a shorter date range. For list methods, narrow the date range. Consider splitting multi-month queries into smaller chunks.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APITimeoutError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        # Large export that may time out\n        results = client.transactions.load_job(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-02\",\n            timeout=600.0,  # 10 minutes instead of default 5\n        )\n    except APITimeoutError:\n        print(\"Job timed out -- try a shorter date range or increase timeout\")\n        # Fallback: split into smaller chunks\n        from datetime import date, timedelta\n        start = date(2025, 6, 1)\n        end = date(2025, 6, 2)\n        midpoint = start + (end - start) / 2\n        print(f\"Try splitting: {start} to {midpoint} and {midpoint} to {end}\")\n</code></pre> <p>Note</p> <p><code>APITimeoutError</code> is a subclass of <code>APIConnectionError</code>. If you catch <code>APIConnectionError</code>, it will also catch timeouts. Use the specific <code>APITimeoutError</code> class when you need to distinguish timeouts from other connection failures.</p>"},{"location":"guides/error-handling/#built-in-retry-behavior","title":"Built-in Retry Behavior","text":"<p>The SDK includes two layers of automatic protection against rate limiting.</p>"},{"location":"guides/error-handling/#pre-request-rate-limiting","title":"Pre-request rate limiting","text":"<p>Every request passes through a sliding window rate limiter before it is sent. The limiter enforces a maximum of 20 requests per 15-second window. If you are at capacity, the client automatically sleeps until a slot opens -- no exception is raised.</p>"},{"location":"guides/error-handling/#429-retry-with-exponential-backoff","title":"429 retry with exponential backoff","text":"<p>If the API returns HTTP 429 despite the client-side limiter (e.g., another script shares the same API ID), the SDK retries with exponential backoff:</p> Attempt Delay 1 1 second 2 2 seconds 3 4 seconds <p>After <code>max_retries</code> attempts (default 3), the SDK raises <code>RateLimitError</code>.</p> <p>Note</p> <p>You can configure <code>max_retries</code> when constructing the client:</p> <pre><code>client = SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    max_retries=5,  # Allow up to 5 retry attempts for 429s\n)\n</code></pre>"},{"location":"guides/error-handling/#what-is-not-retried-automatically","title":"What is NOT retried automatically","text":"<p>The SDK only retries HTTP 429 responses. These errors are not retried:</p> <ul> <li><code>APIConnectionError</code> -- Network failures (no response received)</li> <li><code>APITimeoutError</code> -- Request timeouts</li> <li><code>AuthError</code> (403) -- Credential or authorization problems</li> <li><code>ValidationError</code> (400/422) -- Invalid request parameters</li> <li><code>NotFoundError</code> (404) -- Resource does not exist</li> <li><code>ServerError</code> (5xx) -- Server-side failures</li> </ul> <p>If you need retry logic for these errors, implement it yourself using the patterns below.</p>"},{"location":"guides/error-handling/#custom-retry-patterns","title":"Custom Retry Patterns","text":""},{"location":"guides/error-handling/#retry-on-transient-server-errors","title":"Retry on transient server errors","text":"<p>Server errors (500, 502, 503) are often transient. Wrap your call in a simple retry loop with backoff:</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ServerError\n\ndef fetch_with_retry(client, retries=3, base_delay=2.0):\n    for attempt in range(retries):\n        try:\n            return client.transactions.list(\n                startDate=\"2025-06-01\",\n                endDate=\"2025-06-30\",\n            )\n        except ServerError as e:\n            if attempt == retries - 1:\n                raise\n            delay = base_delay * (2 ** attempt)\n            print(f\"Server error ({e.status_code}), retrying in {delay}s...\")\n            time.sleep(delay)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = fetch_with_retry(client)\n</code></pre>"},{"location":"guides/error-handling/#retry-on-connection-and-timeout-errors","title":"Retry on connection and timeout errors","text":"<p>Network problems can be intermittent. Retry <code>APIConnectionError</code> and <code>APITimeoutError</code> with a short delay:</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError, APITimeoutError\n\ndef fetch_with_network_retry(client, retries=3, delay=5.0):\n    for attempt in range(retries):\n        try:\n            return client.customers.list()\n        except (APIConnectionError, APITimeoutError) as e:\n            if attempt == retries - 1:\n                raise\n            print(f\"{type(e).__name__}, retrying in {delay}s...\")\n            time.sleep(delay)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customers = fetch_with_network_retry(client)\n</code></pre>"},{"location":"guides/error-handling/#production-retry-with-tenacity","title":"Production retry with tenacity","text":"<p>For production systems, use the <code>tenacity</code> library for configurable, decorator-based retry logic:</p> <pre><code>pip install tenacity\n</code></pre> <pre><code>from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError, APITimeoutError, ServerError\n\n@retry(\n    retry=retry_if_exception_type((ServerError, APIConnectionError, APITimeoutError)),\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=1, min=2, max=30),\n)\ndef fetch_transactions(client):\n    return client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = fetch_transactions(client)\n</code></pre> <p>Warning</p> <p>Never retry <code>AuthError</code> or <code>ValidationError</code> -- these indicate a code or configuration problem, not a transient failure. Retrying them wastes time and rate limit budget without any chance of success.</p>"},{"location":"guides/error-handling/#logging-debugging","title":"Logging &amp; Debugging","text":"<p>The SDK logs every request, response, and retry through Python's built-in <code>logging</code> module under the <code>sonnys_data_client</code> logger. Enabling debug logging is the fastest way to understand what the SDK is doing under the hood.</p>"},{"location":"guides/error-handling/#enabling-debug-logging","title":"Enabling Debug Logging","text":"<p>Log everything (SDK + all other libraries):</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <p>Log only the SDK (recommended for most debugging):</p> <pre><code>import logging\n\nlogging.getLogger(\"sonnys_data_client\").setLevel(logging.DEBUG)\n</code></pre> <p>Add a StreamHandler for scripts that don't already configure logging:</p> <pre><code>import logging\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)s %(name)s: %(message)s\"))\n\nsdk_logger = logging.getLogger(\"sonnys_data_client\")\nsdk_logger.addHandler(handler)\nsdk_logger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"guides/error-handling/#what-gets-logged","title":"What Gets Logged","text":"<p>The SDK emits these log messages at each stage of a request:</p> Level Message Pattern Meaning DEBUG <code>Rate limiter: waiting {N}s</code> Pre-request rate limit sleep DEBUG <code>Request: {METHOD} {PATH} params={PARAMS}</code> Outgoing HTTP request DEBUG <code>Response: {METHOD} {PATH} status={CODE} elapsed={TIME}s</code> Successful response received WARNING <code>Rate limited (429), retry {N}/{MAX} after {DELAY}s</code> 429 received, backing off before retry"},{"location":"guides/error-handling/#reading-debug-output","title":"Reading Debug Output","text":"<p>Here is an annotated example of a typical debug session. Two requests are made: the first hits the rate limiter and succeeds, the second gets a 429 and retries.</p> <pre><code>2025-06-15 10:00:00,100 DEBUG sonnys_data_client: Rate limiter: waiting 0.450s\n# ^ Rate limiter detected we're near the 20 req/15s limit. Sleeping 450ms.\n\n2025-06-15 10:00:00,550 DEBUG sonnys_data_client: Request: GET /sites params=None\n# ^ Outgoing request to the /sites endpoint with no query parameters.\n\n2025-06-15 10:00:01,200 DEBUG sonnys_data_client: Response: GET /sites status=200 elapsed=0.650s\n# ^ Success! The API responded in 650ms with HTTP 200.\n\n2025-06-15 10:00:01,210 DEBUG sonnys_data_client: Request: GET /transactions params={'startDate': '2025-06-01', 'endDate': '2025-06-15'}\n# ^ Second request -- fetching transactions with date range parameters.\n\n2025-06-15 10:00:01,800 WARNING sonnys_data_client: Rate limited (429), retry 1/3 after 1.0s\n# ^ API returned 429. SDK will wait 1 second then retry (attempt 1 of 3).\n\n2025-06-15 10:00:02,810 DEBUG sonnys_data_client: Request: GET /transactions params={'startDate': '2025-06-01', 'endDate': '2025-06-15'}\n# ^ Retry request sent after the 1-second backoff.\n\n2025-06-15 10:00:03,500 DEBUG sonnys_data_client: Response: GET /transactions status=200 elapsed=0.690s\n# ^ Retry succeeded. The API responded with HTTP 200.\n</code></pre> <p>Tip</p> <p>In production, leave the SDK logger at WARNING to only see 429 retries. Set to DEBUG only when troubleshooting.</p>"},{"location":"guides/error-handling/#common-issues-troubleshooting","title":"Common Issues &amp; Troubleshooting","text":""},{"location":"guides/error-handling/#troubleshooting-table","title":"Troubleshooting Table","text":"Symptom Likely Cause Solution <code>AuthError: MissingClientCredentialsError</code> <code>api_id</code> or <code>api_key</code> not provided or empty Check <code>SonnysClient</code> constructor args <code>AuthError: BadClientCredentialsError</code> Wrong <code>api_id</code> or <code>api_key</code> Verify credentials with Sonny's support <code>AuthError: NotAuthorizedSiteCredentialsError</code> <code>site_code</code> not authorized for this API ID Use a <code>site_code</code> linked to your API credentials <code>RateLimitError</code> after retries exhausted Too many concurrent requests Reduce parallelism or increase <code>max_retries</code> <code>ValidationError: PayloadValidationError</code> Bad date format or invalid parameter Use <code>YYYY-MM-DD</code> format, check parameter names <code>NotFoundError: EntityNotFoundError</code> Resource ID doesn't exist or wrong site Verify ID and <code>site_code</code> match <code>ServerError</code> intermittent 500s Sonny's API transient issue Add retry logic for 5xx (see Custom Retry Patterns) <code>APIConnectionError</code> Network/DNS failure Check internet, verify <code>trigonapi.sonnyscontrols.com</code> is reachable <code>APITimeoutError</code> Request took too long Use smaller date ranges, check network latency Slow responses but no errors Rate limiter pre-emptively sleeping Enable DEBUG logging to see rate limiter waits <code>ImportError</code> on exceptions Wrong import path Import from <code>sonnys_data_client</code> directly, not <code>_exceptions</code>"},{"location":"guides/error-handling/#diagnostic-checklist","title":"Diagnostic Checklist","text":"<p>When something goes wrong, follow these steps in order:</p> <ol> <li>Enable DEBUG logging -- see Enabling Debug Logging above</li> <li>Check the <code>error_type</code> attribute for the specific API error string (e.g., <code>\"BadClientCredentialsError\"</code>)</li> <li>Inspect the <code>body</code> attribute for the full API response JSON -- it often contains additional detail</li> <li>Verify credentials with a simple <code>client.sites.list()</code> call -- if this fails with <code>AuthError</code>, your credentials are wrong</li> <li>Check rate limiter state with debug logs -- look for <code>Rate limiter: waiting</code> messages to see if pre-request throttling is slowing you down</li> </ol> <p>Warning</p> <p>The most common mistake is using <code>MM/DD/YYYY</code> date format (e.g., <code>\"06/01/2025\"</code>) instead of the required <code>YYYY-MM-DD</code> format (e.g., <code>\"2025-06-01\"</code>). The API will reject the request with a <code>ValidationError</code> and <code>error_type</code> of <code>InvalidPayloadRequestTimestampError</code>. Always use ISO 8601 dates.</p>"},{"location":"guides/error-handling/#quick-reference","title":"Quick Reference","text":"<p>A scannable cheat sheet mapping HTTP status codes to SDK exceptions, typical causes, and recommended actions.</p> HTTP Status SDK Exception Typical Cause Recommended Action -- <code>APIConnectionError</code> Network down, DNS failure, firewall blocking Check connectivity; retry with delay -- <code>APITimeoutError</code> Slow response, large query, job polling timeout Shorten date range; increase timeout 400 <code>ValidationError</code> Bad date format, invalid parameters Fix request parameters; do not retry 403 <code>AuthError</code> Wrong credentials, unauthorized site code Fix credentials or site_code; do not retry 404 <code>NotFoundError</code> ID does not exist, wrong site, deleted record Verify ID and site; skip in batch loops 422 <code>ValidationError</code> Payload validation failure Check parameter values; do not retry 429 <code>RateLimitError</code> Rate limit exceeded after built-in retries Back off 30s+; stagger concurrent scripts 500 <code>ServerError</code> API crash, maintenance, <code>ServerUnexpectedFailure</code> Retry with backoff; contact support if persistent 502/503 <code>ServerError</code> Gateway/infrastructure error Retry with backoff; usually transient"},{"location":"guides/giftcards/","title":"Giftcards","text":"<p>The Giftcards resource provides access to gift card liability records. Each record tracks a gift card's original value, amount used, and the site where it was sold. Use this resource to retrieve gift card balances and monitor usage across your locations.</p>"},{"location":"guides/giftcards/#methods","title":"Methods","text":""},{"location":"guides/giftcards/#listparams-listgiftcardlistitem","title":"<code>list(**params) -&gt; list[GiftcardListItem]</code>","text":"<p>Fetch all gift card records. Returns a list of <code>GiftcardListItem</code> objects. The client automatically paginates through all pages of results.</p> <pre><code>giftcards = client.giftcards.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>giftcards = client.giftcards.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre> <p>List-only resource</p> <p>The Giftcards resource only supports the <code>list()</code> method. There is no <code>get()</code> method for retrieving individual gift card details.</p>"},{"location":"guides/giftcards/#examples","title":"Examples","text":""},{"location":"guides/giftcards/#list-all-gift-cards","title":"List all gift cards","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    for gc in giftcards:\n        print(f\"Card #{gc.number} (ID: {gc.giftcard_id}) - Site: {gc.site_code}\")\n</code></pre>"},{"location":"guides/giftcards/#check-gift-card-balances","title":"Check gift card balances","text":"<p>Each gift card record includes the original <code>value</code> and <code>amount_used</code>. Calculate the remaining balance by subtracting <code>amount_used</code> from <code>value</code>:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    for gc in giftcards:\n        remaining = gc.value - gc.amount_used\n        print(\n            f\"Card #{gc.number}: \"\n            f\"Value=${gc.value:.2f}, \"\n            f\"Used=${gc.amount_used:.2f}, \"\n            f\"Remaining=${remaining:.2f}\"\n        )\n</code></pre>"},{"location":"guides/giftcards/#summarize-gift-card-liability-by-site","title":"Summarize gift card liability by site","text":"<pre><code>from collections import defaultdict\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    liability_by_site: dict[str, float] = defaultdict(float)\n    for gc in giftcards:\n        remaining = gc.value - gc.amount_used\n        liability_by_site[gc.site_code] += remaining\n\n    for site, total in sorted(liability_by_site.items()):\n        print(f\"Site {site}: ${total:.2f} outstanding\")\n</code></pre>"},{"location":"guides/giftcards/#models","title":"Models","text":""},{"location":"guides/giftcards/#giftcardlistitem","title":"<code>GiftcardListItem</code>","text":"<p>Returned by <code>list()</code>. Contains the full gift card record.</p> Field Type Description <code>giftcard_id</code> <code>str</code> Unique gift card identifier <code>number</code> <code>str</code> Gift card number <code>value</code> <code>float</code> Original gift card value <code>amount_used</code> <code>float</code> Total amount redeemed <code>site_code</code> <code>str</code> Site where the gift card was sold <code>complete_date</code> <code>str \\| None</code> Date the gift card was fully used"},{"location":"guides/giftcards/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/giftcards/#liability-tracking-with-transactions","title":"Liability Tracking with Transactions","text":"<p>Combine gift card records with gift card transaction data to track redemptions and calculate outstanding liability:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n    gc_txns = client.transactions.list_by_type(\n        \"giftcard\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Outstanding liability\n    total_liability = sum(gc.value - gc.amount_used for gc in giftcards)\n    print(f\"Total outstanding liability: ${total_liability:.2f}\")\n    print(f\"Gift card transactions this month: {len(gc_txns)}\")\n    print(f\"Active cards: {sum(1 for gc in giftcards if gc.value &gt; gc.amount_used)}\")\n</code></pre> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p>"},{"location":"guides/items/","title":"Items","text":"<p>The Items resource provides access to the wash items and products catalog. Each item represents a product or service offered at a car wash site, including its SKU, pricing, and department classification. This is a list-only resource -- there is no <code>get()</code> method for individual item detail.</p>"},{"location":"guides/items/#methods","title":"Methods","text":""},{"location":"guides/items/#listparams-listitem","title":"<code>list(**params) -&gt; list[Item]</code>","text":"<p>Fetch all items. Returns a list of <code>Item</code> objects representing the full product catalog. The client automatically paginates through all pages of results.</p> <pre><code>items = client.items.list()\n</code></pre>"},{"location":"guides/items/#examples","title":"Examples","text":""},{"location":"guides/items/#list-all-items","title":"List all items","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    for item in items:\n        print(f\"{item.sku}: {item.name} - ${item.price_at_site}\")\n</code></pre>"},{"location":"guides/items/#view-item-details-with-department-info","title":"View item details with department info","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    for item in items:\n        print(f\"SKU:        {item.sku}\")\n        print(f\"Name:       {item.name}\")\n        print(f\"Department: {item.department_name}\")\n        print(f\"Price:      {item.price_at_site}\")\n        print(f\"Site:       {item.site_location}\")\n        print()\n</code></pre>"},{"location":"guides/items/#group-items-by-department","title":"Group items by department","text":"<pre><code>from collections import defaultdict\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    by_department = defaultdict(list)\n    for item in items:\n        by_department[item.department_name].append(item)\n\n    for dept, dept_items in by_department.items():\n        print(f\"\\n{dept} ({len(dept_items)} items):\")\n        for item in dept_items:\n            print(f\"  {item.sku}: {item.name} - ${item.price_at_site}\")\n</code></pre>"},{"location":"guides/items/#filter-items-by-site-location","title":"Filter items by site location","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    site_items = [i for i in items if i.site_location == \"MAIN\"]\n    print(f\"Found {len(site_items)} items at MAIN site\")\n</code></pre>"},{"location":"guides/items/#models","title":"Models","text":""},{"location":"guides/items/#item","title":"<code>Item</code>","text":"<p>Returned by <code>list()</code>. Contains product catalog information.</p> Field Type Description <code>sku</code> <code>str</code> Stock keeping unit identifier <code>name</code> <code>str</code> Product or service name <code>department_name</code> <code>str</code> Department classification <code>price_at_site</code> <code>str</code> Price at the associated site <code>cost_per_item</code> <code>str \\| None</code> Cost per item (if available) <code>is_prompt_for_price</code> <code>bool</code> Whether the price is entered at the POS <code>site_location</code> <code>str</code> Site location code where the item is sold <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>List-only resource</p> <p>Items is a list-only resource. There is no <code>get()</code> method to retrieve a single item by ID. Use <code>list()</code> and filter the results in Python if you need a specific item.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/recurring/","title":"Recurring Accounts","text":"<p>The Recurring Accounts resource provides access to recurring (membership) car wash accounts. This is the richest standard resource in the client, offering five methods for listing accounts, fetching full details, tracking status changes, and reviewing modification history. Each account includes billing information, plan details, associated tags, vehicles, and customer data.</p>"},{"location":"guides/recurring/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The recurring resource offers five methods. Pick the one that matches your use case to avoid fetching more data than you need:</p> Method Returns Use When Pagination <code>list()</code> <code>RecurringListItem</code> Quick summaries, filtering by date/site Auto <code>get()</code> <code>Recurring</code> Full detail for a single account N/A <code>list_status_changes()</code> <code>RecurringStatusChange</code> Tracking cancellations, reactivations Auto <code>list_modifications()</code> <code>RecurringModification</code> Audit trail, plan changes, account edits Auto <code>list_details()</code> <code>Recurring</code> Bulk export with full detail (heavier) Auto <p>Start with <code>list()</code> for lightweight summaries and filtering by date range or site. Use <code>get()</code> when you need a single-account deep dive with nested billing history, tags, vehicles, and customer data. Reach for <code>list_status_changes()</code> when analyzing churn and retention trends, and <code>list_modifications()</code> when you need an audit trail of plan changes or account edits. Reserve <code>list_details()</code> for cases where you need the full nested data (tags, vehicles, billing history) in bulk -- it returns the same rich <code>Recurring</code> objects as <code>get()</code> but for every account, so it is significantly heavier.</p>"},{"location":"guides/recurring/#methods","title":"Methods","text":""},{"location":"guides/recurring/#listparams-listrecurringlistitem","title":"<code>list(**params) -&gt; list[RecurringListItem]</code>","text":"<p>Fetch all recurring accounts. Returns a list of <code>RecurringListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>accounts = client.recurring.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>accounts = client.recurring.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/recurring/#getaccount_id-recurring","title":"<code>get(account_id) -&gt; Recurring</code>","text":"<p>Fetch full details for a single recurring account by its ID. Returns a <code>Recurring</code> object with nested customer, tags, vehicles, billing history, and status history.</p> <pre><code>account = client.recurring.get(\"12345\")\n</code></pre>"},{"location":"guides/recurring/#list_status_changesparams-listrecurringstatuschange","title":"<code>list_status_changes(**params) -&gt; list[RecurringStatusChange]</code>","text":"<p>Fetch all recurring account status changes. Returns a list of <code>RecurringStatusChange</code> objects tracking when accounts changed status (e.g., active to cancelled).</p> <pre><code>changes = client.recurring.list_status_changes()\n</code></pre>"},{"location":"guides/recurring/#list_modificationsparams-listrecurringmodification","title":"<code>list_modifications(**params) -&gt; list[RecurringModification]</code>","text":"<p>Fetch all recurring account modifications. Returns a list of <code>RecurringModification</code> objects -- each includes the full account detail plus a list of modification entries.</p> <pre><code>modifications = client.recurring.list_modifications()\n</code></pre>"},{"location":"guides/recurring/#list_detailsparams-listrecurring","title":"<code>list_details(**params) -&gt; list[Recurring]</code>","text":"<p>Fetch all recurring accounts with full detail. Returns full <code>Recurring</code> objects (the same model as <code>get()</code>) for every account, rather than the summary <code>RecurringListItem</code> objects returned by <code>list()</code>.</p> <pre><code>details = client.recurring.list_details()\n</code></pre> <p>Heavier API call</p> <p><code>list_details()</code> returns full <code>Recurring</code> objects for every account. This results in significantly more data per request than <code>list()</code>. Use <code>list()</code> when you only need summary fields, and reserve <code>list_details()</code> for when you need the complete account data in bulk.</p>"},{"location":"guides/recurring/#examples","title":"Examples","text":""},{"location":"guides/recurring/#list-recurring-accounts","title":"List recurring accounts","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    accounts = client.recurring.list()\n\n    for acct in accounts:\n        print(\n            f\"Account {acct.id}: {acct.status_name} \"\n            f\"(status={acct.status}, site={acct.billing_site_code})\"\n        )\n</code></pre>"},{"location":"guides/recurring/#get-account-detail","title":"Get account detail","text":"<p>The detail endpoint returns billing info, plan details, tags, vehicles, customer data, and full status and billing history:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    acct = client.recurring.get(\"12345\")\n\n    # Plan and billing info\n    print(f\"Plan: {acct.plan_name}\")\n    print(f\"Billing amount: ${acct.billing_amount:.2f}\")\n    print(f\"Next bill date: {acct.next_bill_date}\")\n    print(f\"On trial: {acct.is_on_trial}\")\n    print(f\"Suspended: {acct.is_suspended}\")\n\n    # Customer\n    print(f\"Customer: {acct.customer.first_name} {acct.customer.last_name}\")\n\n    # Tags and vehicles\n    for tag in acct.tags:\n        print(f\"Tag #{tag.number} - {'active' if tag.enabled else 'disabled'}\")\n    for vehicle in acct.vehicles:\n        print(f\"Vehicle {vehicle.id}: {vehicle.plate or 'No plate'}\")\n\n    # Status history\n    for status in acct.recurring_statuses:\n        print(f\"Status: {status.status} on {status.date}\")\n\n    # Billing history\n    for billing in acct.recurring_billings:\n        print(f\"Billed ${billing.amount_charged:.2f} on {billing.date}\")\n</code></pre>"},{"location":"guides/recurring/#track-status-changes","title":"Track status changes","text":"<p>The <code>list_status_changes()</code> method returns a flat list of every status transition across all accounts:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    changes = client.recurring.list_status_changes(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for change in changes:\n        print(\n            f\"Account {change.recurring_id}: \"\n            f\"{change.old_status} -&gt; {change.new_status} \"\n            f\"on {change.status_date} \"\n            f\"(by {change.employee_name} at {change.site_code})\"\n        )\n</code></pre>"},{"location":"guides/recurring/#review-modifications","title":"Review modifications","text":"<p>The <code>list_modifications()</code> method returns full account objects extended with a <code>modifications</code> list:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    modified = client.recurring.list_modifications(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for acct in modified:\n        print(f\"Account {acct.id} ({acct.plan_name}):\")\n        for mod in acct.modifications:\n            comment = mod.comment or \"No comment\"\n            print(f\"  {mod.date}: {mod.name} - {comment}\")\n</code></pre>"},{"location":"guides/recurring/#compare-list-vs-list_details","title":"Compare list vs list_details","text":"<p>Use <code>list()</code> for lightweight summaries and <code>list_details()</code> when you need the full account data:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Lightweight: returns RecurringListItem objects\n    summaries = client.recurring.list()\n    print(f\"Found {len(summaries)} accounts (summary)\")\n\n    # Full detail: returns Recurring objects (same as get())\n    details = client.recurring.list_details()\n    print(f\"Found {len(details)} accounts (full detail)\")\n\n    # Full detail includes nested data not available in summaries\n    for acct in details:\n        print(\n            f\"Account {acct.id}: {acct.plan_name}, \"\n            f\"{len(acct.tags)} tags, {len(acct.vehicles)} vehicles\"\n        )\n</code></pre>"},{"location":"guides/recurring/#models","title":"Models","text":""},{"location":"guides/recurring/#recurringlistitem","title":"<code>RecurringListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each recurring account.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str \\| None</code> Account name <code>balance</code> <code>float \\| None</code> Current account balance <code>sign_up_date</code> <code>str</code> Date the account was created <code>cancel_date</code> <code>str \\| None</code> Date the account was cancelled <code>billing_site_id</code> <code>int</code> ID of the billing site <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>status</code> <code>int</code> Numeric status code <code>status_name</code> <code>str</code> Human-readable status name <code>billing_site_code</code> <code>str</code> Site code of the billing site"},{"location":"guides/recurring/#recurring","title":"<code>Recurring</code>","text":"<p>Returned by <code>get()</code> and <code>list_details()</code>. Contains full account details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>is_on_trial</code> <code>bool</code> Whether the account is on trial <code>trial_amount</code> <code>float</code> Trial billing amount <code>billing_site_code</code> <code>str</code> Site code of the billing site <code>creation_site_code</code> <code>str</code> Site code where account was created <code>next_bill_date</code> <code>str</code> Next scheduled billing date <code>last_bill_date</code> <code>str \\| None</code> Most recent billing date <code>billing_amount</code> <code>float \\| None</code> Current billing amount <code>is_suspended</code> <code>bool</code> Whether the account is suspended <code>suspended_until</code> <code>str \\| None</code> Suspension end date <code>current_recurring_status_name</code> <code>str</code> Current status name <code>plan_name</code> <code>str</code> Name of the wash plan <code>additional_tag_price</code> <code>float \\| None</code> Price for additional tags <code>customer</code> <code>WashbookCustomer</code> Nested customer object <code>tags</code> <code>list[WashbookTag]</code> List of RFID tags <code>vehicles</code> <code>list[WashbookVehicle]</code> List of vehicles <code>recurring_statuses</code> <code>list[RecurringStatus]</code> Status history (see below) <code>recurring_billings</code> <code>list[RecurringBilling]</code> Billing history (see below)"},{"location":"guides/recurring/#recurringstatus","title":"<code>RecurringStatus</code>","text":"<p>Nested inside the <code>Recurring</code> model. Represents a single status history entry.</p> Field Type Description <code>status</code> <code>str</code> Status name <code>date</code> <code>str</code> Date of the status"},{"location":"guides/recurring/#recurringbilling","title":"<code>RecurringBilling</code>","text":"<p>Nested inside the <code>Recurring</code> model. Represents a single billing history entry.</p> Field Type Description <code>amount_charged</code> <code>float</code> Amount billed <code>date</code> <code>str</code> Billing date <code>last_four_cc</code> <code>str</code> Last four digits of credit card <code>credit_card_expiration_date</code> <code>str \\| None</code> Card expiration date"},{"location":"guides/recurring/#recurringstatuschange","title":"<code>RecurringStatusChange</code>","text":"<p>Returned by <code>list_status_changes()</code>. Represents a single status transition.</p> Field Type Description <code>washbook_account_id</code> <code>str</code> Associated washbook account ID <code>recurring_id</code> <code>str</code> Recurring account identifier <code>old_status</code> <code>str</code> Previous status <code>new_status</code> <code>str</code> New status <code>status_date</code> <code>str</code> Date of the status change <code>employee_name</code> <code>str</code> Employee who made the change <code>site_code</code> <code>str</code> Site where the change occurred"},{"location":"guides/recurring/#recurringmodification","title":"<code>RecurringModification</code>","text":"<p>Returned by <code>list_modifications()</code>. Extends the <code>Recurring</code> model with a modifications list.</p> <p>This model inherits all fields from <code>Recurring</code> (see above) plus:</p> Field Type Description <code>modifications</code> <code>list[RecurringModificationEntry]</code> List of modifications"},{"location":"guides/recurring/#recurringmodificationentry","title":"<code>RecurringModificationEntry</code>","text":"<p>Nested inside <code>RecurringModification</code>.</p> Field Type Description <code>name</code> <code>str</code> Modification name <code>date</code> <code>str</code> Date of the modification <code>comment</code> <code>str \\| None</code> Optional comment"},{"location":"guides/recurring/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/recurring/#churn-analysis","title":"Churn Analysis","text":"<p>Use <code>list_status_changes()</code> to analyze account churn over a date range. Each status change includes the old and new status, the date, and the employee and site responsible:</p> <pre><code>from collections import Counter\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    changes = client.recurring.list_status_changes(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Count transitions by type\n    transitions = Counter(\n        f\"{c.old_status} \u2192 {c.new_status}\" for c in changes\n    )\n    for transition, count in transitions.most_common():\n        print(f\"{transition}: {count}\")\n\n    # Find cancellations\n    cancellations = [c for c in changes if c.new_status.lower() == \"cancelled\"]\n    print(f\"\\n{len(cancellations)} cancellations this month\")\n    for c in cancellations:\n        print(f\"  Account {c.recurring_id} at {c.site_code} on {c.status_date}\")\n</code></pre>"},{"location":"guides/recurring/#billing-history-report","title":"Billing History Report","text":"<p>Use <code>list_details()</code> to build a billing summary across all accounts. Each <code>Recurring</code> object includes a <code>recurring_billings</code> list with individual charge records:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    accounts = client.recurring.list_details(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    total_revenue = 0.0\n    for acct in accounts:\n        acct_total = sum(b.amount_charged for b in acct.recurring_billings)\n        total_revenue += acct_total\n        if acct_total &gt; 0:\n            print(\n                f\"Account {acct.id} ({acct.plan_name}): \"\n                f\"${acct_total:.2f} over {len(acct.recurring_billings)} billings\"\n            )\n\n    print(f\"\\nTotal recurring revenue: ${total_revenue:.2f}\")\n</code></pre> <p>Use <code>list_details()</code> only when needed</p> <p><code>list_details()</code> returns full <code>Recurring</code> objects for every account, including nested tags, vehicles, and billing history. This is significantly heavier than <code>list()</code>. Use it only when you need billing or status history data in bulk.</p> <p>Shared nested types</p> <p>The <code>Recurring</code> model reuses <code>WashbookCustomer</code>, <code>WashbookTag</code>, and <code>WashbookVehicle</code> from the Washbooks resource. See that guide for field-level documentation of those nested types.</p> <p>Auto-pagination</p> <p>All list methods (<code>list()</code>, <code>list_status_changes()</code>, <code>list_modifications()</code>, and <code>list_details()</code>) automatically fetch all pages of results. You do not need to handle pagination manually.</p> <p>See also</p> <p>For patterns combining recurring accounts with transaction data, see the Transactions guide.</p>"},{"location":"guides/sites/","title":"Sites","text":"<p>The Sites resource provides access to the car wash site locations associated with your API credentials. Each site represents a physical car wash location with its identifying code, name, and timezone. This is a list-only resource -- there is no <code>get()</code> method for individual site detail.</p>"},{"location":"guides/sites/#methods","title":"Methods","text":""},{"location":"guides/sites/#listparams-listsite","title":"<code>list(**params) -&gt; list[Site]</code>","text":"<p>Fetch all sites. Returns a list of <code>Site</code> objects representing every car wash location associated with the API credentials.</p> <pre><code>sites = client.sites.list()\n</code></pre> <p>Not paginated</p> <p>Unlike other resources, the Sites endpoint is not paginated. It returns all sites in a single API call. The <code>list()</code> method makes exactly one request regardless of how many sites exist.</p>"},{"location":"guides/sites/#examples","title":"Examples","text":""},{"location":"guides/sites/#list-all-sites","title":"List all sites","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    for site in sites:\n        print(f\"{site.code}: {site.name} ({site.timezone})\")\n</code></pre>"},{"location":"guides/sites/#access-site-fields","title":"Access site fields","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    for site in sites:\n        print(f\"Site ID:  {site.site_id}\")\n        print(f\"Code:     {site.code}\")\n        print(f\"Name:     {site.name}\")\n        print(f\"Timezone: {site.timezone}\")\n        print()\n</code></pre>"},{"location":"guides/sites/#build-a-site-code-lookup","title":"Build a site code lookup","text":"<p>Site codes are used as filter parameters in other resources. Building a lookup dictionary can be helpful when working across multiple resources:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    # Map site codes to site names\n    site_names = {site.code: site.name for site in sites}\n\n    # Use in combination with other resources\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-01\",\n    )\n\n    for txn in transactions:\n        name = site_names.get(txn.site_code, \"Unknown\")\n        print(f\"{txn.transaction_id} at {name}\")\n</code></pre>"},{"location":"guides/sites/#models","title":"Models","text":""},{"location":"guides/sites/#site","title":"<code>Site</code>","text":"<p>Returned by <code>list()</code>. Contains site location information.</p> Field Type Description <code>site_id</code> <code>int</code> Unique site identifier <code>code</code> <code>str \\| None</code> Site code (used in other API calls) <code>name</code> <code>str</code> Display name of the site <code>timezone</code> <code>str \\| None</code> Timezone of the site location <p>Site codes in other resources</p> <p>Site codes appear throughout other resources (e.g., transactions, clock entries) as a foreign key. Use <code>sites.list()</code> to retrieve the full site names and details for those codes.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/transactions/","title":"Transactions","text":"<p>The Transactions resource provides access to transaction records across all wash types. This is the most feature-rich resource in the client, offering five methods including type-filtered listing, an enriched v2 endpoint, and a batch job system for large exports. Use this resource to retrieve transaction summaries, full details with tenders and line items, and bulk data exports.</p>"},{"location":"guides/transactions/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The Transactions resource exposes five methods. Use this table to pick the right one for your use case:</p> Method Returns Use When Caching Pagination <code>list()</code> <code>TransactionListItem</code> Quick summaries, date range queries None Auto <code>list_by_type()</code> <code>TransactionListItem</code> Filtering by wash/prepaid/recurring/etc. None Auto <code>list_v2()</code> <code>TransactionV2ListItem</code> Need customer_id, recurring flags, status 10-min cache Auto <code>get()</code> <code>Transaction</code> Full detail for a single transaction None N/A <code>load_job()</code> <code>TransactionJobItem</code> Bulk exports, full detail + v2 fields 20-min cache Auto (job-level) <p>For most day-to-day queries, start with <code>list()</code> -- it is the fastest method with no caching layer. Switch to <code>list_by_type()</code> when you only need a specific transaction type (e.g., <code>\"recurring\"</code> or <code>\"giftcard\"</code>). Use <code>list_v2()</code> when your analysis requires the enriched fields like <code>customer_id</code>, <code>is_recurring_plan_sale</code>, or <code>transaction_status</code> -- but be aware of the 10-minute cache. Call <code>get()</code> when you need the complete detail for a single transaction, including tenders, line items, and discounts. For bulk exports where you need full transaction detail on every record, use <code>load_job()</code> -- it combines the depth of <code>get()</code> with the enrichment of <code>list_v2()</code>, at the cost of a slower batch-job workflow and a 20-minute cache.</p>"},{"location":"guides/transactions/#query-parameters","title":"Query Parameters","text":"<p>The list methods (<code>list()</code>, <code>list_by_type()</code>, <code>list_v2()</code>) and <code>load_job()</code> all accept the same query parameters:</p> Parameter Type Description <code>startDate</code> <code>str</code> Start of date range (format: <code>YYYY-MM-DD</code>) <code>endDate</code> <code>str</code> End of date range (format: <code>YYYY-MM-DD</code>) <code>site</code> <code>str</code> Filter by site code <code>region</code> <code>str</code> Filter by region <p>Pagination is handled automatically</p> <p>The <code>limit</code> and <code>offset</code> parameters are managed by the client's auto-pagination logic -- you do not need to set these manually. For <code>load_job()</code>, <code>limit</code> and <code>offset</code> control job-level pagination (default 100 records per job page), but the client handles this transparently.</p> <p><code>get()</code> takes no query parameters</p> <p>The <code>get()</code> method accepts only a positional <code>trans_id</code> argument and does not support any query parameters. Pass the transaction ID directly: <code>client.transactions.get(\"98765\")</code>.</p>"},{"location":"guides/transactions/#methods","title":"Methods","text":""},{"location":"guides/transactions/#listparams-listtransactionlistitem","title":"<code>list(**params) -&gt; list[TransactionListItem]</code>","text":"<p>Fetch all transactions. Returns a list of <code>TransactionListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>transactions = client.transactions.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>transactions = client.transactions.list(\n    startDate=\"2025-06-01\",\n    endDate=\"2025-06-30\",\n)\n</code></pre>"},{"location":"guides/transactions/#gettrans_id-transaction","title":"<code>get(trans_id) -&gt; Transaction</code>","text":"<p>Fetch full details for a single transaction by its ID. Returns a <code>Transaction</code> object with tenders, line items, discounts, and employee information.</p> <pre><code>transaction = client.transactions.get(\"98765\")\n</code></pre>"},{"location":"guides/transactions/#list_by_typeitem_type-params-listtransactionlistitem","title":"<code>list_by_type(item_type, **params) -&gt; list[TransactionListItem]</code>","text":"<p>Fetch all transactions of a specific type. The <code>item_type</code> parameter accepts these values:</p> <ul> <li><code>wash</code> -- standard wash transactions</li> <li><code>prepaid-wash</code> -- prepaid wash redemptions</li> <li><code>recurring</code> -- recurring membership transactions</li> <li><code>washbook</code> -- wash book transactions</li> <li><code>giftcard</code> -- gift card transactions</li> <li><code>merchandise</code> -- merchandise sales</li> <li><code>house-account</code> -- house account transactions</li> </ul> <pre><code>wash_transactions = client.transactions.list_by_type(\"wash\")\n</code></pre>"},{"location":"guides/transactions/#list_v2params-listtransactionv2listitem","title":"<code>list_v2(**params) -&gt; list[TransactionV2ListItem]</code>","text":"<p>Fetch all transactions using the v2 endpoint. Returns enriched list items with additional fields: <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, and <code>transaction_status</code>.</p> <pre><code>transactions_v2 = client.transactions.list_v2(\n    startDate=\"2025-06-01\",\n    endDate=\"2025-06-30\",\n)\n</code></pre> <p>V2 caching</p> <p>The API caches v2 responses for 10 minutes per reporting criteria. If you need real-time data, use the standard <code>list()</code> method instead.</p>"},{"location":"guides/transactions/#load_job-poll_interval20-timeout3000-params-listtransactionjobitem","title":"<code>load_job(*, poll_interval=2.0, timeout=300.0, **params) -&gt; list[TransactionJobItem]</code>","text":"<p>Submit a batch job and auto-poll until results are ready. Returns <code>TransactionJobItem</code> objects -- full transaction details enriched with v2 fields. The method handles pagination at the job submission level, submitting as many jobs as needed to retrieve all records.</p> <pre><code>job_results = client.transactions.load_job(\n    startDate=\"2025-06-15\",\n    endDate=\"2025-06-16\",\n)\n</code></pre> <p>Date range limit</p> <p>The <code>load_job()</code> method is limited to a maximum 24-hour date range per call. For longer periods, submit multiple jobs with consecutive date ranges.</p> <p>Job caching and polling</p> <p>Job data is cached by the API for 20 minutes. The <code>poll_interval</code> parameter controls how frequently the client checks for results (default 2 seconds), and <code>timeout</code> sets the maximum wait time per job (default 300 seconds / 5 minutes).</p>"},{"location":"guides/transactions/#examples","title":"Examples","text":""},{"location":"guides/transactions/#list-transactions-with-date-range","title":"List transactions with date range","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for txn in transactions:\n        print(\n            f\"#{txn.trans_number} (ID: {txn.trans_id}) - \"\n            f\"${txn.total:.2f} on {txn.date}\"\n        )\n</code></pre>"},{"location":"guides/transactions/#get-transaction-detail","title":"Get transaction detail","text":"<p>The detail endpoint returns the complete transaction including tenders, line items, discounts, and employee information:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    txn = client.transactions.get(\"98765\")\n\n    # Transaction summary\n    print(f\"Transaction #{txn.number} ({txn.type})\")\n    print(f\"Date: {txn.complete_date}\")\n    print(f\"Location: {txn.location_code}\")\n    print(f\"Total: ${txn.total:.2f}\")\n    print(f\"Customer: {txn.customer_name or 'N/A'}\")\n    print(f\"Cashier: {txn.employee_cashier or 'N/A'}\")\n\n    # Line items\n    print(\"\\nItems:\")\n    for item in txn.items:\n        voided = \" [VOIDED]\" if item.is_voided else \"\"\n        print(f\"  {item.name} ({item.department}): ${item.net:.2f}{voided}\")\n\n    # Payment tenders\n    print(\"\\nTenders:\")\n    for tender in txn.tenders:\n        print(f\"  {tender.tender}: ${tender.total:.2f}\")\n\n    # Discounts\n    if txn.discounts:\n        print(\"\\nDiscounts:\")\n        for disc in txn.discounts:\n            print(f\"  {disc.discount_name} on {disc.applied_to_item_name}: -${disc.discount_amount:.2f}\")\n</code></pre>"},{"location":"guides/transactions/#filter-by-transaction-type","title":"Filter by transaction type","text":"<p>Retrieve only specific transaction types to focus your analysis:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Get all recurring membership transactions\n    recurring_txns = client.transactions.list_by_type(\n        \"recurring\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(recurring_txns)} recurring transactions\")\n\n    # Get all gift card transactions\n    gc_txns = client.transactions.list_by_type(\n        \"giftcard\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(gc_txns)} gift card transactions\")\n</code></pre>"},{"location":"guides/transactions/#use-the-v2-endpoint-for-enriched-data","title":"Use the v2 endpoint for enriched data","text":"<p>The v2 endpoint adds <code>customer_id</code>, recurring flags, and transaction status to each list item:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list_v2(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for txn in transactions:\n        flags = []\n        if txn.is_recurring_plan_sale:\n            flags.append(\"recurring-sale\")\n        if txn.is_recurring_plan_redemption:\n            flags.append(\"recurring-redemption\")\n\n        flag_str = f\" [{', '.join(flags)}]\" if flags else \"\"\n        print(\n            f\"#{txn.trans_number}: ${txn.total:.2f} - \"\n            f\"Status: {txn.transaction_status}\"\n            f\"{flag_str}\"\n        )\n</code></pre>"},{"location":"guides/transactions/#batch-export-with-load_job","title":"Batch export with load_job","text":"<p>The <code>load_job()</code> method is designed for bulk data exports. It submits a batch job to the API, automatically polls for completion, and paginates through all results:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Export one day of transactions (max 24-hour range)\n    results = client.transactions.load_job(\n        startDate=\"2025-06-15\",\n        endDate=\"2025-06-16\",\n    )\n\n    print(f\"Exported {len(results)} transactions\")\n\n    for txn in results:\n        print(\n            f\"#{txn.number} at {txn.location_code}: \"\n            f\"${txn.total:.2f} ({txn.transaction_status})\"\n        )\n</code></pre> <p>You can customize the polling behavior:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    results = client.transactions.load_job(\n        startDate=\"2025-06-15\",\n        endDate=\"2025-06-16\",\n        poll_interval=5.0,   # Check every 5 seconds\n        timeout=600.0,       # Wait up to 10 minutes\n    )\n</code></pre>"},{"location":"guides/transactions/#batch-job-workflow","title":"Batch Job Workflow","text":"<p>The <code>load_job()</code> method is the most complex operation in the SDK. Under the hood, it orchestrates a multi-step batch job workflow against two API endpoints. This section explains how it works so you can understand the timing, error handling, and pagination behavior.</p>"},{"location":"guides/transactions/#how-it-works","title":"How It Works","text":"<p>Each call to <code>load_job()</code> follows a three-phase workflow: submit the job, poll for completion, and return the results.</p> <pre><code>  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  Submit Job  \u2502\u2500\u2500\u2500\u2500&gt;\u2502  Poll Status  \u2502\u2500\u2500\u2500\u2500&gt;\u2502   Return    \u2502\n  \u2502  POST        \u2502     \u2502  GET          \u2502     \u2502   Results   \u2502\n  \u2502  /load-job   \u2502     \u2502  /get-job-data\u2502     \u2502             \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n                        \u2502 Status? \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u25bc        \u25bc        \u25bc\n                 \"pass\"  \"working\"  \"fail\"\n                   \u2502        \u2502        \u2502\n                   \u2502     sleep &amp;     \u2502\n                   \u2502     retry \u2500\u2500\u2510   \u2502\n                   \u2502        ^    \u2502   \u2502\n                   \u2502        \u2514\u2500\u2500\u2500\u2500\u2518   \u2502\n                   \u25bc                 \u25bc\n               Return data     Raise APIError\n</code></pre> <ol> <li>Submit -- The client sends a <code>POST</code> request to <code>/transaction/load-job</code>    with your query parameters. The API returns a <code>hash</code> identifier for the job.</li> <li>Poll -- The client sends <code>GET</code> requests to <code>/transaction/get-job-data</code>    with the job hash, sleeping <code>poll_interval</code> seconds between attempts.</li> <li>Return -- When the status reaches <code>\"pass\"</code>, the response contains the    transaction data. The client validates each record into a    <code>TransactionJobItem</code> model and returns the full list.</li> </ol>"},{"location":"guides/transactions/#job-status-lifecycle","title":"Job Status Lifecycle","text":"<p>Each polling response includes a <code>status</code> field with one of three values:</p> <ul> <li><code>\"working\"</code> -- The job is still processing. The client sleeps for   <code>poll_interval</code> seconds (default 2.0) and sends another poll request.</li> <li><code>\"pass\"</code> -- The job completed successfully. Transaction data is available   in the response body.</li> <li><code>\"fail\"</code> -- The job failed on the server side. The client raises an   <code>APIError</code> with the message <code>\"Batch job failed\"</code>.</li> </ul>"},{"location":"guides/transactions/#multi-page-jobs","title":"Multi-Page Jobs","text":"<p>Pagination for <code>load_job()</code> happens at the job submission level, not within a single job response. Each <code>POST /transaction/load-job</code> with a different <code>offset</code> value submits a separate batch job. The client handles this automatically:</p> <ol> <li>The first job is submitted with <code>offset=1</code> (or your custom starting offset).</li> <li>The response includes a <code>total</code> field indicating the total number of records.</li> <li>The client calculates how many additional pages are needed based on <code>total</code>    and the <code>limit</code> (default 100 records per page).</li> <li>Each remaining page submits a new job and goes through its own submit, poll,    and return cycle.</li> </ol> <p>All results are collected and returned as a single flat list.</p>"},{"location":"guides/transactions/#timeouts-and-errors","title":"Timeouts and Errors","text":"<p>Two error conditions can occur during the batch job workflow:</p> <ul> <li><code>APIError(\"Batch job failed\")</code> -- Raised when the API returns a job   status of <code>\"fail\"</code>. This indicates a server-side error processing your   request. Retry with the same parameters or narrow your date range.</li> <li><code>APITimeoutError</code> -- Raised when a single job does not reach <code>\"pass\"</code> or   <code>\"fail\"</code> within the <code>timeout</code> period (default 300 seconds / 5 minutes).   Increase the <code>timeout</code> parameter if you expect slow processing.</li> </ul> <p>Timeout applies per job page</p> <p>The <code>timeout</code> parameter applies to each individual job page, not to the entire <code>load_job()</code> call. For example, a query returning 500 records with the default limit of 100 submits 5 separate jobs. Each job has its own 300-second timeout, so the theoretical maximum wall time is 5 x 300 = 1,500 seconds (25 minutes).</p>"},{"location":"guides/transactions/#models","title":"Models","text":""},{"location":"guides/transactions/#transactionlistitem","title":"<code>TransactionListItem</code>","text":"<p>Returned by <code>list()</code> and <code>list_by_type()</code>. Contains summary fields.</p> Field Type Description <code>trans_number</code> <code>int</code> Transaction number <code>trans_id</code> <code>str</code> Unique transaction identifier <code>total</code> <code>float</code> Transaction total amount <code>date</code> <code>str</code> Transaction date"},{"location":"guides/transactions/#transactionv2listitem","title":"<code>TransactionV2ListItem</code>","text":"<p>Returned by <code>list_v2()</code>. Extends <code>TransactionListItem</code> with enriched fields.</p> Field Type Description <code>trans_number</code> <code>int</code> Transaction number <code>trans_id</code> <code>str</code> Unique transaction identifier <code>total</code> <code>float</code> Transaction total amount <code>date</code> <code>str</code> Transaction date <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>is_recurring_plan_sale</code> <code>bool</code> Whether this is a recurring sale <code>is_recurring_plan_redemption</code> <code>bool</code> Whether this is a recurring redemption <code>transaction_status</code> <code>str</code> Transaction status"},{"location":"guides/transactions/#transaction","title":"<code>Transaction</code>","text":"<p>Returned by <code>get()</code>. Contains full transaction details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique transaction identifier <code>number</code> <code>int</code> Transaction number <code>type</code> <code>str</code> Transaction type <code>complete_date</code> <code>str</code> Date and time of the transaction <code>location_code</code> <code>str</code> Site location code <code>sales_device_name</code> <code>str</code> Name of the sales device / POS <code>total</code> <code>float</code> Transaction total amount <code>customer_name</code> <code>str \\| None</code> Customer name <code>customer_id</code> <code>str \\| None</code> Customer identifier <code>vehicle_license_plate</code> <code>str \\| None</code> Vehicle license plate <code>employee_cashier</code> <code>str \\| None</code> Cashier employee name <code>employee_greeter</code> <code>str \\| None</code> Greeter employee name <code>is_recurring_payment</code> <code>bool</code> Recurring payment flag <code>is_recurring_redemption</code> <code>bool</code> Recurring redemption flag <code>is_recurring_sale</code> <code>bool</code> Recurring sale flag <code>is_prepaid_redemption</code> <code>bool</code> Prepaid redemption flag <code>is_prepaid_sale</code> <code>bool</code> Prepaid sale flag <code>tenders</code> <code>list[TransactionTender]</code> Payment tenders (see below) <code>items</code> <code>list[TransactionItem]</code> Line items (see below) <code>discounts</code> <code>list[TransactionDiscount]</code> Applied discounts (see below)"},{"location":"guides/transactions/#transactionjobitem","title":"<code>TransactionJobItem</code>","text":"<p>Returned by <code>load_job()</code>. Extends <code>Transaction</code> with v2 enrichment fields.</p> <p>This model inherits all fields from <code>Transaction</code> (see above) plus:</p> Field Type Description <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>is_recurring_plan_sale</code> <code>bool \\| None</code> Whether this is a recurring sale <code>is_recurring_plan_redemption</code> <code>bool \\| None</code> Whether this is a recurring redemption <code>transaction_status</code> <code>str \\| None</code> Transaction status"},{"location":"guides/transactions/#transactiontender","title":"<code>TransactionTender</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>tender</code> <code>str</code> Tender type name <code>tender_sub_type</code> <code>str \\| None</code> Tender sub-type <code>amount</code> <code>float</code> Tender amount <code>change</code> <code>float</code> Change given <code>total</code> <code>float</code> Net tender total <code>reference_number</code> <code>str \\| None</code> Payment reference number <code>credit_card_last_four</code> <code>str \\| None</code> Last four digits of card <code>credit_card_expiration_date</code> <code>str \\| None</code> Card expiration date"},{"location":"guides/transactions/#transactionitem","title":"<code>TransactionItem</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>name</code> <code>str</code> Item name <code>sku</code> <code>str \\| None</code> Item SKU <code>department</code> <code>str</code> Department name <code>quantity</code> <code>int</code> Quantity sold <code>gross</code> <code>float</code> Gross amount <code>net</code> <code>float</code> Net amount <code>discount</code> <code>float</code> Discount amount <code>tax</code> <code>float</code> Tax amount <code>additional_fee</code> <code>float</code> Additional fees <code>is_voided</code> <code>bool</code> Whether the item was voided"},{"location":"guides/transactions/#transactiondiscount","title":"<code>TransactionDiscount</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>discount_name</code> <code>str</code> Discount name <code>discount_sku</code> <code>str \\| None</code> Discount SKU <code>applied_to_item_name</code> <code>str</code> Item the discount was applied to <code>discount_amount</code> <code>float</code> Amount discounted <code>discount_code</code> <code>str</code> Discount code"},{"location":"guides/transactions/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/transactions/#multi-day-exports","title":"Multi-Day Exports","text":"<p>Since <code>load_job()</code> is limited to a 24-hour date range per call, use a loop to export multiple days:</p> <pre><code>from datetime import date, timedelta\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    start = date(2025, 6, 1)\n    end = date(2025, 6, 30)\n    all_results = []\n\n    current = start\n    while current &lt; end:\n        next_day = current + timedelta(days=1)\n        day_results = client.transactions.load_job(\n            startDate=current.isoformat(),\n            endDate=next_day.isoformat(),\n        )\n        all_results.extend(day_results)\n        current = next_day\n\n    print(f\"Exported {len(all_results)} transactions over {(end - start).days} days\")\n</code></pre> <p>Spacing requests for large exports</p> <p>For very large exports, consider adding a small <code>time.sleep()</code> between days to stay well within the rate limit. The client handles 429 retries automatically, but spacing requests reduces retry churn.</p>"},{"location":"guides/transactions/#error-handling","title":"Error Handling","text":"<p>Transaction-specific error handling patterns:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    APIError,\n    APITimeoutError,\n    RateLimitError,\n    ValidationError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        results = client.transactions.load_job(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n            timeout=600.0,\n        )\n    except APITimeoutError:\n        print(\"Job timed out \u2014 try a shorter date range or increase timeout\")\n    except APIError as e:\n        print(f\"Job failed: {e}\")\n    except RateLimitError:\n        print(\"Rate limit exceeded after max retries\")\n</code></pre> <p><code>ValidationError</code></p> <p><code>ValidationError</code> is raised when date format is invalid or parameters fail API validation. This is caught before the request is sent, so it does not count against the rate limit.</p>"},{"location":"guides/transactions/#cross-resource-lookups","title":"Cross-Resource Lookups","text":"<p>Enrich transaction data by combining with other resources:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Get enriched transactions with customer_id\n    transactions = client.transactions.list_v2(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Build customer lookup from customer_ids found in transactions\n    customer_ids = {t.customer_id for t in transactions if t.customer_id}\n    customers = {\n        c.customer_id: c\n        for c in client.customers.list()\n        if c.customer_id in customer_ids\n    }\n\n    # Enrich transactions with customer names\n    for txn in transactions:\n        if txn.customer_id and txn.customer_id in customers:\n            customer = customers[txn.customer_id]\n            print(f\"#{txn.trans_number}: ${txn.total:.2f} \u2014 {customer.first_name} {customer.last_name}\")\n</code></pre> <p>Auto-pagination</p> <p>The <code>list()</code>, <code>list_by_type()</code>, and <code>list_v2()</code> methods automatically fetch all pages of results. The <code>load_job()</code> method handles pagination at the job submission level, submitting multiple jobs as needed.</p>"},{"location":"guides/washbooks/","title":"Washbooks","text":"<p>The Washbooks resource provides access to prepaid wash book accounts. Each account tracks balances, sign-up and cancellation dates, and billing site information. The detail endpoint expands each account with customer contact info, RFID tags, associated vehicles, and recurring billing details.</p>"},{"location":"guides/washbooks/#methods","title":"Methods","text":""},{"location":"guides/washbooks/#listparams-listwashbooklistitem","title":"<code>list(**params) -&gt; list[WashbookListItem]</code>","text":"<p>Fetch all wash book accounts. Returns a list of <code>WashbookListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>washbooks = client.washbooks.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>washbooks = client.washbooks.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/washbooks/#getaccount_id-washbook","title":"<code>get(account_id) -&gt; Washbook</code>","text":"<p>Fetch full details for a single wash book account by its ID. Returns a <code>Washbook</code> object with nested customer, tag, vehicle, and recurring billing information.</p> <pre><code>washbook = client.washbooks.get(\"12345\")\n</code></pre>"},{"location":"guides/washbooks/#examples","title":"Examples","text":""},{"location":"guides/washbooks/#list-all-wash-book-accounts","title":"List all wash book accounts","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    washbooks = client.washbooks.list()\n\n    for wb in washbooks:\n        print(f\"{wb.name} (ID: {wb.id}) - Status: {wb.status}\")\n</code></pre>"},{"location":"guides/washbooks/#filter-by-date-and-check-balances","title":"Filter by date and check balances","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    recent = client.washbooks.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for wb in recent:\n        print(f\"Account {wb.id}: balance={wb.balance}, site={wb.billing_site_id}\")\n</code></pre>"},{"location":"guides/washbooks/#get-wash-book-detail-with-customer-info","title":"Get wash book detail with customer info","text":"<p>The detail endpoint returns rich nested data including the customer, tags, vehicles, and recurring billing information:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    # Customer information\n    print(f\"Customer: {wb.customer.first_name} {wb.customer.last_name}\")\n    print(f\"Customer ID: {wb.customer.id}\")\n\n    # Account status and balance\n    print(f\"Status: {wb.status}\")\n    print(f\"Balance: {wb.balance}\")\n</code></pre>"},{"location":"guides/washbooks/#iterate-tags-and-vehicles","title":"Iterate tags and vehicles","text":"<p>Each wash book detail includes lists of RFID tags and associated vehicles:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    # RFID tags\n    for tag in wb.tags:\n        status = \"active\" if tag.enabled else \"disabled\"\n        print(f\"Tag #{tag.number} (ID: {tag.id}) - {status}\")\n\n    # Vehicles\n    for vehicle in wb.vehicles:\n        plate = vehicle.plate or \"No plate\"\n        print(f\"Vehicle {vehicle.id}: {plate}\")\n</code></pre>"},{"location":"guides/washbooks/#access-recurring-billing-info","title":"Access recurring billing info","text":"<p>The <code>recurring_info</code> field provides current billing details and trial status:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    info = wb.recurring_info\n    print(f\"Billing amount: ${info.current_billable_amount:.2f}\")\n    print(f\"Next bill date: {info.next_bill_date}\")\n    print(f\"Last bill date: {info.last_bill_date}\")\n    print(f\"On trial: {info.is_on_trial}\")\n    if info.is_on_trial:\n        print(f\"Remaining trial periods: {info.remaining_trial_periods}\")\n</code></pre>"},{"location":"guides/washbooks/#models","title":"Models","text":""},{"location":"guides/washbooks/#washbooklistitem","title":"<code>WashbookListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each wash book account.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str \\| None</code> Account name <code>balance</code> <code>str</code> Current account balance <code>sign_up_date</code> <code>str</code> Date the account was created <code>cancel_date</code> <code>str \\| None</code> Date the account was cancelled <code>billing_site_id</code> <code>int</code> ID of the billing site <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>status</code> <code>str</code> Current account status"},{"location":"guides/washbooks/#washbook","title":"<code>Washbook</code>","text":"<p>Returned by <code>get()</code>. Contains full account details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str</code> Account name <code>balance</code> <code>str \\| None</code> Current account balance <code>customer</code> <code>WashbookCustomer</code> Nested customer object (see below) <code>status</code> <code>str</code> Current account status <code>recurring_info</code> <code>WashbookRecurringInfo</code> Billing and trial info (see below) <code>tags</code> <code>list[WashbookTag]</code> List of RFID tags (see below) <code>vehicles</code> <code>list[WashbookVehicle]</code> List of vehicles (see below)"},{"location":"guides/washbooks/#washbookcustomer","title":"<code>WashbookCustomer</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str \\| None</code> Customer identifier <code>number</code> <code>str \\| None</code> Customer account number <code>first_name</code> <code>str \\| None</code> Customer first name <code>last_name</code> <code>str \\| None</code> Customer last name"},{"location":"guides/washbooks/#washbookrecurringinfo","title":"<code>WashbookRecurringInfo</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>current_billable_amount</code> <code>float</code> Current billing amount <code>next_bill_date</code> <code>str \\| None</code> Next scheduled billing date <code>last_bill_date</code> <code>str \\| None</code> Most recent billing date <code>is_on_trial</code> <code>bool</code> Whether the account is on trial <code>remaining_trial_periods</code> <code>int</code> Number of trial periods left"},{"location":"guides/washbooks/#washbooktag","title":"<code>WashbookTag</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str</code> Unique tag identifier <code>number</code> <code>str</code> Tag number <code>enabled</code> <code>bool</code> Whether the tag is active"},{"location":"guides/washbooks/#washbookvehicle","title":"<code>WashbookVehicle</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str</code> Unique vehicle identifier <code>plate</code> <code>str \\| None</code> License plate number <p>Nested model relationships</p> <p>The <code>Washbook</code> detail model contains four nested types: <code>WashbookCustomer</code>, <code>WashbookRecurringInfo</code>, <code>WashbookTag</code>, and <code>WashbookVehicle</code>. These same nested types are also used by the Recurring Accounts resource.</p> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"}]}