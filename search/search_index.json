{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Sonny's Data Client","text":"<p>A typed Python SDK for the Sonny's Carwash Controls Data API.</p> <p><code>sonnys-data-client</code> wraps the Sonny's Carwash Controls REST API with a resource-based interface. Every response is returned as a validated Pydantic v2 model, list calls auto-paginate transparently, and a built-in rate limiter keeps your application within the API's request window.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>8 resource types -- Customers, Employees, Giftcards, Items, Recurring Accounts, Sites, Transactions, and Washbooks</li> <li>Auto-pagination -- <code>.list()</code> calls transparently fetch all pages</li> <li>Rate limiting -- Built-in rate limiter with exponential-backoff retry</li> <li>Pydantic v2 models -- Fully typed responses with validation</li> <li>Batch jobs -- Long-running export operations with polling support</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/christopher-nance/Sonnys-Data-API-V2.git\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list(\n        startDate=\"2024-01-01\", endDate=\"2024-01-31\"\n    )\n    for txn in transactions:\n        print(txn.transaction_id, txn.total)\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Client -- <code>SonnysClient</code> constructor and configuration</li> <li>Resources -- Resource classes for each API endpoint</li> <li>Models -- Pydantic response models</li> <li>Exceptions -- Error types and exception hierarchy</li> </ul>"},{"location":"api/client/","title":"Client","text":""},{"location":"api/client/#sonnys_data_client.SonnysClient","title":"SonnysClient","text":"<pre><code>SonnysClient(\n    api_id: str,\n    api_key: str,\n    site_code: str | None = None,\n    *,\n    max_retries: int = 3,\n)\n</code></pre> <p>Client for the Sonny's Carwash Controls Data API.</p> <p>Manages authentication and HTTP session lifecycle. Use as a context manager or call :meth:<code>close</code> explicitly when done.</p> <p>Parameters:</p> Name Type Description Default <code>api_id</code> <code>str</code> <p>Sonny's API ID credential.</p> required <code>api_key</code> <code>str</code> <p>Sonny's API key credential.</p> required <code>site_code</code> <code>str | None</code> <p>Optional site code to scope requests to a specific site.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>Maximum number of retries for 429 responses.</p> <code>3</code>"},{"location":"api/client/#sonnys_data_client.SonnysClient.customers","title":"customers  <code>cached</code> <code>property</code>","text":"<pre><code>customers: Customers\n</code></pre> <p>Access the Customers resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.items","title":"items  <code>cached</code> <code>property</code>","text":"<pre><code>items: Items\n</code></pre> <p>Access the Items resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.employees","title":"employees  <code>cached</code> <code>property</code>","text":"<pre><code>employees: Employees\n</code></pre> <p>Access the Employees resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.giftcards","title":"giftcards  <code>cached</code> <code>property</code>","text":"<pre><code>giftcards: Giftcards\n</code></pre> <p>Access the Giftcards resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.sites","title":"sites  <code>cached</code> <code>property</code>","text":"<pre><code>sites: Sites\n</code></pre> <p>Access the Sites resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.transactions","title":"transactions  <code>cached</code> <code>property</code>","text":"<pre><code>transactions: Transactions\n</code></pre> <p>Access the Transactions resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.washbooks","title":"washbooks  <code>cached</code> <code>property</code>","text":"<pre><code>washbooks: Washbooks\n</code></pre> <p>Access the Washbooks resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.recurring","title":"recurring  <code>cached</code> <code>property</code>","text":"<pre><code>recurring: RecurringAccounts\n</code></pre> <p>Access the Recurring Accounts resource.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the underlying HTTP session.</p>"},{"location":"api/client/#sonnys_data_client.SonnysClient.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; SonnysClient\n</code></pre>"},{"location":"api/client/#sonnys_data_client.SonnysClient.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: object) -&gt; None\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>All exceptions raised by the SDK inherit from <code>SonnysError</code>. The hierarchy is:</p> <pre><code>SonnysError\n  APIError\n    APIConnectionError\n      APITimeoutError\n    APIStatusError\n      AuthError\n      RateLimitError\n      ValidationError\n      NotFoundError\n      ServerError\n</code></pre> <p>Catch <code>SonnysError</code> to handle any SDK error, or catch specific subclasses for fine-grained control:</p> <pre><code>from sonnys_data_client import SonnysClient, AuthError, RateLimitError, SonnysError\n\ntry:\n    client.customers.list()\nexcept AuthError:\n    print(\"Invalid credentials\")\nexcept RateLimitError:\n    print(\"Too many requests\")\nexcept SonnysError:\n    print(\"Something else went wrong\")\n</code></pre>"},{"location":"api/exceptions/#sonnys_data_client.SonnysError","title":"SonnysError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Sonny's Data Client errors.</p>"},{"location":"api/exceptions/#sonnys_data_client.APIError","title":"APIError","text":"<pre><code>APIError(message: str)\n</code></pre> <p>               Bases: <code>SonnysError</code></p> <p>An error returned by the API.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Human-readable error description.</p>"},{"location":"api/exceptions/#sonnys_data_client.APIConnectionError","title":"APIConnectionError","text":"<pre><code>APIConnectionError(message: str = 'Connection error.')\n</code></pre> <p>               Bases: <code>APIError</code></p> <p>Failed to connect to the Sonny's Data API.</p>"},{"location":"api/exceptions/#sonnys_data_client.APITimeoutError","title":"APITimeoutError","text":"<pre><code>APITimeoutError(message: str = 'Request timed out.')\n</code></pre> <p>               Bases: <code>APIConnectionError</code></p> <p>Request to the Sonny's Data API timed out.</p>"},{"location":"api/exceptions/#sonnys_data_client.APIStatusError","title":"APIStatusError","text":"<pre><code>APIStatusError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIError</code></p> <p>API returned an error HTTP status.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <p>The HTTP status code returned by the API.</p> <code>body</code> <p>The parsed JSON error body, if available.</p> <code>error_type</code> <p>The Sonny's API error type string, if available.</p>"},{"location":"api/exceptions/#sonnys_data_client.AuthError","title":"AuthError","text":"<pre><code>AuthError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p> <p>Authentication or authorization failed (HTTP 403).</p> <p>Raised for invalid/missing API credentials or unauthorized site access.</p>"},{"location":"api/exceptions/#sonnys_data_client.RateLimitError","title":"RateLimitError","text":"<pre><code>RateLimitError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p> <p>Rate limit exceeded (HTTP 429).</p> <p>The client auto-retries with backoff, so this is only raised after retries are exhausted.</p>"},{"location":"api/exceptions/#sonnys_data_client.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p> <p>Request validation failed (HTTP 400/422).</p> <p>Check <code>error_type</code> and <code>body</code> for details on invalid parameters.</p>"},{"location":"api/exceptions/#sonnys_data_client.NotFoundError","title":"NotFoundError","text":"<pre><code>NotFoundError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p> <p>Requested resource not found (HTTP 404).</p>"},{"location":"api/exceptions/#sonnys_data_client.ServerError","title":"ServerError","text":"<pre><code>ServerError(\n    message: str,\n    *,\n    status_code: int,\n    body: dict | None = None,\n    error_type: str | None = None,\n)\n</code></pre> <p>               Bases: <code>APIStatusError</code></p> <p>Sonny's API server error (HTTP 500+).</p>"},{"location":"api/models/","title":"Models","text":"<p>All response models are Pydantic v2 <code>BaseModel</code> subclasses. The API returns camelCase field names; each model uses <code>alias_generator = to_camel</code> so you can access fields with Pythonic snake_case attributes.</p> <pre><code>customer = client.customers.get(\"12345\")\nprint(customer.first_name)   # snake_case attribute\nprint(customer.model_dump(by_alias=True))  # camelCase dict\n</code></pre>"},{"location":"api/models/#customers","title":"Customers","text":""},{"location":"api/models/#sonnys_data_client.types.CustomerListItem","title":"CustomerListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Summary customer record returned by <code>client.customers.list()</code>.</p> <p>Contains identifiers, name, phone, and active status.</p>"},{"location":"api/models/#sonnys_data_client.types.Customer","title":"Customer","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Full customer profile returned by <code>client.customers.get(id)</code>.</p> <p>Includes address, contact details, loyalty info, and SMS opt-in status.</p>"},{"location":"api/models/#items","title":"Items","text":""},{"location":"api/models/#sonnys_data_client.types.Item","title":"Item","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A menu item (wash package, product, or service) returned by <code>client.items.list()</code>.</p> <p>Includes SKU, pricing, and department info.</p>"},{"location":"api/models/#employees","title":"Employees","text":""},{"location":"api/models/#sonnys_data_client.types.EmployeeListItem","title":"EmployeeListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Summary employee record returned by <code>client.employees.list()</code>.</p> <p>Contains name and employee ID.</p>"},{"location":"api/models/#sonnys_data_client.types.Employee","title":"Employee","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Full employee profile returned by <code>client.employees.get(id)</code>.</p> <p>Includes contact info, active status, and start date.</p>"},{"location":"api/models/#sonnys_data_client.types.ClockEntry","title":"ClockEntry","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A single clock-in/clock-out record for an employee.</p> <p>Returned by <code>client.employees.get_clock_entries()</code>.</p>"},{"location":"api/models/#sites","title":"Sites","text":""},{"location":"api/models/#sonnys_data_client.types.Site","title":"Site","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A car wash site/location returned by <code>client.sites.list()</code>.</p> <p>Contains the site code, name, and timezone.</p>"},{"location":"api/models/#giftcards","title":"Giftcards","text":""},{"location":"api/models/#sonnys_data_client.types.GiftcardListItem","title":"GiftcardListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A giftcard liability record returned by <code>client.giftcards.list()</code>.</p> <p>Contains card number, value, amount used, and site code.</p>"},{"location":"api/models/#washbooks","title":"Washbooks","text":""},{"location":"api/models/#sonnys_data_client.types.WashbookListItem","title":"WashbookListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Summary washbook record returned by <code>client.washbooks.list()</code>.</p> <p>Contains ID, balance, status, and sign-up date.</p>"},{"location":"api/models/#sonnys_data_client.types.Washbook","title":"Washbook","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Full washbook detail returned by <code>client.washbooks.get(id)</code>.</p> <p>Includes customer, vehicles, tags, and recurring billing info.</p>"},{"location":"api/models/#sonnys_data_client.types.WashbookTag","title":"WashbookTag","text":"<p>               Bases: <code>SonnysModel</code></p> <p>An RFID tag or barcode associated with a washbook account.</p>"},{"location":"api/models/#sonnys_data_client.types.WashbookVehicle","title":"WashbookVehicle","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A vehicle linked to a washbook account.</p>"},{"location":"api/models/#recurring","title":"Recurring","text":""},{"location":"api/models/#sonnys_data_client.types.RecurringListItem","title":"RecurringListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Summary recurring account returned by <code>client.recurring.list()</code>.</p> <p>Contains ID, plan name, status, balance, and billing site.</p>"},{"location":"api/models/#sonnys_data_client.types.Recurring","title":"Recurring","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Full recurring account detail returned by <code>client.recurring.get(id)</code>.</p> <p>Includes customer, vehicles, tags, billing history, and status history.</p>"},{"location":"api/models/#sonnys_data_client.types.RecurringStatusChange","title":"RecurringStatusChange","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A status change event returned by <code>client.recurring.list_status_changes()</code>.</p> <p>Records old/new status, date, employee, and site.</p>"},{"location":"api/models/#sonnys_data_client.types.RecurringModification","title":"RecurringModification","text":"<p>               Bases: <code>Recurring</code></p> <p>A recurring account with its modification history.</p> <p>Extends :class:<code>Recurring</code> with a modifications list. Returned by <code>client.recurring.list_modifications()</code>.</p>"},{"location":"api/models/#transactions","title":"Transactions","text":""},{"location":"api/models/#sonnys_data_client.types.TransactionListItem","title":"TransactionListItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Summary transaction record returned by <code>client.transactions.list()</code> and <code>client.transactions.list_by_type()</code>.</p> <p>Contains transaction number, ID, total, and date.</p>"},{"location":"api/models/#sonnys_data_client.types.TransactionV2ListItem","title":"TransactionV2ListItem","text":"<p>               Bases: <code>TransactionListItem</code></p> <p>Enriched transaction summary returned by <code>client.transactions.list_v2()</code>.</p> <p>Extends :class:<code>TransactionListItem</code> with customer ID, recurring plan flags, and transaction status.</p>"},{"location":"api/models/#sonnys_data_client.types.Transaction","title":"Transaction","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Full transaction detail returned by <code>client.transactions.get(id)</code>.</p> <p>Includes line items, tenders, discounts, customer/employee info, and prepaid/recurring flags.</p>"},{"location":"api/models/#sonnys_data_client.types.TransactionJobItem","title":"TransactionJobItem","text":"<p>               Bases: <code>Transaction</code></p> <p>Transaction record returned by <code>client.transactions.load_job()</code>.</p> <p>Extends :class:<code>Transaction</code> with additional fields from the batch job endpoint.</p>"},{"location":"api/models/#sonnys_data_client.types.TransactionTender","title":"TransactionTender","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A payment tender (cash, credit, etc.) within a transaction detail.</p> <p>Contains tender type, amount, change, and optional credit card info.</p>"},{"location":"api/models/#sonnys_data_client.types.TransactionItem","title":"TransactionItem","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A line item within a transaction detail.</p> <p>Contains the item name, SKU, department, quantity, and price breakdown (gross, net, discount, tax).</p>"},{"location":"api/models/#sonnys_data_client.types.TransactionDiscount","title":"TransactionDiscount","text":"<p>               Bases: <code>SonnysModel</code></p> <p>A discount applied within a transaction detail.</p> <p>Records the discount name, code, amount, and which item it was applied to.</p>"},{"location":"api/models/#stats","title":"Stats","text":""},{"location":"api/models/#sonnys_data_client.types.SalesResult","title":"SalesResult","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Revenue breakdown returned by <code>client.stats.total_sales()</code>.</p> <p>Categorizes total revenue into three buckets based on transaction flags: recurring plan sales, recurring redemptions, and retail. Each bucket includes both a revenue total and a transaction count.</p>"},{"location":"api/models/#sonnys_data_client.types.WashResult","title":"WashResult","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Wash volume breakdown returned by <code>client.stats.total_washes()</code>.</p> <p>Categorizes wash transactions using v2 flags, v1 <code>type=wash</code>, and v1 <code>type=recurring</code>:</p> <ul> <li>member_wash_count: Transactions where   <code>is_recurring_plan_redemption</code> is <code>True</code> (membership washes).</li> <li>retail_wash_count: Non-member car washes \u2014 <code>type=wash</code>   transactions (excluding plan sales and redemptions) plus   unknown non-negative transaction types.</li> <li>free_wash_count: Washes with <code>total == 0</code>.</li> <li>eligible_wash_count: Derived as   <code>total - member_wash_count - free_wash_count</code>.  Used as the   denominator in conversion rate calculations.  Includes plan sale   washes and positive-total unknown types.</li> </ul> <p>The <code>total</code> field is <code>member + retail + plan_sale_washes</code>. Negative-total transactions (refunds) are excluded entirely.</p>"},{"location":"api/models/#sonnys_data_client.types.ConversionResult","title":"ConversionResult","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Membership conversion KPI returned by <code>client.stats.conversion_rate()</code>.</p> <p>Measures how effectively a site converts eligible wash customers into membership sign-ups.  The <code>rate</code> is computed as <code>new_memberships / eligible_washes</code>.</p> <p>A rate of <code>0.15</code> means 15 % of eligible washes resulted in a new membership sale.  When there are zero eligible washes the rate is <code>0.0</code> (division-by-zero safe).</p>"},{"location":"api/models/#sonnys_data_client.types.StatsReport","title":"StatsReport","text":"<p>               Bases: <code>SonnysModel</code></p> <p>Unified analytics report returned by <code>client.stats.report()</code>.</p> <p>Bundles all KPIs into a single result object, computed from a single v2 transaction fetch for efficiency.</p> <p>Attributes:</p> Name Type Description <code>sales</code> <code>SalesResult</code> <p>Revenue breakdown (recurring plan sales, recurring redemptions, and retail) as a :class:<code>SalesResult</code>.</p> <code>washes</code> <code>WashResult</code> <p>Wash volume breakdown (retail, member, and eligible washes) as a :class:<code>WashResult</code>.</p> <code>new_memberships</code> <code>int</code> <p>Count of recurring plan sales during the report period.</p> <code>conversion</code> <code>ConversionResult</code> <p>Membership conversion rate KPI as a :class:<code>ConversionResult</code>.</p> <code>period_start</code> <code>str</code> <p>ISO-8601 date string for the start of the report range (e.g. <code>\"2026-01-01\"</code>).</p> <code>period_end</code> <code>str</code> <p>ISO-8601 date string for the end of the report range (e.g. <code>\"2026-01-31\"</code>).</p>"},{"location":"api/resources/","title":"Resources","text":"<p>Resources are the primary interface for interacting with the Sonny's Data API. Each resource is accessed as a property on the <code>SonnysClient</code> and exposes methods like <code>list()</code>, <code>get()</code>, and resource-specific operations.</p> <pre><code>with SonnysClient(api_id, api_key) as client:\n    customers = client.customers.list()\n    customer  = client.customers.get(\"12345\")\n</code></pre>"},{"location":"api/resources/#base-classes","title":"Base Classes","text":""},{"location":"api/resources/#sonnys_data_client._resources.BaseResource","title":"BaseResource","text":"<pre><code>BaseResource(client: SonnysClient)\n</code></pre> <p>Base class for all API resources.</p> <p>Stores a reference to the parent :class:<code>SonnysClient</code> so that subclasses can issue HTTP requests via <code>self._client._request()</code>.</p>"},{"location":"api/resources/#sonnys_data_client._resources.ListableResource","title":"ListableResource","text":"<pre><code>ListableResource(client: SonnysClient)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> <p>Mixin for resources that support a paginated (or non-paginated) list endpoint.</p> <p>Subclasses must define the following class attributes:</p> <ul> <li><code>_path</code>: URL path for the list endpoint (e.g., <code>\"/customer\"</code>).</li> <li><code>_items_key</code>: Key inside <code>data</code> that holds the items array   (e.g., <code>\"customers\"</code>).</li> <li><code>_model</code>: Pydantic model class to validate each item against.</li> <li><code>_default_limit</code>: Page size for paginated requests (default <code>100</code>).</li> <li><code>_paginated</code>: Whether the endpoint supports offset/limit pagination   (default <code>True</code>).  Set to <code>False</code> for endpoints like <code>/site</code> that   return all records in a single response.</li> </ul>"},{"location":"api/resources/#sonnys_data_client._resources.ListableResource.list","title":"list","text":"<pre><code>list(**params: object) -&gt; list[SonnysModel]\n</code></pre> <p>Fetch all items from the list endpoint.</p> <p>For paginated endpoints, automatically pages through all results using offset-based pagination (offset starts at 1 per API spec).</p> <p>For non-paginated endpoints (<code>_paginated=False</code>), makes a single request and returns all items.</p> <p>Parameters:</p> Name Type Description Default <code>**params</code> <code>object</code> <p>Extra query parameters forwarded to every request (e.g., <code>first_name=\"John\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[SonnysModel]</code> <p>A list of validated Pydantic model instances.</p>"},{"location":"api/resources/#sonnys_data_client._resources.GettableResource","title":"GettableResource","text":"<pre><code>GettableResource(client: SonnysClient)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> <p>Mixin for resources that support a detail (get-by-ID) endpoint.</p> <p>Subclasses must define the following class attributes:</p> <ul> <li><code>_detail_path</code>: URL path template with <code>{id}</code> placeholder   (e.g., <code>\"/customer/{id}\"</code>).</li> <li><code>_detail_model</code>: Pydantic model class to validate the detail   response against.</li> </ul>"},{"location":"api/resources/#sonnys_data_client._resources.GettableResource.get","title":"get","text":"<pre><code>get(id: str) -&gt; SonnysModel\n</code></pre> <p>Fetch a single resource by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The resource identifier, substituted into <code>_detail_path</code>.</p> required <p>Returns:</p> Type Description <code>SonnysModel</code> <p>A validated Pydantic model instance.</p>"},{"location":"api/resources/#concrete-resources","title":"Concrete Resources","text":""},{"location":"api/resources/#sonnys_data_client.resources.Customers","title":"Customers","text":"<pre><code>Customers(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /customer list and detail endpoints.</p> <p>Provides paginated customer search and individual customer lookup.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.CustomerListItem</code>   summaries. Supports <code>startDate</code>, <code>endDate</code>, <code>site</code>, and <code>region</code>   filters.</li> <li><code>get(id)</code> returns a full :class:<code>~sonnys_data_client.types.Customer</code>   profile including address, contact info, and SMS preferences.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.Items","title":"Items","text":"<pre><code>Items(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /item list endpoint.</p> <p>Provides paginated item catalog listing. List-only resource with no detail endpoint.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.Item</code> records   with SKU, name, department, and pricing info. Supports <code>site</code>   filter.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.Employees","title":"Employees","text":"<pre><code>Employees(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /employee list and detail endpoints.</p> <p>Provides paginated employee search, individual employee lookup, and time-tracking data.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.EmployeeListItem</code>   summaries. Supports <code>startDate</code> and <code>endDate</code> filters.</li> <li><code>get(id)</code> returns a full :class:<code>~sonnys_data_client.types.Employee</code>   record with contact info and employment dates.</li> <li><code>get_clock_entries(id)</code> fetches   :class:<code>~sonnys_data_client.types.ClockEntry</code> time-tracking records   for a specific employee.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.Employees.get_clock_entries","title":"get_clock_entries","text":"<pre><code>get_clock_entries(\n    employee_id: int | str,\n    *,\n    start_date: str | None = None,\n    end_date: str | None = None,\n) -&gt; list[ClockEntry]\n</code></pre> <p>Fetch clock entries for an employee.</p> <p>The API returns a nested <code>data.weeks[]</code> structure where each week contains a <code>clockEntries[]</code> array.  This method flattens them into a single list.</p> <p>Parameters:</p> Name Type Description Default <code>employee_id</code> <code>int | str</code> <p>The employee identifier.</p> required <code>start_date</code> <code>str | None</code> <p>Optional start date filter (passed as <code>startDate</code>).</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>Optional end date filter (passed as <code>endDate</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ClockEntry]</code> <p>A flat list of validated :class:<code>ClockEntry</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Sites","title":"Sites","text":"<pre><code>Sites(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /site/list endpoint.</p> <p>Provides a complete site listing. Non-paginated resource that returns all sites in a single call. No detail endpoint.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.Site</code> records   with site ID, code, name, and timezone.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.Giftcards","title":"Giftcards","text":"<pre><code>Giftcards(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code></p> <p>Access the /giftcard-liablilty list endpoint.</p> <p>Provides paginated gift card liability listing. List-only resource with no detail endpoint.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.GiftcardListItem</code>   records with balance and usage info.</li> </ul> Note <p>The API path contains a typo (<code>giftcard-liablilty</code>) which is intentional to match the actual Sonny's API endpoint.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Washbooks","title":"Washbooks","text":"<pre><code>Washbooks(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /washbook/account list and detail endpoints.</p> <p>Provides paginated washbook account search and individual account lookup with full detail.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.WashbookListItem</code>   summaries. Supports date and site filters.</li> <li><code>get(id)</code> returns a full :class:<code>~sonnys_data_client.types.Washbook</code>   record with customer, vehicle, and tag details.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts","title":"RecurringAccounts","text":"<pre><code>RecurringAccounts(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /recurring/account list, detail, and custom endpoints.</p> <p>The most feature-rich resource, providing paginated account search, individual account lookup, and specialized reporting endpoints.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.RecurringListItem</code>   summaries with status and billing site info.</li> <li><code>get(id)</code> returns a full :class:<code>~sonnys_data_client.types.Recurring</code>   record with billing history, tags, vehicles, and customer details.</li> <li><code>list_status_changes()</code> fetches status transition history.</li> <li><code>list_modifications()</code> fetches account modification audit logs.</li> <li><code>list_details()</code> fetches all accounts with full detail in bulk.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_status_changes","title":"list_status_changes","text":"<pre><code>list_status_changes(\n    **params: object,\n) -&gt; list[RecurringStatusChange]\n</code></pre> <p>Fetch all recurring account status changes.</p> <p>Returns:</p> Type Description <code>list[RecurringStatusChange]</code> <p>A flat list of :class:<code>RecurringStatusChange</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_modifications","title":"list_modifications","text":"<pre><code>list_modifications(\n    **params: object,\n) -&gt; list[RecurringModification]\n</code></pre> <p>Fetch all recurring account modifications.</p> <p>Returns:</p> Type Description <code>list[RecurringModification]</code> <p>A flat list of :class:<code>RecurringModification</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.RecurringAccounts.list_details","title":"list_details","text":"<pre><code>list_details(**params: object) -&gt; list[Recurring]\n</code></pre> <p>Fetch all recurring accounts with full detail.</p> <p>Unlike :meth:<code>list</code> which returns summary :class:<code>RecurringListItem</code> objects, this method returns full :class:<code>Recurring</code> detail objects.</p> <p>Returns:</p> Type Description <code>list[Recurring]</code> <p>A flat list of :class:<code>Recurring</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions","title":"Transactions","text":"<pre><code>Transactions(client: SonnysClient)\n</code></pre> <p>               Bases: <code>ListableResource</code>, <code>GettableResource</code></p> <p>Access the /transaction list, detail, and by-type endpoints.</p> <p>The most complex resource, providing paginated transaction search, individual transaction lookup, type-filtered listing, and batch job support for large exports.</p> <ul> <li><code>list()</code> returns :class:<code>~sonnys_data_client.types.TransactionListItem</code>   summaries. Supports <code>startDate</code>, <code>endDate</code>, <code>site</code>, <code>region</code>   filters.</li> <li><code>get(id)</code> returns a full :class:<code>~sonnys_data_client.types.Transaction</code>   record with line items, tenders, and discounts.</li> <li><code>list_by_type(type)</code> filters transactions by type (wash, recurring, etc.).</li> <li><code>list_v2()</code> uses the enriched v2 endpoint with customer and status fields.</li> <li><code>load_job()</code> submits asynchronous batch jobs for large date ranges.</li> </ul>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.list","title":"list","text":"<pre><code>list(**params: object) -&gt; list[TransactionListItem]\n</code></pre> <p>Fetch all transactions, converting date strings to timestamps.</p> <p>Accepts <code>startDate</code> / <code>endDate</code> as ISO-8601 strings (e.g. <code>\"2026-01-15\"</code>) or Unix timestamps.</p> <p>Returns:</p> Type Description <code>list[TransactionListItem]</code> <p>A flat list of :class:<code>TransactionListItem</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.list_by_type","title":"list_by_type","text":"<pre><code>list_by_type(\n    item_type: str, **params: object\n) -&gt; list[TransactionListItem]\n</code></pre> <p>Fetch all transactions of a specific type.</p> <p>Valid types include: wash, prepaid-wash, recurring, washbook, giftcard, merchandise, house-account. The API validates the type parameter.</p> <p>Parameters:</p> Name Type Description Default <code>item_type</code> <code>str</code> <p>The transaction type to filter by.</p> required <code>**params</code> <code>object</code> <p>Extra query parameters forwarded to every request (e.g., <code>startDate</code>, <code>endDate</code>, <code>site</code>, <code>region</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[TransactionListItem]</code> <p>A flat list of :class:<code>TransactionListItem</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.list_v2","title":"list_v2","text":"<pre><code>list_v2(**params: object) -&gt; list[TransactionV2ListItem]\n</code></pre> <p>Fetch all transactions using the v2 endpoint.</p> <p>The v2 endpoint returns enriched list items with <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, and <code>transaction_status</code> fields.</p> <p>Note: The API caches v2 responses for 10 minutes per reporting criteria.</p> <p>Returns:</p> Type Description <code>list[TransactionV2ListItem]</code> <p>A flat list of :class:<code>TransactionV2ListItem</code> instances.</p>"},{"location":"api/resources/#sonnys_data_client.resources.Transactions.load_job","title":"load_job","text":"<pre><code>load_job(\n    *,\n    poll_interval: float = 2.0,\n    timeout: float = 300.0,\n    **params: object,\n) -&gt; list[TransactionJobItem]\n</code></pre> <p>Submit batch jobs and auto-paginate through all results.</p> <p>Pagination happens at the job submission level: each call to <code>/transaction/load-job</code> with a different <code>offset</code> fetches one page. The method submits as many jobs as needed to retrieve all records.</p> <p>Note: The API caches job data for 20 minutes and limits the date range to a maximum of 24 hours.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>Seconds between poll attempts (default 2.0).</p> <code>2.0</code> <code>timeout</code> <code>float</code> <p>Max seconds to wait for each job (default 300.0).</p> <code>300.0</code> <code>**params</code> <code>object</code> <p>Query parameters (<code>startDate</code>, <code>endDate</code>, <code>site</code>, <code>limit</code>, <code>offset</code>, etc.).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[TransactionJobItem]</code> <p>A list of :class:<code>TransactionJobItem</code> instances.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If any job status is <code>\"fail\"</code>.</p> <code>APITimeoutError</code> <p>If any job does not complete within timeout.</p>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource","title":"StatsResource","text":"<pre><code>StatsResource(client: SonnysClient)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> <p>Access computed business analytics and KPIs.</p> <p>Unlike other resources that wrap REST endpoints directly, <code>StatsResource</code> computes analytics by fetching raw data and aggregating it locally.  Individual stat methods (total sales, total washes, conversion rate, etc.) will be added in Phases 21-25.</p> <p>All stat methods accept a date range and delegate to :meth:<code>_resolve_dates</code> for consistent parsing and validation.</p>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.retail_wash_count","title":"retail_wash_count","text":"<pre><code>retail_wash_count(\n    start: str | datetime, end: str | datetime\n) -&gt; int\n</code></pre> <p>Count retail wash transactions for a date range.</p> <p>A retail wash is a <code>type=wash</code> transaction (v1) that is neither a recurring plan sale nor a recurring redemption (v2 flags).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of retail wash transactions in the date range.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>count = client.stats.retail_wash_count(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Retail washes: {count}\")\n</code></pre>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.new_memberships_sold","title":"new_memberships_sold","text":"<pre><code>new_memberships_sold(\n    start: str | datetime, end: str | datetime\n) -&gt; int\n</code></pre> <p>Count new membership sales for a date range.</p> <p>Fetches enriched v2 transactions and counts those flagged as <code>is_recurring_plan_sale</code>.  This captures both brand-new sign-ups and reactivations \u2014 any transaction where a recurring plan was sold. The returned count serves as the numerator for conversion rate calculations.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of recurring plan sales in the date range.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>count = client.stats.new_memberships_sold(\"2026-01-01\", \"2026-01-31\")\nprint(f\"New memberships sold: {count}\")\n</code></pre>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.total_sales","title":"total_sales","text":"<pre><code>total_sales(\n    start: str | datetime, end: str | datetime\n) -&gt; SalesResult\n</code></pre> <p>Compute revenue breakdown for a date range.</p> <p>Fetches all transactions via the enriched v2 endpoint and categorizes them into three buckets: recurring plan sales, recurring redemptions, and retail.  Returns a :class:<code>~sonnys_data_client.types.SalesResult</code> with grand totals and per-bucket revenue and count.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>SalesResult</code> <p>class:<code>~sonnys_data_client.types.SalesResult</code> containing</p> <code>SalesResult</code> <p>the grand total, transaction count, and per-category</p> <code>SalesResult</code> <p>breakdowns.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>result = client.stats.total_sales(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Total: ${result.total:.2f}\")\nprint(f\"Memberships: ${result.recurring_plan_sales:.2f}\")\n</code></pre>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.total_washes","title":"total_washes","text":"<pre><code>total_washes(\n    start: str | datetime, end: str | datetime\n) -&gt; WashResult\n</code></pre> <p>Compute wash volume breakdown for a date range.</p> <p>Fetches v2 transactions (for membership flags), v1 <code>type=wash</code> (to identify car washes), and v1 <code>type=recurring</code> (to identify recharges).  Classification priority: redemption &gt; plan sale &gt; wash &gt; recharge &gt; unknown.</p> <p><code>eligible_wash_count</code> is derived as <code>total - member_wash_count - free_wash_count</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>WashResult</code> <p>class:<code>~sonnys_data_client.types.WashResult</code> containing the</p> <code>WashResult</code> <p>total wash count and per-category breakdowns.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>result = client.stats.total_washes(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Total washes: {result.total}\")\nprint(f\"Retail: {result.retail_wash_count}\")\nprint(f\"Member: {result.member_wash_count}\")\nprint(f\"Eligible: {result.eligible_wash_count}\")\nprint(f\"Free: {result.free_wash_count}\")\n</code></pre>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.conversion_rate","title":"conversion_rate","text":"<pre><code>conversion_rate(\n    start: str | datetime, end: str | datetime\n) -&gt; ConversionResult\n</code></pre> <p>Compute the membership conversion rate for a date range.</p> <p>Measures how effectively a site converts eligible wash customers into membership sign-ups.  The rate is computed as <code>new_memberships / eligible_washes</code>.</p> <p>Eligible washes are derived from the total wash count: <code>total_washes - member_washes - free_washes</code>.  This includes retail washes with <code>total &gt; 0</code>, plan sale washes, and unknown non-negative transaction types.  When there are zero eligible washes the rate is <code>0.0</code> (division-by-zero safe).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>ConversionResult</code> <p>class:<code>~sonnys_data_client.types.ConversionResult</code> containing</p> <code>ConversionResult</code> <p>the conversion rate and component counts.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>result = client.stats.conversion_rate(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Conversion rate: {result.rate:.1%}\")\nprint(f\"Memberships: {result.new_memberships}\")\nprint(f\"Eligible washes: {result.eligible_washes}\")\n</code></pre>"},{"location":"api/resources/#sonnys_data_client.resources.StatsResource.report","title":"report","text":"<pre><code>report(\n    start: str | datetime, end: str | datetime\n) -&gt; StatsReport\n</code></pre> <p>Compute all KPIs for a date range in a single call.</p> <p>Fetches v2 transactions, v1 <code>type=wash</code>, and v1 <code>type=recurring</code> with 3 API calls and computes every KPI locally, compared to the 12 API calls that would result from calling :meth:<code>total_sales</code>, :meth:<code>total_washes</code>, :meth:<code>new_memberships_sold</code>, and :meth:<code>conversion_rate</code> individually.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | datetime</code> <p>Range start as an ISO-8601 string (e.g. <code>\"2026-01-01\"</code>) or :class:<code>~datetime.datetime</code>.</p> required <code>end</code> <code>str | datetime</code> <p>Range end as an ISO-8601 string or :class:<code>~datetime.datetime</code>.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>StatsReport</code> <p>class:<code>~sonnys_data_client.types.StatsReport</code> containing</p> <code>StatsReport</code> <p><code>sales</code>, <code>washes</code>, <code>new_memberships</code>, <code>conversion</code>,</p> <code>StatsReport</code> <p><code>period_start</code>, and <code>period_end</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start is after end, or if a string cannot be parsed as a valid ISO-8601 date/datetime.</p> <p>Example::</p> <pre><code>rpt = client.stats.report(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Revenue: ${rpt.sales.total:.2f}\")\nprint(f\"Washes: {rpt.washes.total}\")\nprint(f\"New members: {rpt.new_memberships}\")\nprint(f\"Conversion: {rpt.conversion.rate:.1%}\")\n</code></pre>"},{"location":"guides/advanced-patterns/","title":"Advanced Patterns","text":"<p>This guide covers SDK usage patterns that go beyond single-resource CRUD operations. If you are building production data pipelines, operating across multiple sites, or need to understand the rate limiter in depth, this is the right place.</p> <p>Who this is for:</p> <ul> <li>Developers building scheduled data pipelines that pull from multiple sites</li> <li>Operators managing separate databases (e.g., WashU and Icon) with different   API credentials</li> <li>Anyone who needs to export large volumes of data efficiently without hitting   rate limits</li> </ul> <p>Prerequisites: Familiarity with the basic client usage covered in the resource guides (e.g., Transactions) and the Error Handling guide.</p>"},{"location":"guides/advanced-patterns/#multi-site-operations","title":"Multi-Site Operations","text":"<p>The Sonny's API scopes data by site code. A single API ID may have access to multiple sites, and an organization may operate multiple databases with entirely separate credentials. This section covers patterns for working across sites and databases.</p>"},{"location":"guides/advanced-patterns/#single-site-vs-multi-site-setup","title":"Single-Site vs Multi-Site Setup","text":"<p>When you pass <code>site_code</code> to the constructor, every request is scoped to that site automatically via the <code>X-Sonnys-Site-Code</code> header:</p> <pre><code>from sonnys_data_client import SonnysClient\n\n# Scoped to a single site -- all requests return data for JOLIET only\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Joliet transactions: {len(transactions)}\")\n</code></pre> <p>Omitting <code>site_code</code> returns data for all sites the API ID has access to. This is useful when you want a consolidated view without looping:</p> <pre><code># No site_code -- returns transactions across all authorized sites\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n) as client:\n    all_transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"All-site transactions: {len(all_transactions)}\")\n</code></pre> <p>Tip</p> <p>Use <code>site_code</code> when you need per-site reporting or when the API ID has access to many sites and you want to reduce response size. Omit it when you need a quick cross-site total.</p>"},{"location":"guides/advanced-patterns/#iterating-multiple-sites","title":"Iterating Multiple Sites","text":"<p>When you need per-site breakdowns, create a separate client for each site code. This is the standard pattern for daily dashboards and scheduled reports:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\ndaily_counts = {}\n\nfor site in SITES:\n    with SonnysClient(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=site,\n    ) as client:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n        )\n        daily_counts[site] = len(transactions)\n\nfor site, count in daily_counts.items():\n    print(f\"{site}: {count} transactions\")\n</code></pre> <p>Warning</p> <p>Each client in this loop shares the same <code>api_id</code>, which means the API server enforces a single 20 req/15s rate limit across all of them. See Multi-Client Rate Limit Considerations for details and mitigation strategies.</p>"},{"location":"guides/advanced-patterns/#multi-database-operations","title":"Multi-Database Operations","text":"<p>Some organizations operate entirely separate databases with different API credentials. For example, WashU and Icon each have their own <code>api_id</code> and <code>api_key</code>. Create independent clients for each database:</p> <pre><code>from sonnys_data_client import SonnysClient\n\n# WashU database -- separate API credentials\nwashu_client = SonnysClient(\n    api_id=\"washu-api-id\",\n    api_key=\"washu-api-key\",\n)\n\n# Icon database -- separate API credentials\nicon_client = SonnysClient(\n    api_id=\"icon-api-id\",\n    api_key=\"icon-api-key\",\n)\n\ntry:\n    washu_txns = washu_client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    icon_txns = icon_client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    print(f\"WashU: {len(washu_txns)} transactions\")\n    print(f\"Icon:  {len(icon_txns)} transactions\")\n    print(f\"Combined: {len(washu_txns) + len(icon_txns)} transactions\")\nfinally:\n    washu_client.close()\n    icon_client.close()\n</code></pre> <p>Note</p> <p>Since these clients use different API IDs, each has its own independent rate limit (20 req/15s per API ID). They will not interfere with each other.</p>"},{"location":"guides/advanced-patterns/#consolidated-reporting","title":"Consolidated Reporting","text":"<p>A common need is aggregating data across sites into a single report. This pattern collects revenue per site for a date range and produces a summary:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\nrevenue_by_site = {}\n\nfor site in SITES:\n    with SonnysClient(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=site,\n    ) as client:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n        revenue_by_site[site] = sum(txn.total for txn in transactions)\n\n# Print consolidated report\ntotal_revenue = sum(revenue_by_site.values())\nprint(f\"{'Site':&lt;15} {'Revenue':&gt;12}\")\nprint(\"-\" * 28)\nfor site, revenue in revenue_by_site.items():\n    pct = (revenue / total_revenue * 100) if total_revenue else 0\n    print(f\"{site:&lt;15} ${revenue:&gt;10,.2f}  ({pct:.1f}%)\")\nprint(\"-\" * 28)\nprint(f\"{'TOTAL':&lt;15} ${total_revenue:&gt;10,.2f}\")\n</code></pre> <p>Sample output:</p> <pre><code>Site                 Revenue\n----------------------------\nJOLIET          $  45,230.50  (39.2%)\nPLNFLD          $  38,910.25  (33.7%)\nNILES           $  31,245.75  (27.1%)\n----------------------------\nTOTAL           $ 115,386.50\n</code></pre> <p>Tip</p> <p>For large multi-site reports, add a <code>time.sleep(1)</code> between site iterations to avoid rate limit pressure. See Request Spacing for Bulk Operations for a configurable pattern.</p>"},{"location":"guides/advanced-patterns/#context-managers-for-multi-site","title":"Context Managers for Multi-Site","text":"<p>When working with multiple clients simultaneously, use <code>contextlib.ExitStack</code> to manage their lifecycles cleanly. This ensures all clients are closed even if an error occurs partway through:</p> <pre><code>import contextlib\nfrom sonnys_data_client import SonnysClient\n\nDATABASES = {\n    \"WashU\": {\"api_id\": \"washu-api-id\", \"api_key\": \"washu-api-key\"},\n    \"Icon\":  {\"api_id\": \"icon-api-id\",  \"api_key\": \"icon-api-key\"},\n}\n\nwith contextlib.ExitStack() as stack:\n    clients = {}\n    for name, creds in DATABASES.items():\n        client = SonnysClient(api_id=creds[\"api_id\"], api_key=creds[\"api_key\"])\n        stack.enter_context(client)\n        clients[name] = client\n\n    # All clients are open -- use them freely\n    for name, client in clients.items():\n        sites = client.sites.list()\n        print(f\"{name}: {len(sites)} sites\")\n\n    # All clients are automatically closed when the block exits\n</code></pre> <p>For the common case of iterating sites within a single database, you can combine <code>ExitStack</code> with site-scoped clients:</p> <pre><code>import contextlib\nfrom sonnys_data_client import SonnysClient\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\nwith contextlib.ExitStack() as stack:\n    clients = {}\n    for site in SITES:\n        client = SonnysClient(\n            api_id=\"your-api-id\",\n            api_key=\"your-api-key\",\n            site_code=site,\n        )\n        stack.enter_context(client)\n        clients[site] = client\n\n    # Fetch data from all sites with all clients open\n    for site, client in clients.items():\n        txns = client.transactions.list(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n        )\n        print(f\"{site}: {len(txns)} transactions\")\n</code></pre> <p>Warning</p> <p>Opening multiple clients to the same API ID simultaneously means they all share the server-side rate limit but each has its own local rate limiter. The local limiters do not coordinate. If you fire requests from all clients at once, you will likely hit server-side 429s. Use sequential access or add delays between clients.</p>"},{"location":"guides/advanced-patterns/#rate-limiting-deep-dive","title":"Rate Limiting Deep Dive","text":"<p>The SDK includes a built-in rate limiter that prevents most 429 errors before they happen. This section explains how the limiter works internally, what happens with multiple clients, and how to forecast your request budget for bulk operations.</p> <p>For exception handling when rate limits are exceeded, see the Error Handling guide.</p>"},{"location":"guides/advanced-patterns/#how-the-rate-limiter-works","title":"How the Rate Limiter Works","text":"<p>Each <code>SonnysClient</code> instance creates its own <code>RateLimiter</code> with a sliding window algorithm:</p> <ul> <li>Window: 15 seconds (rolling, not fixed intervals)</li> <li>Capacity: 20 requests per window</li> <li>Behavior: The limiter tracks the timestamp of each request in a deque.   Before every request, it purges timestamps older than 15 seconds. If fewer   than 20 timestamps remain, the request proceeds immediately. If at capacity,   the client sleeps until the oldest timestamp expires from the window.</li> </ul> <pre><code>Timeline (seconds):\n0s    5s    10s   15s   20s   25s   30s\n|-----|-----|-----|-----|-----|-----|\n[  20 requests fired  ]\n                       ^ window expires for req #1\n                       ^ req #21 can now proceed\n</code></pre> <p>The key insight is that requests never fail due to the client-side rate limiter. Instead, the client automatically waits until a slot opens. You can observe this behavior by enabling debug logging:</p> <pre><code>import logging\nfrom sonnys_data_client import SonnysClient\n\nlogging.getLogger(\"sonnys_data_client\").setLevel(logging.DEBUG)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # After 20 rapid requests, the 21st will pause automatically\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    # Debug log: \"Rate limiter: waiting 2.350s\"\n</code></pre> <p>Note</p> <p>The rate limiter is per-client-instance. Two separate <code>SonnysClient</code> objects each maintain independent rate limiters, even if they share the same <code>api_id</code>.</p>"},{"location":"guides/advanced-patterns/#multi-client-rate-limit-considerations","title":"Multi-Client Rate Limit Considerations","text":"<p>This is the most common source of unexpected 429 errors. Understanding it will save you hours of debugging.</p> <p>The problem: Each <code>SonnysClient</code> has its own local rate limiter allowing 20 req/15s. But the Sonny's API server enforces a single 20 req/15s limit per API ID, regardless of how many clients use that ID. If two clients share the same <code>api_id</code>, each thinks it can send 20 requests, but the server only allows 20 total.</p> <pre><code>Client A (api_id=\"ABC\"):  local limiter = 20 req/15s  \u2500\u2510\n                                                         \u251c\u2500&gt; Server: 20 req/15s for \"ABC\"\nClient B (api_id=\"ABC\"):  local limiter = 20 req/15s  \u2500\u2518\n\nCombined effective limit: 20 req/15s total, NOT 40\n</code></pre> <p>Shared API ID = shared rate limit</p> <p>If you run N clients against the same <code>api_id</code>, expect effective per-client throughput of approximately 20/N requests per 15 seconds. With 4 site-scoped clients sharing one API ID, each client effectively gets ~5 req/15s before the server starts returning 429s.</p> <p>The SDK handles server-side 429s with exponential backoff retries (up to <code>max_retries</code> attempts), so your script will not crash immediately. But each retry adds latency. It is faster to proactively space your requests than to rely on retry-after-429 recovery.</p> <p>Mitigation strategies:</p> <ol> <li> <p>Sequential site iteration -- Process one site at a time rather than    opening all clients simultaneously (see    Iterating Multiple Sites).</p> </li> <li> <p>Add delays between sites -- Insert <code>time.sleep(2)</code> between site    iterations to let the rate limit window recover.</p> </li> <li> <p>Increase <code>max_retries</code> -- If you must run multiple clients concurrently,    increase <code>max_retries</code> to give the backoff more room:</p> <pre><code>client = SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n    max_retries=5,  # More room for 429 recovery\n)\n</code></pre> </li> <li> <p>Use separate API IDs -- If available, request separate API credentials    for separate processes. Each API ID gets its own 20 req/15s budget.</p> </li> </ol>"},{"location":"guides/advanced-patterns/#request-budget-forecasting","title":"Request Budget Forecasting","text":"<p>Before running a bulk export, estimate how many requests it will consume and how long it will take. This helps you plan scheduling windows and avoid surprises.</p> <p>Formula: The API returns up to 100 records per page. For a paginated endpoint:</p> <pre><code>pages = ceil(total_records / 100)\n</code></pre> <p>At 20 requests per 15 seconds, the minimum time to complete is:</p> <pre><code>time_seconds = (pages / 20) * 15\n</code></pre> <p>Reference table:</p> Records Pages Min Time Notes 100 1 &lt; 1s Single request 500 5 ~4s Fits in one rate limit window 1,000 10 ~8s Fits in one rate limit window 2,000 20 ~15s Fills exactly one window 5,000 50 ~38s ~2.5 windows 10,000 100 ~75s 5 windows 25,000 250 ~188s (~3 min) 12.5 windows 50,000 500 ~375s (~6 min) 25 windows <p>Note</p> <p>These estimates assume a single client with exclusive use of the API ID. If other processes share the same API ID, actual times will be longer due to contention.</p> <p>Example: estimating a monthly export</p> <pre><code>import math\n\n# Estimate for a site that processes ~800 transactions per day\ndays_in_month = 30\ndaily_transactions = 800\ntotal_records = days_in_month * daily_transactions  # 24,000\n\npages = math.ceil(total_records / 100)  # 240 pages\nmin_seconds = (pages / 20) * 15  # 180 seconds = 3 minutes\n\nprint(f\"Estimated: {total_records:,} records, {pages} pages, ~{min_seconds:.0f}s\")\n</code></pre> <p>Tip</p> <p>For <code>load_job()</code>, each page submits a separate batch job that must be polled. The total time includes polling delays (default 2s per poll). A 240-page <code>load_job()</code> export will take significantly longer than a 240-page <code>list()</code> call. Use <code>list()</code> when you only need summary fields.</p>"},{"location":"guides/advanced-patterns/#staying-within-limits","title":"Staying Within Limits","text":"<p>Practical tips to keep your scripts running smoothly without hitting rate limits:</p> <p>1. Add sleep between site iterations</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\nfor site in SITES:\n    with SonnysClient(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=site,\n    ) as client:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n        )\n        print(f\"{site}: {len(transactions)} transactions\")\n\n    time.sleep(2)  # Let the rate limit window recover between sites\n</code></pre> <p>2. Use <code>load_job()</code> for bulk exports instead of paginated <code>list()</code></p> <p>A <code>load_job()</code> call for 10,000 records uses fewer API requests than paginating through <code>list()</code>, because the batch job server does the heavy lifting. The tradeoff is wall-clock time (polling delay), but the request budget impact is lower.</p> <p>3. Keep date ranges narrow</p> <p>Fewer records per query means fewer pages, which means fewer requests. Day-by-day iteration is the safest approach for large exports:</p> <pre><code>from datetime import date, timedelta\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    start = date(2025, 6, 1)\n    end = date(2025, 6, 30)\n    current = start\n\n    while current &lt; end:\n        next_day = current + timedelta(days=1)\n        transactions = client.transactions.list(\n            startDate=current.isoformat(),\n            endDate=next_day.isoformat(),\n        )\n        print(f\"{current}: {len(transactions)} transactions\")\n        current = next_day\n</code></pre> <p>4. Stagger scheduled jobs</p> <p>If you have multiple cron jobs or scheduled tasks using the same API ID, offset their start times by at least 60 seconds. Two jobs starting simultaneously will compete for the same 20 req/15s budget.</p> <p>Tip</p> <p>The Error Handling guide covers what happens when rate limits are exceeded despite these precautions -- the SDK retries 429s with exponential backoff before raising <code>RateLimitError</code>.</p>"},{"location":"guides/advanced-patterns/#performance-optimization","title":"Performance Optimization","text":"<p>Getting data out of the API efficiently means choosing the right method, sizing your date ranges, and spacing your requests. This section provides practical guidance for minimizing wall-clock time and request budget usage in production pipelines.</p>"},{"location":"guides/advanced-patterns/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The Transactions resource offers five methods, each with different performance characteristics. The Transactions guide has a full comparison table. Here is the decision from a performance perspective:</p> Priority Method Speed Request Cost Best For 1 <code>list()</code> Fastest 1 req per 100 records Daily counts, revenue totals, date range summaries 2 <code>list_by_type()</code> Fast 1 req per 100 records Type-filtered queries (fewer records = fewer pages) 3 <code>list_v2()</code> Fast 1 req per 100 records When you need <code>customer_id</code> or recurring flags 4 <code>get()</code> Per-record 1 req per record Single transaction detail lookup 5 <code>load_job()</code> Slowest Submit + poll + paginate Bulk full-detail exports <p>Default to <code>list()</code> unless you need specific fields</p> <p><code>list()</code> has no server-side caching layer and returns results immediately. It is the fastest method for most reporting use cases. Only switch to <code>list_v2()</code> when you specifically need <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, or <code>transaction_status</code>. Only use <code>load_job()</code> when you need full transaction detail (tenders, line items, discounts) on every record.</p> <p>Avoid <code>get()</code> in loops. Fetching 500 transactions one at a time with <code>get()</code> costs 500 requests. The same data from <code>load_job()</code> costs roughly 5 job submissions + polling. If you need full detail on many transactions, always prefer <code>load_job()</code>:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    # BAD: 500 requests for 500 transactions\n    # for tid in transaction_ids:\n    #     detail = client.transactions.get(tid)\n\n    # GOOD: ~5 requests for 500 transactions with full detail\n    results = client.transactions.load_job(\n        startDate=\"2025-06-15\",\n        endDate=\"2025-06-16\",\n        site=\"JOLIET\",\n    )\n</code></pre>"},{"location":"guides/advanced-patterns/#date-range-sizing","title":"Date Range Sizing","text":"<p>Narrower date ranges mean fewer records per query, which means fewer pages and fewer requests. The tradeoff is more iterations if you need a wide range.</p> <p>Guidelines by method:</p> Method Recommended Range Reason <code>list()</code> Up to 30 days Fast pagination, no caching complications <code>list_v2()</code> Up to 30 days 10-min cache; repeated calls within cache window return stale data <code>load_job()</code> Exactly 1 day Required -- max 24-hour range per call <p>For <code>load_job()</code> exports spanning multiple days, iterate day by day. The Transactions guide shows this pattern in detail. Here is the performance-optimized version with request spacing:</p> <pre><code>import time\nfrom datetime import date, timedelta\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    start = date(2025, 6, 1)\n    end = date(2025, 6, 30)\n    all_results = []\n    current = start\n\n    while current &lt; end:\n        next_day = current + timedelta(days=1)\n        day_results = client.transactions.load_job(\n            startDate=current.isoformat(),\n            endDate=next_day.isoformat(),\n            site=\"JOLIET\",\n        )\n        all_results.extend(day_results)\n        print(f\"{current}: {len(day_results)} transactions\")\n        current = next_day\n\n        # Pause between days to stay well within rate limits\n        time.sleep(1)\n\n    print(f\"Total: {len(all_results)} transactions over {(end - start).days} days\")\n</code></pre> <p>Note</p> <p>For <code>list()</code> and <code>list_v2()</code>, wider date ranges are fine if you only need summary data. A 30-day <code>list()</code> query on a site with 800 transactions/day returns ~24,000 records across ~240 pages -- about 3 minutes of wall time with a single client.</p>"},{"location":"guides/advanced-patterns/#request-spacing-for-bulk-operations","title":"Request Spacing for Bulk Operations","text":"<p>Even though the SDK handles 429 retries automatically, each retry adds latency. A request that gets a 429, waits 1 second, retries, and succeeds takes ~1.7 seconds instead of ~0.7 seconds. Proactive spacing is faster overall than reactive retry.</p> <p>Here is a configurable pattern for bulk operations with built-in spacing:</p> <pre><code>import time\nfrom datetime import date, timedelta\nfrom sonnys_data_client import SonnysClient\n\ndef export_site_transactions(\n    api_id: str,\n    api_key: str,\n    site_code: str,\n    start: date,\n    end: date,\n    delay_between_days: float = 1.0,\n) -&gt; list:\n    \"\"\"Export transactions for a site with configurable request spacing.\"\"\"\n    all_results = []\n\n    with SonnysClient(\n        api_id=api_id,\n        api_key=api_key,\n        site_code=site_code,\n    ) as client:\n        current = start\n        while current &lt; end:\n            next_day = current + timedelta(days=1)\n            day_results = client.transactions.load_job(\n                startDate=current.isoformat(),\n                endDate=next_day.isoformat(),\n                site=site_code,\n            )\n            all_results.extend(day_results)\n            current = next_day\n\n            if current &lt; end:\n                time.sleep(delay_between_days)\n\n    return all_results\n\n\n# Usage: export June for Joliet with 2-second spacing\nresults = export_site_transactions(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n    start=date(2025, 6, 1),\n    end=date(2025, 6, 30),\n    delay_between_days=2.0,\n)\nprint(f\"Exported {len(results)} transactions\")\n</code></pre> <p>For multi-site exports, add an additional delay between sites:</p> <pre><code>import time\nfrom datetime import date\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\nfor i, site in enumerate(SITES):\n    results = export_site_transactions(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=site,\n        start=date(2025, 6, 1),\n        end=date(2025, 6, 30),\n        delay_between_days=1.0,\n    )\n    print(f\"{site}: {len(results)} transactions\")\n\n    # Pause between sites (skip after the last one)\n    if i &lt; len(SITES) - 1:\n        time.sleep(5)\n</code></pre> <p>Warning</p> <p>Do not set <code>delay_between_days</code> to 0 for large exports. While the SDK will handle the resulting 429s gracefully, the exponential backoff delays (1s, 2s, 4s per retry) will make the total run time longer than a small proactive delay would.</p>"},{"location":"guides/advanced-patterns/#batch-jobs-vs-paginated-lists","title":"Batch Jobs vs Paginated Lists","text":"<p>The choice between <code>load_job()</code> and <code>list()</code> is the most impactful performance decision. Here is when to use each:</p> <p>Use <code>list()</code> when:</p> <ul> <li>You need summary fields only (transaction number, total, date)</li> <li>You are building dashboards or real-time reports</li> <li>Speed matters more than data completeness</li> <li>You are querying across wide date ranges (up to 30 days)</li> </ul> <p>Use <code>load_job()</code> when:</p> <ul> <li>You need full transaction detail (tenders, line items, discounts) on every   record</li> <li>You need v2 enrichment fields (<code>customer_id</code>, <code>transaction_status</code>) combined   with full detail</li> <li>You are building a data warehouse or archival export</li> <li>You can tolerate longer run times (polling overhead)</li> </ul> <p>Performance comparison for 1,000 transactions:</p> Aspect <code>list()</code> <code>load_job()</code> Requests 10 (paginated) ~10 job submissions + ~10 poll cycles Wall time ~8 seconds ~30-60 seconds (includes polling) Data depth Summary only Full detail + v2 fields Caching None 20-min server cache <p>Leveraging the <code>load_job()</code> cache</p> <p>Job results are cached by the API for 20 minutes. If you call <code>load_job()</code> with the same parameters within that window, the API returns cached results without re-processing the job. This means repeated calls are fast -- useful for retry-after-failure scenarios. See the Transactions guide for details on the job lifecycle.</p> <p>Hybrid approach: Use <code>list()</code> to get transaction counts and summaries, then use <code>load_job()</code> only for the specific date ranges where you need full detail:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Step 1: Quick summary scan with list()\n    summary = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(summary)} transactions in June\")\n\n    # Step 2: Full detail export only for high-value days\n    high_value_txns = [t for t in summary if t.total &gt; 500]\n    print(f\"{len(high_value_txns)} high-value transactions to inspect\")\n\n    # Step 3: Get full detail for specific transactions\n    for txn in high_value_txns[:10]:  # Limit to first 10\n        detail = client.transactions.get(txn.trans_id)\n        print(\n            f\"#{detail.number}: ${detail.total:.2f} - \"\n            f\"{len(detail.items)} items, {len(detail.tenders)} tenders\"\n        )\n</code></pre>"},{"location":"guides/advanced-patterns/#integration-recipes","title":"Integration Recipes","text":"<p>Ready-to-use patterns for the most common SDK integration scenarios. Each recipe is a complete, copy-pasteable script that uses only the standard library and the SDK itself -- no extra dependencies required. Change the credentials and run.</p>"},{"location":"guides/advanced-patterns/#export-to-csv","title":"Export to CSV","text":"<p>Export transaction data for a date range to a CSV file. Uses <code>model_dump()</code> to convert each Pydantic model to a dictionary, then writes rows with the standard <code>csv</code> module.</p> <pre><code>import csv\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\nif transactions:\n    fieldnames = list(transactions[0].model_dump().keys())\n    with open(\"joliet_transactions.csv\", \"w\", newline=\"\") as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        for txn in transactions:\n            writer.writerow(txn.model_dump())\n\n    print(f\"Exported {len(transactions)} transactions to joliet_transactions.csv\")\n</code></pre> <p>Tip</p> <p>Use <code>list_v2()</code> instead of <code>list()</code> when you need enriched CSV exports with <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, and <code>transaction_status</code> columns. Use <code>list()</code> for lightweight exports with just <code>trans_number</code>, <code>trans_id</code>, <code>total</code>, and <code>date</code>.</p>"},{"location":"guides/advanced-patterns/#export-to-json","title":"Export to JSON","text":"<p>Export transaction data to a JSON file. Use <code>model_dump(mode=\"json\")</code> to get a JSON-serializable dictionary (handles dates, decimals, etc.).</p> <pre><code>import json\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\ndata = [txn.model_dump(mode=\"json\") for txn in transactions]\n\nwith open(\"joliet_transactions.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\nprint(f\"Exported {len(data)} transactions to joliet_transactions.json\")\n</code></pre> <p>Note</p> <p>Use <code>model_dump(mode=\"json\", by_alias=True)</code> if the downstream consumer expects camelCase field names matching the raw API format (e.g., <code>transNumber</code> instead of <code>trans_number</code>).</p>"},{"location":"guides/advanced-patterns/#scheduled-daily-export","title":"Scheduled Daily Export","text":"<p>A script designed to run once per day that exports yesterday's transactions to a date-stamped CSV file. Ideal for cron jobs or Windows Task Scheduler.</p> <pre><code>\"\"\"daily_export.py -- Export yesterday's transactions to a date-stamped CSV.\"\"\"\nimport csv\nimport logging\nfrom datetime import date, timedelta\nfrom pathlib import Path\n\nfrom sonnys_data_client import SonnysClient\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(message)s\")\nlogger = logging.getLogger(__name__)\n\nyesterday = date.today() - timedelta(days=1)\ntoday = date.today()\noutput_dir = Path(\"exports\")\noutput_dir.mkdir(exist_ok=True)\noutput_file = output_dir / f\"transactions_{yesterday.isoformat()}.csv\"\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    transactions = client.transactions.list(\n        startDate=yesterday.isoformat(),\n        endDate=today.isoformat(),\n    )\n\nif transactions:\n    fieldnames = list(transactions[0].model_dump().keys())\n    with open(output_file, \"w\", newline=\"\") as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        for txn in transactions:\n            writer.writerow(txn.model_dump())\n\nlogger.info(\"Exported %d transactions to %s\", len(transactions), output_file)\n</code></pre> <p>Scheduling this script</p> <p>Linux/Mac (cron): Run daily at 6:00 AM:</p> <pre><code>0 6 * * * python /path/to/daily_export.py\n</code></pre> <p>Windows (Task Scheduler): Create a Basic Task triggered daily at 6:00 AM, with the action \"Start a program\" pointing to your Python executable and the script path as the argument.</p>"},{"location":"guides/advanced-patterns/#multi-site-daily-report","title":"Multi-Site Daily Report","text":"<p>Combine the multi-site iteration pattern with CSV export to produce either per-site CSV files or a single consolidated CSV with a <code>site_code</code> column. This example builds a consolidated file.</p> <pre><code>\"\"\"multi_site_report.py -- Consolidated daily report across all sites.\"\"\"\nimport csv\nimport time\nfrom datetime import date, timedelta\nfrom pathlib import Path\n\nfrom sonnys_data_client import SonnysClient\n\nSITES = [\"JOLIET\", \"PLNFLD\", \"NILES\"]\n\nyesterday = date.today() - timedelta(days=1)\ntoday = date.today()\noutput_file = Path(f\"daily_report_{yesterday.isoformat()}.csv\")\n\nall_rows = []\n\nfor site in SITES:\n    with SonnysClient(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=site,\n    ) as client:\n        transactions = client.transactions.list(\n            startDate=yesterday.isoformat(),\n            endDate=today.isoformat(),\n        )\n        for txn in transactions:\n            row = txn.model_dump()\n            row[\"site_code\"] = site\n            all_rows.append(row)\n    time.sleep(2)  # Respect shared rate limit between sites\n\nif all_rows:\n    fieldnames = list(all_rows[0].keys())\n    with open(output_file, \"w\", newline=\"\") as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerows(all_rows)\n\nprint(f\"Exported {len(all_rows)} transactions across {len(SITES)} sites\")\nprint(f\"Output: {output_file}\")\n</code></pre> <p>Tip</p> <p>For per-site CSV files instead of a consolidated file, move the file writing inside the site loop and use <code>Path(f\"{site}_{yesterday.isoformat()}.csv\")</code> as the output path. See Iterating Multiple Sites for the base pattern.</p>"},{"location":"guides/advanced-patterns/#data-pipeline-pattern","title":"Data Pipeline Pattern","text":"<p>A structured fetch-validate-transform-load pipeline. This example pulls recurring account data, filters to active accounts, calculates key metrics (active count, monthly recurring revenue), and writes a summary to JSON.</p> <pre><code>\"\"\"recurring_pipeline.py -- Recurring account data pipeline.\"\"\"\nimport json\nimport logging\nfrom datetime import date\nfrom pathlib import Path\n\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIError\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\nlogger = logging.getLogger(__name__)\n\n# --- Fetch ---\ntry:\n    with SonnysClient(\n        api_id=\"your-api-id\",\n        api_key=\"your-api-key\",\n        site_code=\"JOLIET\",\n    ) as client:\n        accounts = client.recurring.list_details()\nexcept APIError as e:\n    logger.error(\"Failed to fetch recurring accounts: %s\", e)\n    raise SystemExit(1)\n\nlogger.info(\"Fetched %d recurring accounts\", len(accounts))\n\n# --- Validate &amp; Transform ---\nactive = [a for a in accounts if a.current_recurring_status_name == \"Active\"]\nmrr = sum(a.billing_amount for a in active if a.billing_amount is not None)\n\nsummary = {\n    \"date\": date.today().isoformat(),\n    \"total_accounts\": len(accounts),\n    \"active_accounts\": len(active),\n    \"monthly_recurring_revenue\": round(mrr, 2),\n    \"average_billing\": round(mrr / len(active), 2) if active else 0,\n}\n\n# --- Load ---\noutput_file = Path(f\"recurring_summary_{date.today().isoformat()}.json\")\nwith open(output_file, \"w\") as f:\n    json.dump(summary, f, indent=2)\n\nlogger.info(\"Pipeline complete: %d active accounts, MRR=$%.2f\", len(active), mrr)\nlogger.info(\"Output: %s\", output_file)\n</code></pre> <p>Tip</p> <p>For production pipelines, reference the Error Handling guide for more granular exception handling. You can wrap each pipeline stage in its own try/except to handle partial failures gracefully.</p>"},{"location":"guides/advanced-patterns/#monitoring-alerting-recipe","title":"Monitoring &amp; Alerting Recipe","text":"<p>A simple script that checks a KPI (today's transaction count) against a threshold and logs a warning when the value is below expected volume. Run this on a schedule to catch low-volume days early.</p> <pre><code>\"\"\"monitor_volume.py -- Check daily transaction volume against threshold.\"\"\"\nimport logging\nfrom datetime import date, timedelta\n\nfrom sonnys_data_client import SonnysClient\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\nlogger = logging.getLogger(__name__)\n\nSITE = \"JOLIET\"\nMIN_EXPECTED_TRANSACTIONS = 200  # Typical daily volume for this site\n\ntoday = date.today()\nyesterday = today - timedelta(days=1)\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=SITE,\n) as client:\n    transactions = client.transactions.list(\n        startDate=yesterday.isoformat(),\n        endDate=today.isoformat(),\n    )\n\ncount = len(transactions)\nrevenue = sum(txn.total for txn in transactions)\n\nlogger.info(\"%s: %d transactions, $%.2f revenue\", SITE, count, revenue)\n\nif count &lt; MIN_EXPECTED_TRANSACTIONS:\n    logger.warning(\n        \"LOW VOLUME ALERT: %s had %d transactions (expected &gt;= %d)\",\n        SITE, count, MIN_EXPECTED_TRANSACTIONS,\n    )\nelse:\n    logger.info(\"%s volume is normal (%d &gt;= %d)\", SITE, count, MIN_EXPECTED_TRANSACTIONS)\n</code></pre> <p>Extending with real alerts</p> <p>This recipe logs warnings to stdout. In production, extend it with:</p> <ul> <li>Email alerts: Use <code>smtplib</code> from the standard library to send an   email when the threshold is breached.</li> <li>Slack webhooks: Use <code>urllib.request</code> to POST a JSON payload to a   Slack incoming webhook URL.</li> <li>Integration with the logging config from the   Error Handling guide to route   warnings to a file or external logging service.</li> </ul>"},{"location":"guides/customers/","title":"Customers","text":"<p>The Customers resource provides access to car wash customer records. Each customer includes contact information, loyalty data, and an optional mailing address. Use this resource to retrieve customer lists or fetch full details for a single customer by ID.</p>"},{"location":"guides/customers/#methods","title":"Methods","text":""},{"location":"guides/customers/#listparams-listcustomerlistitem","title":"<code>list(**params) -&gt; list[CustomerListItem]</code>","text":"<p>Fetch all customers. Returns a list of <code>CustomerListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>customers = client.customers.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>customers = client.customers.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/customers/#getcustomer_id-customer","title":"<code>get(customer_id) -&gt; Customer</code>","text":"<p>Fetch full details for a single customer by their ID. Returns a <code>Customer</code> object with all fields including address, email, loyalty number, and SMS preferences.</p> <pre><code>customer = client.customers.get(\"12345\")\n</code></pre>"},{"location":"guides/customers/#examples","title":"Examples","text":""},{"location":"guides/customers/#list-all-customers","title":"List all customers","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customers = client.customers.list()\n\n    for c in customers:\n        print(f\"{c.first_name} {c.last_name} (ID: {c.customer_id})\")\n</code></pre>"},{"location":"guides/customers/#filter-customers-by-date-range","title":"Filter customers by date range","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    recent = client.customers.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(recent)} customers modified in June 2025\")\n</code></pre>"},{"location":"guides/customers/#get-customer-detail-by-id","title":"Get customer detail by ID","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customer = client.customers.get(\"12345\")\n\n    print(f\"Name:    {customer.first_name} {customer.last_name}\")\n    print(f\"Email:   {customer.email}\")\n    print(f\"Phone:   {customer.phone}\")\n    print(f\"Loyalty: {customer.loyalty_number}\")\n    print(f\"Active:  {customer.is_active}\")\n</code></pre>"},{"location":"guides/customers/#access-nested-address-fields","title":"Access nested address fields","text":"<p>The <code>Customer</code> detail model includes an <code>Address</code> object with full mailing address fields:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customer = client.customers.get(\"12345\")\n\n    addr = customer.address\n    print(f\"{addr.address1}\")\n    print(f\"{addr.city}, {addr.state} {addr.postal_code}\")\n</code></pre>"},{"location":"guides/customers/#models","title":"Models","text":""},{"location":"guides/customers/#customerlistitem","title":"<code>CustomerListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each customer.</p> Field Type Description <code>customer_id</code> <code>str</code> Unique customer identifier <code>first_name</code> <code>str</code> Customer first name <code>last_name</code> <code>str</code> Customer last name <code>phone_number</code> <code>str \\| None</code> Phone number <code>customer_number</code> <code>str \\| None</code> Customer account number <code>is_active</code> <code>bool</code> Whether the customer is active <code>created_date</code> <code>str</code> Date the record was created <code>modified_date</code> <code>str \\| None</code> Date the record was last modified"},{"location":"guides/customers/#customer","title":"<code>Customer</code>","text":"<p>Returned by <code>get()</code>. Contains full customer details including address.</p> Field Type Description <code>id</code> <code>str</code> Unique customer identifier <code>number</code> <code>str</code> Customer account number <code>first_name</code> <code>str</code> Customer first name <code>last_name</code> <code>str</code> Customer last name <code>company_name</code> <code>str \\| None</code> Company name <code>loyalty_number</code> <code>str \\| None</code> Loyalty program number <code>address</code> <code>Address</code> Nested address object (see below) <code>phone</code> <code>str</code> Phone number <code>email</code> <code>str \\| None</code> Email address <code>birth_date</code> <code>str \\| None</code> Date of birth <code>is_active</code> <code>bool</code> Whether the customer is active <code>allow_sms</code> <code>bool</code> SMS opt-in status <code>recurring_sms_signup_date</code> <code>str \\| None</code> Date of recurring SMS signup <code>loyalty_sms_signup_date</code> <code>str \\| None</code> Date of loyalty SMS signup <code>modify_date</code> <code>str</code> Date the record was last modified"},{"location":"guides/customers/#address","title":"<code>Address</code>","text":"<p>Nested inside the <code>Customer</code> model.</p> Field Type Description <code>address1</code> <code>str \\| None</code> Street address <code>address2</code> <code>str \\| None</code> Suite / unit <code>city</code> <code>str \\| None</code> City <code>state</code> <code>str \\| None</code> State <code>country</code> <code>str \\| None</code> Country <code>postal_code</code> <code>str \\| None</code> ZIP / postal code <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/employees/","title":"Employees","text":"<p>The Employees resource provides access to employee records and their clock entry history. Beyond the standard <code>list()</code> and <code>get()</code> methods, this resource includes a dedicated <code>get_clock_entries()</code> method for retrieving time-tracking data with date range filtering.</p>"},{"location":"guides/employees/#methods","title":"Methods","text":""},{"location":"guides/employees/#listparams-listemployeelistitem","title":"<code>list(**params) -&gt; list[EmployeeListItem]</code>","text":"<p>Fetch all employees. Returns a list of <code>EmployeeListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>employees = client.employees.list()\n</code></pre>"},{"location":"guides/employees/#getemployee_id-employee","title":"<code>get(employee_id) -&gt; Employee</code>","text":"<p>Fetch full details for a single employee by their ID. Returns an <code>Employee</code> object with all fields including active status, start date, phone, and email.</p> <pre><code>employee = client.employees.get(\"42\")\n</code></pre>"},{"location":"guides/employees/#get_clock_entriesemployee_id-start_datenone-end_datenone-listclockentry","title":"<code>get_clock_entries(employee_id, *, start_date=None, end_date=None) -&gt; list[ClockEntry]</code>","text":"<p>Fetch clock entries for a specific employee. Returns a flat list of <code>ClockEntry</code> objects. Optionally filter by date range using <code>start_date</code> and <code>end_date</code>.</p> <pre><code>entries = client.employees.get_clock_entries(\n    \"42\",\n    start_date=\"2025-01-01\",\n    end_date=\"2025-01-31\",\n)\n</code></pre> <p>Keyword-only arguments</p> <p><code>start_date</code> and <code>end_date</code> are keyword-only arguments. They must be passed by name, not by position. These are passed to the API as <code>startDate</code> and <code>endDate</code> query parameters.</p>"},{"location":"guides/employees/#examples","title":"Examples","text":""},{"location":"guides/employees/#list-all-employees","title":"List all employees","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    employees = client.employees.list()\n\n    for emp in employees:\n        print(f\"{emp.first_name} {emp.last_name} (ID: {emp.employee_id})\")\n</code></pre>"},{"location":"guides/employees/#get-employee-detail","title":"Get employee detail","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    emp = client.employees.get(\"42\")\n\n    print(f\"Name:       {emp.first_name} {emp.last_name}\")\n    print(f\"Active:     {emp.active}\")\n    print(f\"Start Date: {emp.start_date}\")\n    print(f\"Phone:      {emp.phone}\")\n    print(f\"Email:      {emp.email}\")\n</code></pre>"},{"location":"guides/employees/#fetch-clock-entries-for-a-date-range","title":"Fetch clock entries for a date range","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    entries = client.employees.get_clock_entries(\n        \"42\",\n        start_date=\"2025-06-01\",\n        end_date=\"2025-06-14\",\n    )\n\n    print(f\"Found {len(entries)} clock entries\\n\")\n\n    for entry in entries:\n        print(f\"Site:     {entry.site_code}\")\n        print(f\"Clock In: {entry.clock_in}\")\n        print(f\"Clock Out:{entry.clock_out}\")\n        print(f\"Regular:  {entry.regular_hours}h @ ${entry.regular_rate}/h\")\n        print(f\"Overtime: {entry.overtime_hours}h @ ${entry.overtime_rate}/h\")\n        print(f\"Modified: {entry.was_modified}\")\n        print()\n</code></pre>"},{"location":"guides/employees/#summarize-hours-for-all-employees","title":"Summarize hours for all employees","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    employees = client.employees.list()\n\n    for emp in employees:\n        entries = client.employees.get_clock_entries(\n            str(emp.employee_id),\n            start_date=\"2025-06-01\",\n            end_date=\"2025-06-14\",\n        )\n\n        total_regular = sum(e.regular_hours for e in entries)\n        total_overtime = sum(e.overtime_hours for e in entries)\n\n        print(\n            f\"{emp.first_name} {emp.last_name}: \"\n            f\"{total_regular:.1f}h regular, {total_overtime:.1f}h overtime\"\n        )\n</code></pre>"},{"location":"guides/employees/#models","title":"Models","text":""},{"location":"guides/employees/#employeelistitem","title":"<code>EmployeeListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each employee.</p> Field Type Description <code>first_name</code> <code>str</code> Employee first name <code>last_name</code> <code>str</code> Employee last name <code>employee_id</code> <code>int</code> Unique employee identifier"},{"location":"guides/employees/#employee","title":"<code>Employee</code>","text":"<p>Returned by <code>get()</code>. Contains full employee details.</p> Field Type Description <code>employee_id</code> <code>int</code> Unique employee identifier <code>first_name</code> <code>str</code> Employee first name <code>last_name</code> <code>str</code> Employee last name <code>active</code> <code>bool</code> Whether the employee is active <code>start_date</code> <code>str</code> Employment start date <code>start_date_change</code> <code>str \\| None</code> Date the start date was changed <code>phone</code> <code>str \\| None</code> Phone number <code>email</code> <code>str \\| None</code> Email address"},{"location":"guides/employees/#clockentry","title":"<code>ClockEntry</code>","text":"<p>Returned by <code>get_clock_entries()</code>. Represents a single clock-in/clock-out record.</p> Field Type Description <code>clock_in</code> <code>str \\| None</code> Clock-in timestamp <code>clock_out</code> <code>str \\| None</code> Clock-out timestamp <code>regular_rate</code> <code>float</code> Hourly pay rate for regular hours <code>regular_hours</code> <code>float</code> Number of regular hours worked <code>overtime_eligible</code> <code>bool</code> Whether the employee is OT-eligible <code>overtime_rate</code> <code>float</code> Hourly pay rate for overtime hours <code>overtime_hours</code> <code>float</code> Number of overtime hours worked <code>was_modified</code> <code>bool</code> Whether the entry was manually edited <code>modification_timestamp</code> <code>str \\| None</code> When the entry was modified <code>was_created_in_back_office</code> <code>bool</code> Whether the entry was created in back office <code>site_code</code> <code>str</code> Site code where the shift occurred <p>Flattened response</p> <p>The Sonny's API returns clock entries in a nested <code>weeks[].clockEntries[]</code> structure. The <code>get_clock_entries()</code> method automatically flattens this into a single list of <code>ClockEntry</code> objects for easier iteration.</p> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>The SDK raises typed exceptions for every failure mode so your code can react precisely to each problem. Every exception inherits from <code>SonnysError</code>, letting you catch broadly or narrow down to specific error types depending on your needs.</p>"},{"location":"guides/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All SDK exceptions follow this inheritance tree. Catching a parent class also catches all of its children.</p> <pre><code>SonnysError                     # Base for all SDK errors\n  APIError                      # Base for API-related errors\n    APIConnectionError          # Network failures (DNS, refused, etc.)\n      APITimeoutError           # Request timed out before a response\n    APIStatusError              # HTTP error responses (4xx / 5xx)\n      AuthError                 # 403 -- credential or authorization problem\n      RateLimitError            # 429 -- rate limit exceeded\n      ValidationError           # 400 / 422 -- bad request parameters\n      NotFoundError             # 404 -- resource not found\n      ServerError               # 5xx -- server-side failure\n</code></pre>"},{"location":"guides/error-handling/#catching-errors","title":"Catching Errors","text":""},{"location":"guides/error-handling/#catch-all","title":"Catch-all","text":"<p>The simplest approach catches <code>SonnysError</code> to handle any SDK failure in one place:</p> <pre><code>from sonnys_data_client import SonnysClient, SonnysError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except SonnysError as e:\n        print(f\"SDK error: {e}\")\n</code></pre>"},{"location":"guides/error-handling/#catch-by-category","title":"Catch by category","text":"<p>Separate network problems from HTTP errors to apply different recovery strategies:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    APIConnectionError,\n    APIStatusError,\n    SonnysError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        customers = client.customers.list()\n    except APIConnectionError:\n        print(\"Network problem -- check your connection\")\n    except APIStatusError as e:\n        print(f\"HTTP {e.status_code}: {e.message}\")\n    except SonnysError as e:\n        print(f\"Other SDK error: {e}\")\n</code></pre>"},{"location":"guides/error-handling/#catch-specific-exceptions","title":"Catch specific exceptions","text":"<p>For fine-grained control, catch each exception type individually:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    AuthError,\n    NotFoundError,\n    RateLimitError,\n    ServerError,\n    ValidationError,\n    SonnysError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        customer = client.customers.get(\"12345\")\n    except AuthError:\n        print(\"Invalid credentials or unauthorized site\")\n    except NotFoundError:\n        print(\"Customer not found\")\n    except RateLimitError:\n        print(\"Rate limit exceeded after retries\")\n    except ValidationError as e:\n        print(f\"Bad request: {e.message}\")\n    except ServerError:\n        print(\"Server error -- try again later\")\n    except SonnysError as e:\n        print(f\"Unexpected SDK error: {e}\")\n</code></pre> <p>Tip</p> <p>Order specific exceptions before general ones -- Python matches the first <code>except</code> clause. Place <code>AuthError</code> before <code>APIStatusError</code>, and <code>APIStatusError</code> before <code>SonnysError</code>.</p>"},{"location":"guides/error-handling/#error-attributes","title":"Error Attributes","text":"<p>All <code>APIStatusError</code> subclasses (<code>AuthError</code>, <code>RateLimitError</code>, <code>ValidationError</code>, <code>NotFoundError</code>, <code>ServerError</code>) expose these attributes:</p> Attribute Type Description <code>message</code> <code>str</code> Human-readable error description from the API <code>status_code</code> <code>int</code> HTTP status code (e.g., 403, 404, 429) <code>body</code> <code>dict \\| None</code> Full parsed JSON response body from the API <code>error_type</code> <code>str \\| None</code> Sonny's API error type string (e.g., <code>\"BadClientCredentialsError\"</code>) <p>Access these attributes in your <code>except</code> block to log details or branch on the specific error type:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIStatusError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except APIStatusError as e:\n        print(f\"Status:     {e.status_code}\")\n        print(f\"Message:    {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n        print(f\"Body:       {e.body}\")\n</code></pre> <p>Readable error strings</p> <p>Printing or logging an <code>APIStatusError</code> directly (e.g., <code>print(e)</code>) produces a formatted string with all key details:</p> <pre><code>[HTTP 422] (PayloadValidationError) site: Only 1 site can be selected.\nAPI response body: {'error': {'type': 'PayloadValidationError', ...}}\n</code></pre> <p>This makes tracebacks and log output immediately actionable without needing to inspect individual attributes.</p> <p>API error_type values</p> <p>The <code>error_type</code> attribute contains the raw error type string returned by the Sonny's API. The SDK maps these to exception classes automatically:</p> API <code>error_type</code> HTTP Status SDK Exception <code>MissingClientCredentialsError</code> 403 <code>AuthError</code> <code>BadClientCredentialsError</code> 403 <code>AuthError</code> <code>MismatchCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedError</code> 403 <code>AuthError</code> <code>BadSiteCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedSiteCredentialsError</code> 403 <code>AuthError</code> <code>NotAuthorizedSiteArgsError</code> 403 <code>AuthError</code> <code>RequestRateExceedError</code> 429 <code>RateLimitError</code> <code>PayloadValidationError</code> 422 <code>ValidationError</code> <code>InvalidPayloadRequestTimestampError</code> 400 <code>ValidationError</code> <code>EntityNotFoundError</code> 404 <code>NotFoundError</code> <code>UnexpectedFailure</code> 400 <code>APIError</code> <code>ServerUnexpectedFailure</code> 500 <code>ServerError</code>"},{"location":"guides/error-handling/#per-exception-type-guidance","title":"Per-Exception-Type Guidance","text":""},{"location":"guides/error-handling/#autherror","title":"AuthError","text":"<p>When it is raised: The API returns HTTP 403 for any credential or authorization problem.</p> <p>Common causes:</p> <ul> <li>Wrong <code>api_id</code> or <code>api_key</code> values (e.g., copied from the wrong environment or database)</li> <li><code>site_code</code> not authorized for the given API ID -- each API ID is provisioned for specific sites, and using a site code from a different organization triggers <code>NotAuthorizedSiteCredentialsError</code></li> <li>Missing credentials -- forgetting to pass <code>api_id</code> or <code>api_key</code> to the constructor</li> <li>API ID/key pair mismatch -- using the API ID from one database (e.g., WashU) with the API key from another (e.g., Icon)</li> <li>Passing <code>site</code> as a query parameter instead of using the <code>site_code</code> constructor argument</li> </ul> <p>Recommended handling: Do not retry -- fix your credentials or site code configuration. Check that your <code>api_id</code>, <code>api_key</code>, and <code>site_code</code> match what was provisioned by Sonny's. Use <code>error_type</code> to pinpoint the exact problem.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import AuthError\n\nwith SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    site_code=\"JOLIET\",\n) as client:\n    try:\n        sites = client.sites.list()\n    except AuthError as e:\n        print(f\"Auth failed: {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n\n        # Branch on the specific auth failure\n        if e.error_type == \"BadClientCredentialsError\":\n            print(\"Check your api_id and api_key values\")\n        elif e.error_type == \"NotAuthorizedSiteCredentialsError\":\n            print(\"This site_code is not authorized for your API ID\")\n        elif e.error_type == \"MissingClientCredentialsError\":\n            print(\"Credentials were not provided\")\n        elif e.error_type == \"MismatchCredentialsError\":\n            print(\"API ID and key do not belong to the same account\")\n</code></pre> <p>Warning</p> <p>If you operate multiple databases (e.g., WashU and Icon) with separate credentials, double-check that you are not mixing API IDs and keys across client instances. A <code>MismatchCredentialsError</code> means the ID and key belong to different accounts.</p>"},{"location":"guides/error-handling/#ratelimiterror","title":"RateLimitError","text":"<p>When it is raised: The API returns HTTP 429 and all built-in retries have been exhausted (default: 3 attempts with exponential backoff).</p> <p>Common causes:</p> <ul> <li>Running an analytics script while a scheduled cron job is also pulling data against the same API ID</li> <li>Bulk-exporting transactions for multiple sites in a tight loop without pausing between sites</li> <li>Multiple <code>SonnysClient</code> instances sharing the same <code>api_id</code> -- each instance has its own rate limiter, but the API enforces a single 20 req/15s limit per API ID</li> <li>Burst traffic from a loop that calls <code>client.transactions.get()</code> for hundreds of individual transaction IDs</li> </ul> <p>Recommended handling: The SDK already retries 429 responses with exponential backoff (see Built-in Retry Behavior). If this exception reaches your code, the situation is severe. Back off for a longer period before retrying, or stagger your scripts.</p> <pre><code>import time\nimport logging\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import RateLimitError\n\n# Enable logging to see when 429 retries happen internally\nlogging.basicConfig(level=logging.WARNING)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        transactions = client.transactions.list(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-30\",\n        )\n    except RateLimitError as e:\n        print(f\"Rate limited after retries: {e.message}\")\n        # All 3 built-in retries failed -- back off for 30 seconds\n        time.sleep(30)\n</code></pre> <p>Tip</p> <p>If you regularly hit rate limits, check whether multiple processes share the same API ID. Stagger scheduled jobs by at least 60 seconds, or increase <code>max_retries</code> on the client to allow more backoff time.</p>"},{"location":"guides/error-handling/#validationerror","title":"ValidationError","text":"<p>When it is raised: The API returns HTTP 400 or 422 for invalid request parameters.</p> <p>Common causes:</p> <ul> <li>Date format <code>\"06/01/2025\"</code> instead of ISO 8601 (<code>\"2025-06-01\"</code>) -- this is the most common validation error and triggers <code>InvalidPayloadRequestTimestampError</code>. The SDK auto-converts ISO 8601 strings to Unix timestamps, but non-ISO formats like <code>MM/DD/YYYY</code> are not supported.</li> <li>Passing a transaction type string that does not exist to <code>list_by_type()</code> (e.g., <code>\"membership\"</code> instead of <code>\"recurring\"</code>)</li> <li>Sending <code>endDate</code> earlier than <code>startDate</code></li> <li>Missing the required <code>site</code> parameter on <code>load_job()</code> when the API ID has access to multiple sites</li> <li>Missing required parameters on endpoints that enforce them</li> </ul> <p>Recommended handling: Do not retry -- fix the request parameters. Use ISO 8601 date strings (<code>\"2025-06-01\"</code>) or Unix timestamps. Check parameter names and allowed values. Use <code>error_type</code> to distinguish between timestamp errors and general payload errors.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ValidationError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        # load_job() requires explicit site= when the API ID has multi-site access\n        results = client.transactions.load_job(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n            # Missing site= parameter!\n        )\n    except ValidationError as e:\n        print(f\"Validation error: {e.message}\")\n        print(f\"Error type: {e.error_type}\")\n\n        if e.error_type == \"PayloadValidationError\":\n            print(\"Check parameter names and values\")\n            print(f\"Full response: {e.body}\")\n        elif e.error_type == \"InvalidPayloadRequestTimestampError\":\n            print(\"Use ISO 8601 date format (YYYY-MM-DD) or Unix timestamps\")\n</code></pre> <p>Info</p> <p>The <code>PayloadValidationError</code> type may return multiple error messages in the response body. The SDK joins them into a single <code>message</code> string separated by semicolons. Check <code>e.body</code> for the original <code>\"messages\"</code> array if you need to inspect each validation failure individually.</p>"},{"location":"guides/error-handling/#notfounderror","title":"NotFoundError","text":"<p>When it is raised: The API returns HTTP 404 when the requested resource does not exist.</p> <p>Common causes:</p> <ul> <li>Transaction ID from a different site than the one configured via <code>site_code</code> -- IDs are scoped per site</li> <li>Customer ID that was valid in one database but does not exist in another (e.g., looking up a WashU customer ID against the Icon database)</li> <li>Deleted recurring account or gift card that no longer exists in the system</li> <li>Typo or truncated ID string</li> </ul> <p>Recommended handling: Verify the ID is correct and belongs to the configured site. In batch workflows where you iterate over a list of IDs, catch <code>NotFoundError</code> and skip or log the missing record rather than aborting the entire loop.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import NotFoundError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Gracefully handle missing records in a batch lookup\n    customer_ids = [\"12345\", \"99999\", \"67890\"]\n    found = []\n\n    for cid in customer_ids:\n        try:\n            customer = client.customers.get(cid)\n            found.append(customer)\n        except NotFoundError:\n            print(f\"Customer {cid} not found, skipping\")\n            # e.error_type will be \"EntityNotFoundError\"\n\n    print(f\"Found {len(found)} of {len(customer_ids)} customers\")\n</code></pre>"},{"location":"guides/error-handling/#servererror","title":"ServerError","text":"<p>When it is raised: The API returns HTTP 5xx indicating a server-side failure.</p> <p>Common causes:</p> <ul> <li>Sonny's API scheduled maintenance window -- the API may return 500 or 503 during planned updates</li> <li>Intermittent 500 errors on large date-range queries or <code>load_job()</code> requests that stress the backend</li> <li><code>ServerUnexpectedFailure</code> -- an unexpected crash on the API side</li> <li>502/503 responses from upstream infrastructure (load balancer, gateway)</li> </ul> <p>Recommended handling: Retry after a delay. Server errors are often transient. If they persist beyond a few minutes, check with Sonny's support for known outages. For automated pipelines, implement retry with backoff (see Custom Retry Patterns).</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ServerError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    max_attempts = 3\n    for attempt in range(max_attempts):\n        try:\n            transactions = client.transactions.list(\n                startDate=\"2025-06-01\",\n                endDate=\"2025-06-30\",\n            )\n            break  # Success\n        except ServerError as e:\n            print(f\"Server error ({e.status_code}): {e.message}\")\n            if attempt &lt; max_attempts - 1:\n                delay = 5 * (2 ** attempt)\n                print(f\"Retrying in {delay}s...\")\n                time.sleep(delay)\n            else:\n                print(\"All retries exhausted\")\n                raise\n</code></pre>"},{"location":"guides/error-handling/#apiconnectionerror","title":"APIConnectionError","text":"<p>When it is raised: The HTTP request fails before reaching the server -- no response is received.</p> <p>Common causes:</p> <ul> <li>No internet connection on the machine running the script</li> <li>DNS resolution failure for <code>trigonapi.sonnyscontrols.com</code> -- common on new server deployments where DNS is not yet configured</li> <li>Corporate firewall or proxy blocking outbound HTTPS traffic to the Sonny's API domain</li> <li>VPN disconnection mid-request</li> <li>Running inside a Docker container or CI environment without outbound network access</li> </ul> <p>Recommended handling: Check network connectivity. This error does not have <code>status_code</code> or <code>body</code> attributes since no HTTP response was received. For automated pipelines, retry a few times with a delay -- the network issue may be transient.</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        sites = client.sites.list()\n    except APIConnectionError as e:\n        print(f\"Connection failed: {e.message}\")\n        print(\"Troubleshooting steps:\")\n        print(\"  1. Check internet connectivity\")\n        print(\"  2. Verify DNS resolves: nslookup trigonapi.sonnyscontrols.com\")\n        print(\"  3. Check firewall allows HTTPS to trigonapi.sonnyscontrols.com\")\n        print(\"  4. If behind a proxy, configure requests proxy settings\")\n</code></pre>"},{"location":"guides/error-handling/#apitimeouterror","title":"APITimeoutError","text":"<p>When it is raised: The HTTP request was sent but no response arrived within the timeout period. Also raised when <code>load_job()</code> polling exceeds the configured <code>timeout</code>.</p> <p>Common causes:</p> <ul> <li><code>load_job()</code> on a high-volume site with a full day of transactions -- the batch job takes longer than the default 300-second timeout to complete</li> <li>Very large <code>list()</code> or <code>list_v2()</code> queries spanning months of data at a busy site</li> <li>Network congestion or high latency between your server and <code>trigonapi.sonnyscontrols.com</code></li> <li>API under heavy load from other consumers during peak hours</li> </ul> <p>Recommended handling: For <code>load_job()</code>, increase the <code>timeout</code> parameter or use a shorter date range. For list methods, narrow the date range. Consider splitting multi-month queries into smaller chunks.</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APITimeoutError\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        # Large export that may time out\n        results = client.transactions.load_job(\n            startDate=\"2025-06-01\",\n            endDate=\"2025-06-02\",\n            timeout=600.0,  # 10 minutes instead of default 5\n        )\n    except APITimeoutError:\n        print(\"Job timed out -- try a shorter date range or increase timeout\")\n        # Fallback: split into smaller chunks\n        from datetime import date, timedelta\n        start = date(2025, 6, 1)\n        end = date(2025, 6, 2)\n        midpoint = start + (end - start) / 2\n        print(f\"Try splitting: {start} to {midpoint} and {midpoint} to {end}\")\n</code></pre> <p>Note</p> <p><code>APITimeoutError</code> is a subclass of <code>APIConnectionError</code>. If you catch <code>APIConnectionError</code>, it will also catch timeouts. Use the specific <code>APITimeoutError</code> class when you need to distinguish timeouts from other connection failures.</p>"},{"location":"guides/error-handling/#built-in-retry-behavior","title":"Built-in Retry Behavior","text":"<p>The SDK includes two layers of automatic protection against rate limiting.</p>"},{"location":"guides/error-handling/#pre-request-rate-limiting","title":"Pre-request rate limiting","text":"<p>Every request passes through a sliding window rate limiter before it is sent. The limiter enforces a maximum of 20 requests per 15-second window. If you are at capacity, the client automatically sleeps until a slot opens -- no exception is raised.</p>"},{"location":"guides/error-handling/#429-retry-with-exponential-backoff","title":"429 retry with exponential backoff","text":"<p>If the API returns HTTP 429 despite the client-side limiter (e.g., another script shares the same API ID), the SDK retries with exponential backoff:</p> Attempt Delay 1 1 second 2 2 seconds 3 4 seconds <p>After <code>max_retries</code> attempts (default 3), the SDK raises <code>RateLimitError</code>.</p> <p>Note</p> <p>You can configure <code>max_retries</code> when constructing the client:</p> <pre><code>client = SonnysClient(\n    api_id=\"your-api-id\",\n    api_key=\"your-api-key\",\n    max_retries=5,  # Allow up to 5 retry attempts for 429s\n)\n</code></pre>"},{"location":"guides/error-handling/#what-is-not-retried-automatically","title":"What is NOT retried automatically","text":"<p>The SDK only retries HTTP 429 responses. These errors are not retried:</p> <ul> <li><code>APIConnectionError</code> -- Network failures (no response received)</li> <li><code>APITimeoutError</code> -- Request timeouts</li> <li><code>AuthError</code> (403) -- Credential or authorization problems</li> <li><code>ValidationError</code> (400/422) -- Invalid request parameters</li> <li><code>NotFoundError</code> (404) -- Resource does not exist</li> <li><code>ServerError</code> (5xx) -- Server-side failures</li> </ul> <p>If you need retry logic for these errors, implement it yourself using the patterns below.</p>"},{"location":"guides/error-handling/#custom-retry-patterns","title":"Custom Retry Patterns","text":""},{"location":"guides/error-handling/#retry-on-transient-server-errors","title":"Retry on transient server errors","text":"<p>Server errors (500, 502, 503) are often transient. Wrap your call in a simple retry loop with backoff:</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import ServerError\n\ndef fetch_with_retry(client, retries=3, base_delay=2.0):\n    for attempt in range(retries):\n        try:\n            return client.transactions.list(\n                startDate=\"2025-06-01\",\n                endDate=\"2025-06-30\",\n            )\n        except ServerError as e:\n            if attempt == retries - 1:\n                raise\n            delay = base_delay * (2 ** attempt)\n            print(f\"Server error ({e.status_code}), retrying in {delay}s...\")\n            time.sleep(delay)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = fetch_with_retry(client)\n</code></pre>"},{"location":"guides/error-handling/#retry-on-connection-and-timeout-errors","title":"Retry on connection and timeout errors","text":"<p>Network problems can be intermittent. Retry <code>APIConnectionError</code> and <code>APITimeoutError</code> with a short delay:</p> <pre><code>import time\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError, APITimeoutError\n\ndef fetch_with_network_retry(client, retries=3, delay=5.0):\n    for attempt in range(retries):\n        try:\n            return client.customers.list()\n        except (APIConnectionError, APITimeoutError) as e:\n            if attempt == retries - 1:\n                raise\n            print(f\"{type(e).__name__}, retrying in {delay}s...\")\n            time.sleep(delay)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    customers = fetch_with_network_retry(client)\n</code></pre>"},{"location":"guides/error-handling/#production-retry-with-tenacity","title":"Production retry with tenacity","text":"<p>For production systems, use the <code>tenacity</code> library for configurable, decorator-based retry logic:</p> <pre><code>pip install tenacity\n</code></pre> <pre><code>from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nfrom sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import APIConnectionError, APITimeoutError, ServerError\n\n@retry(\n    retry=retry_if_exception_type((ServerError, APIConnectionError, APITimeoutError)),\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=1, min=2, max=30),\n)\ndef fetch_transactions(client):\n    return client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = fetch_transactions(client)\n</code></pre> <p>Warning</p> <p>Never retry <code>AuthError</code> or <code>ValidationError</code> -- these indicate a code or configuration problem, not a transient failure. Retrying them wastes time and rate limit budget without any chance of success.</p>"},{"location":"guides/error-handling/#logging-debugging","title":"Logging &amp; Debugging","text":"<p>The SDK logs every request, response, and retry through Python's built-in <code>logging</code> module under the <code>sonnys_data_client</code> logger. Enabling debug logging is the fastest way to understand what the SDK is doing under the hood.</p>"},{"location":"guides/error-handling/#enabling-debug-logging","title":"Enabling Debug Logging","text":"<p>Log everything (SDK + all other libraries):</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <p>Log only the SDK (recommended for most debugging):</p> <pre><code>import logging\n\nlogging.getLogger(\"sonnys_data_client\").setLevel(logging.DEBUG)\n</code></pre> <p>Add a StreamHandler for scripts that don't already configure logging:</p> <pre><code>import logging\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)s %(name)s: %(message)s\"))\n\nsdk_logger = logging.getLogger(\"sonnys_data_client\")\nsdk_logger.addHandler(handler)\nsdk_logger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"guides/error-handling/#what-gets-logged","title":"What Gets Logged","text":"<p>The SDK emits these log messages at each stage of a request:</p> Level Message Pattern Meaning DEBUG <code>Rate limiter: waiting {N}s</code> Pre-request rate limit sleep DEBUG <code>Request: {METHOD} {PATH} params={PARAMS}</code> Outgoing HTTP request DEBUG <code>Response: {METHOD} {PATH} status={CODE} elapsed={TIME}s</code> Successful response received DEBUG <code>Error response: {METHOD} {PATH} status={CODE} body={BODY}</code> HTTP error before exception is raised WARNING <code>Rate limited (429), retry {N}/{MAX} after {DELAY}s</code> 429 received, backing off before retry DEBUG <code>Job submit: POST /transaction/load-job params={PARAMS}</code> Batch job submitted DEBUG <code>Job submitted: hash={HASH}</code> Job hash received from API DEBUG <code>Job poll #{N}: hash={HASH}</code> Polling for job results DEBUG <code>Job pending: hash={HASH} status={STATUS}</code> Job still processing DEBUG <code>Job complete: hash={HASH} records={N} polls={N}</code> Job finished with record count ERROR <code>Job failed: hash={HASH}</code> Batch job returned failure status"},{"location":"guides/error-handling/#reading-debug-output","title":"Reading Debug Output","text":"<p>Here is an annotated example of a typical debug session showing a successful request, a 429 retry, and an error response:</p> <pre><code>2025-06-15 10:00:00,100 DEBUG sonnys_data_client: Rate limiter: waiting 0.450s\n# ^ Rate limiter detected we're near the 20 req/15s limit. Sleeping 450ms.\n\n2025-06-15 10:00:00,550 DEBUG sonnys_data_client: Request: GET /sites params=None\n# ^ Outgoing request to the /sites endpoint with no query parameters.\n\n2025-06-15 10:00:01,200 DEBUG sonnys_data_client: Response: GET /sites status=200 elapsed=0.650s\n# ^ Success! The API responded in 650ms with HTTP 200.\n\n2025-06-15 10:00:01,210 DEBUG sonnys_data_client: Request: GET /transaction params={'startDate': 1717200000, 'endDate': 1718409600, 'limit': 100, 'offset': 1}\n# ^ Fetching transactions. Dates were auto-converted from ISO strings to Unix timestamps.\n\n2025-06-15 10:00:01,800 WARNING sonnys_data_client: Rate limited (429), retry 1/3 after 1.0s\n# ^ API returned 429. SDK will wait 1 second then retry (attempt 1 of 3).\n\n2025-06-15 10:00:02,810 DEBUG sonnys_data_client: Request: GET /transaction params={'startDate': 1717200000, 'endDate': 1718409600, 'limit': 100, 'offset': 1}\n# ^ Retry request sent after the 1-second backoff.\n\n2025-06-15 10:00:03,500 DEBUG sonnys_data_client: Response: GET /transaction status=200 elapsed=0.690s\n# ^ Retry succeeded. The API responded with HTTP 200.\n</code></pre> <p>And here is an example showing batch job lifecycle logging:</p> <pre><code>2025-06-15 10:01:00,100 DEBUG sonnys_data_client: Job submit: POST /transaction/load-job params={'startDate': 1717200000, 'endDate': 1717286400, 'site': 'JOLIET', 'limit': 100, 'offset': 1}\n# ^ Batch job submitted with date range and site parameters.\n\n2025-06-15 10:01:00,800 DEBUG sonnys_data_client: Job submitted: hash=abc123def456\n# ^ API accepted the job and returned a hash for polling.\n\n2025-06-15 10:01:02,810 DEBUG sonnys_data_client: Job poll #1: hash=abc123def456\n# ^ First poll attempt (after poll_interval delay).\n\n2025-06-15 10:01:03,200 DEBUG sonnys_data_client: Job pending: hash=abc123def456 status=pending\n# ^ Job is still processing. Will poll again after another interval.\n\n2025-06-15 10:01:05,210 DEBUG sonnys_data_client: Job poll #2: hash=abc123def456\n# ^ Second poll attempt.\n\n2025-06-15 10:01:05,900 DEBUG sonnys_data_client: Job complete: hash=abc123def456 records=347 polls=2\n# ^ Job finished! 347 records returned after 2 poll cycles.\n</code></pre> <p>And an error response example:</p> <pre><code>2025-06-15 10:02:00,100 DEBUG sonnys_data_client: Request: GET /transaction params={'startDate': '06/01/2025'}\n# ^ Request with an invalid date format (not ISO-8601 or Unix timestamp).\n\n2025-06-15 10:02:00,700 DEBUG sonnys_data_client: Error response: GET /transaction status=400 body={\"error\":{\"type\":\"InvalidPayloadRequestTimestampError\",\"message\":\"Invalid timestamp\"}}\n# ^ Full error response body logged before the exception is raised.\n\n# The exception traceback will show:\n# sonnys_data_client._exceptions.ValidationError: [HTTP 400] (InvalidPayloadRequestTimestampError) Invalid timestamp\n</code></pre> <p>Tip</p> <p>In production, leave the SDK logger at WARNING to only see 429 retries. Set to DEBUG only when troubleshooting.</p>"},{"location":"guides/error-handling/#common-issues-troubleshooting","title":"Common Issues &amp; Troubleshooting","text":""},{"location":"guides/error-handling/#troubleshooting-table","title":"Troubleshooting Table","text":"Symptom Likely Cause Solution <code>AuthError: MissingClientCredentialsError</code> <code>api_id</code> or <code>api_key</code> not provided or empty Check <code>SonnysClient</code> constructor args <code>AuthError: BadClientCredentialsError</code> Wrong <code>api_id</code> or <code>api_key</code> Verify credentials with Sonny's support <code>AuthError: NotAuthorizedSiteCredentialsError</code> <code>site_code</code> not authorized for this API ID Use a <code>site_code</code> linked to your API credentials <code>RateLimitError</code> after retries exhausted Too many concurrent requests Reduce parallelism or increase <code>max_retries</code> <code>ValidationError: PayloadValidationError</code> Invalid parameter or missing <code>site</code> on <code>load_job()</code> Check parameter names; pass <code>site=</code> to <code>load_job()</code> <code>NotFoundError: EntityNotFoundError</code> Resource ID doesn't exist or wrong site Verify ID and <code>site_code</code> match <code>ServerError</code> intermittent 500s Sonny's API transient issue Add retry logic for 5xx (see Custom Retry Patterns) <code>APIConnectionError</code> Network/DNS failure Check internet, verify <code>trigonapi.sonnyscontrols.com</code> is reachable <code>APITimeoutError</code> Request took too long Use smaller date ranges, check network latency Slow responses but no errors Rate limiter pre-emptively sleeping Enable DEBUG logging to see rate limiter waits <code>ImportError</code> on exceptions Wrong import path Import from <code>sonnys_data_client</code> directly, not <code>_exceptions</code>"},{"location":"guides/error-handling/#diagnostic-checklist","title":"Diagnostic Checklist","text":"<p>When something goes wrong, follow these steps in order:</p> <ol> <li>Enable DEBUG logging -- see Enabling Debug Logging above</li> <li>Check the <code>error_type</code> attribute for the specific API error string (e.g., <code>\"BadClientCredentialsError\"</code>)</li> <li>Inspect the <code>body</code> attribute for the full API response JSON -- it often contains additional detail</li> <li>Verify credentials with a simple <code>client.sites.list()</code> call -- if this fails with <code>AuthError</code>, your credentials are wrong</li> <li>Check rate limiter state with debug logs -- look for <code>Rate limiter: waiting</code> messages to see if pre-request throttling is slowing you down</li> </ol> <p>Warning</p> <p>The SDK auto-converts ISO 8601 date strings (e.g., <code>\"2025-06-01\"</code>) to Unix timestamps for the API. However, non-ISO formats like <code>\"06/01/2025\"</code> are not recognized and will cause an <code>InvalidPayloadRequestTimestampError</code>. Always use <code>YYYY-MM-DD</code> format or pass Unix timestamps directly.</p>"},{"location":"guides/error-handling/#quick-reference","title":"Quick Reference","text":"<p>A scannable cheat sheet mapping HTTP status codes to SDK exceptions, typical causes, and recommended actions.</p> HTTP Status SDK Exception Typical Cause Recommended Action -- <code>APIConnectionError</code> Network down, DNS failure, firewall blocking Check connectivity; retry with delay -- <code>APITimeoutError</code> Slow response, large query, job polling timeout Shorten date range; increase timeout 400 <code>ValidationError</code> Bad date format, invalid parameters Fix request parameters; do not retry 403 <code>AuthError</code> Wrong credentials, unauthorized site code Fix credentials or site_code; do not retry 404 <code>NotFoundError</code> ID does not exist, wrong site, deleted record Verify ID and site; skip in batch loops 422 <code>ValidationError</code> Payload validation failure Check parameter values; do not retry 429 <code>RateLimitError</code> Rate limit exceeded after built-in retries Back off 30s+; stagger concurrent scripts 500 <code>ServerError</code> API crash, maintenance, <code>ServerUnexpectedFailure</code> Retry with backoff; contact support if persistent 502/503 <code>ServerError</code> Gateway/infrastructure error Retry with backoff; usually transient"},{"location":"guides/giftcards/","title":"Giftcards","text":"<p>The Giftcards resource provides access to gift card liability records. Each record tracks a gift card's original value, amount used, and the site where it was sold. Use this resource to retrieve gift card balances and monitor usage across your locations.</p>"},{"location":"guides/giftcards/#methods","title":"Methods","text":""},{"location":"guides/giftcards/#listparams-listgiftcardlistitem","title":"<code>list(**params) -&gt; list[GiftcardListItem]</code>","text":"<p>Fetch all gift card records. Returns a list of <code>GiftcardListItem</code> objects. The client automatically paginates through all pages of results.</p> <pre><code>giftcards = client.giftcards.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>giftcards = client.giftcards.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre> <p>List-only resource</p> <p>The Giftcards resource only supports the <code>list()</code> method. There is no <code>get()</code> method for retrieving individual gift card details.</p>"},{"location":"guides/giftcards/#examples","title":"Examples","text":""},{"location":"guides/giftcards/#list-all-gift-cards","title":"List all gift cards","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    for gc in giftcards:\n        print(f\"Card #{gc.number} (ID: {gc.giftcard_id}) - Site: {gc.site_code}\")\n</code></pre>"},{"location":"guides/giftcards/#check-gift-card-balances","title":"Check gift card balances","text":"<p>Each gift card record includes the original <code>value</code> and <code>amount_used</code>. Calculate the remaining balance by subtracting <code>amount_used</code> from <code>value</code>:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    for gc in giftcards:\n        remaining = gc.value - gc.amount_used\n        print(\n            f\"Card #{gc.number}: \"\n            f\"Value=${gc.value:.2f}, \"\n            f\"Used=${gc.amount_used:.2f}, \"\n            f\"Remaining=${remaining:.2f}\"\n        )\n</code></pre>"},{"location":"guides/giftcards/#summarize-gift-card-liability-by-site","title":"Summarize gift card liability by site","text":"<pre><code>from collections import defaultdict\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n\n    liability_by_site: dict[str, float] = defaultdict(float)\n    for gc in giftcards:\n        remaining = gc.value - gc.amount_used\n        liability_by_site[gc.site_code] += remaining\n\n    for site, total in sorted(liability_by_site.items()):\n        print(f\"Site {site}: ${total:.2f} outstanding\")\n</code></pre>"},{"location":"guides/giftcards/#models","title":"Models","text":""},{"location":"guides/giftcards/#giftcardlistitem","title":"<code>GiftcardListItem</code>","text":"<p>Returned by <code>list()</code>. Contains the full gift card record.</p> Field Type Description <code>giftcard_id</code> <code>str</code> Unique gift card identifier <code>number</code> <code>str</code> Gift card number <code>value</code> <code>float</code> Original gift card value <code>amount_used</code> <code>float</code> Total amount redeemed <code>site_code</code> <code>str</code> Site where the gift card was sold <code>complete_date</code> <code>str \\| None</code> Date the gift card was fully used"},{"location":"guides/giftcards/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/giftcards/#liability-tracking-with-transactions","title":"Liability Tracking with Transactions","text":"<p>Combine gift card records with gift card transaction data to track redemptions and calculate outstanding liability:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    giftcards = client.giftcards.list()\n    gc_txns = client.transactions.list_by_type(\n        \"giftcard\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Outstanding liability\n    total_liability = sum(gc.value - gc.amount_used for gc in giftcards)\n    print(f\"Total outstanding liability: ${total_liability:.2f}\")\n    print(f\"Gift card transactions this month: {len(gc_txns)}\")\n    print(f\"Active cards: {sum(1 for gc in giftcards if gc.value &gt; gc.amount_used)}\")\n</code></pre> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p>"},{"location":"guides/items/","title":"Items","text":"<p>The Items resource provides access to the wash items and products catalog. Each item represents a product or service offered at a car wash site, including its SKU, pricing, and department classification. This is a list-only resource -- there is no <code>get()</code> method for individual item detail.</p>"},{"location":"guides/items/#methods","title":"Methods","text":""},{"location":"guides/items/#listparams-listitem","title":"<code>list(**params) -&gt; list[Item]</code>","text":"<p>Fetch all items. Returns a list of <code>Item</code> objects representing the full product catalog. The client automatically paginates through all pages of results.</p> <pre><code>items = client.items.list()\n</code></pre>"},{"location":"guides/items/#examples","title":"Examples","text":""},{"location":"guides/items/#list-all-items","title":"List all items","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    for item in items:\n        print(f\"{item.sku}: {item.name} - ${item.price_at_site}\")\n</code></pre>"},{"location":"guides/items/#view-item-details-with-department-info","title":"View item details with department info","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    for item in items:\n        print(f\"SKU:        {item.sku}\")\n        print(f\"Name:       {item.name}\")\n        print(f\"Department: {item.department_name}\")\n        print(f\"Price:      {item.price_at_site}\")\n        print(f\"Site:       {item.site_location}\")\n        print()\n</code></pre>"},{"location":"guides/items/#group-items-by-department","title":"Group items by department","text":"<pre><code>from collections import defaultdict\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    by_department = defaultdict(list)\n    for item in items:\n        by_department[item.department_name].append(item)\n\n    for dept, dept_items in by_department.items():\n        print(f\"\\n{dept} ({len(dept_items)} items):\")\n        for item in dept_items:\n            print(f\"  {item.sku}: {item.name} - ${item.price_at_site}\")\n</code></pre>"},{"location":"guides/items/#filter-items-by-site-location","title":"Filter items by site location","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    items = client.items.list()\n\n    site_items = [i for i in items if i.site_location == \"JOLIET\"]\n    print(f\"Found {len(site_items)} items at JOLIET site\")\n</code></pre>"},{"location":"guides/items/#models","title":"Models","text":""},{"location":"guides/items/#item","title":"<code>Item</code>","text":"<p>Returned by <code>list()</code>. Contains product catalog information.</p> Field Type Description <code>sku</code> <code>str</code> Stock keeping unit identifier <code>name</code> <code>str</code> Product or service name <code>department_name</code> <code>str</code> Department classification <code>price_at_site</code> <code>str</code> Price at the associated site <code>cost_per_item</code> <code>str \\| None</code> Cost per item (if available) <code>is_prompt_for_price</code> <code>bool</code> Whether the price is entered at the POS <code>site_location</code> <code>str</code> Site location code where the item is sold <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>List-only resource</p> <p>Items is a list-only resource. There is no <code>get()</code> method to retrieve a single item by ID. Use <code>list()</code> and filter the results in Python if you need a specific item.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/recurring/","title":"Recurring Accounts","text":"<p>The Recurring Accounts resource provides access to recurring (membership) car wash accounts. This is the richest standard resource in the client, offering five methods for listing accounts, fetching full details, tracking status changes, and reviewing modification history. Each account includes billing information, plan details, associated tags, vehicles, and customer data.</p>"},{"location":"guides/recurring/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The recurring resource offers five methods. Pick the one that matches your use case to avoid fetching more data than you need:</p> Method Returns Use When Pagination <code>list()</code> <code>RecurringListItem</code> Quick summaries, filtering by date/site Auto <code>get()</code> <code>Recurring</code> Full detail for a single account N/A <code>list_status_changes()</code> <code>RecurringStatusChange</code> Tracking cancellations, reactivations Auto <code>list_modifications()</code> <code>RecurringModification</code> Audit trail, plan changes, account edits Auto <code>list_details()</code> <code>Recurring</code> Bulk export with full detail (heavier) Auto <p>Start with <code>list()</code> for lightweight summaries and filtering by date range or site. Use <code>get()</code> when you need a single-account deep dive with nested billing history, tags, vehicles, and customer data. Reach for <code>list_status_changes()</code> when analyzing churn and retention trends, and <code>list_modifications()</code> when you need an audit trail of plan changes or account edits. Reserve <code>list_details()</code> for cases where you need the full nested data (tags, vehicles, billing history) in bulk -- it returns the same rich <code>Recurring</code> objects as <code>get()</code> but for every account, so it is significantly heavier.</p>"},{"location":"guides/recurring/#methods","title":"Methods","text":""},{"location":"guides/recurring/#listparams-listrecurringlistitem","title":"<code>list(**params) -&gt; list[RecurringListItem]</code>","text":"<p>Fetch all recurring accounts. Returns a list of <code>RecurringListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>accounts = client.recurring.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>accounts = client.recurring.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/recurring/#getaccount_id-recurring","title":"<code>get(account_id) -&gt; Recurring</code>","text":"<p>Fetch full details for a single recurring account by its ID. Returns a <code>Recurring</code> object with nested customer, tags, vehicles, billing history, and status history.</p> <pre><code>account = client.recurring.get(\"12345\")\n</code></pre>"},{"location":"guides/recurring/#list_status_changesparams-listrecurringstatuschange","title":"<code>list_status_changes(**params) -&gt; list[RecurringStatusChange]</code>","text":"<p>Fetch all recurring account status changes. Returns a list of <code>RecurringStatusChange</code> objects tracking when accounts changed status (e.g., active to cancelled).</p> <pre><code>changes = client.recurring.list_status_changes()\n</code></pre>"},{"location":"guides/recurring/#list_modificationsparams-listrecurringmodification","title":"<code>list_modifications(**params) -&gt; list[RecurringModification]</code>","text":"<p>Fetch all recurring account modifications. Returns a list of <code>RecurringModification</code> objects -- each includes the full account detail plus a list of modification entries.</p> <pre><code>modifications = client.recurring.list_modifications()\n</code></pre>"},{"location":"guides/recurring/#list_detailsparams-listrecurring","title":"<code>list_details(**params) -&gt; list[Recurring]</code>","text":"<p>Fetch all recurring accounts with full detail. Returns full <code>Recurring</code> objects (the same model as <code>get()</code>) for every account, rather than the summary <code>RecurringListItem</code> objects returned by <code>list()</code>.</p> <pre><code>details = client.recurring.list_details()\n</code></pre> <p>Heavier API call</p> <p><code>list_details()</code> returns full <code>Recurring</code> objects for every account. This results in significantly more data per request than <code>list()</code>. Use <code>list()</code> when you only need summary fields, and reserve <code>list_details()</code> for when you need the complete account data in bulk.</p>"},{"location":"guides/recurring/#examples","title":"Examples","text":""},{"location":"guides/recurring/#list-recurring-accounts","title":"List recurring accounts","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    accounts = client.recurring.list()\n\n    for acct in accounts:\n        print(\n            f\"Account {acct.id}: {acct.status_name} \"\n            f\"(status={acct.status}, site={acct.billing_site_code})\"\n        )\n</code></pre>"},{"location":"guides/recurring/#get-account-detail","title":"Get account detail","text":"<p>The detail endpoint returns billing info, plan details, tags, vehicles, customer data, and full status and billing history:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    acct = client.recurring.get(\"12345\")\n\n    # Plan and billing info\n    print(f\"Plan: {acct.plan_name}\")\n    print(f\"Billing amount: ${acct.billing_amount:.2f}\")\n    print(f\"Next bill date: {acct.next_bill_date}\")\n    print(f\"On trial: {acct.is_on_trial}\")\n    print(f\"Suspended: {acct.is_suspended}\")\n\n    # Customer\n    print(f\"Customer: {acct.customer.first_name} {acct.customer.last_name}\")\n\n    # Tags and vehicles\n    for tag in acct.tags:\n        print(f\"Tag #{tag.number} - {'active' if tag.enabled else 'disabled'}\")\n    for vehicle in acct.vehicles:\n        print(f\"Vehicle {vehicle.id}: {vehicle.plate or 'No plate'}\")\n\n    # Status history\n    for status in acct.recurring_statuses:\n        print(f\"Status: {status.status} on {status.date}\")\n\n    # Billing history\n    for billing in acct.recurring_billings:\n        print(f\"Billed ${billing.amount_charged:.2f} on {billing.date}\")\n</code></pre>"},{"location":"guides/recurring/#track-status-changes","title":"Track status changes","text":"<p>The <code>list_status_changes()</code> method returns a flat list of every status transition across all accounts:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    changes = client.recurring.list_status_changes(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for change in changes:\n        print(\n            f\"Account {change.recurring_id}: \"\n            f\"{change.old_status} -&gt; {change.new_status} \"\n            f\"on {change.status_date} \"\n            f\"(by {change.employee_name} at {change.site_code})\"\n        )\n</code></pre>"},{"location":"guides/recurring/#review-modifications","title":"Review modifications","text":"<p>The <code>list_modifications()</code> method returns full account objects extended with a <code>modifications</code> list:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    modified = client.recurring.list_modifications(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for acct in modified:\n        print(f\"Account {acct.id} ({acct.plan_name}):\")\n        for mod in acct.modifications:\n            comment = mod.comment or \"No comment\"\n            print(f\"  {mod.date}: {mod.name} - {comment}\")\n</code></pre>"},{"location":"guides/recurring/#compare-list-vs-list_details","title":"Compare list vs list_details","text":"<p>Use <code>list()</code> for lightweight summaries and <code>list_details()</code> when you need the full account data:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Lightweight: returns RecurringListItem objects\n    summaries = client.recurring.list()\n    print(f\"Found {len(summaries)} accounts (summary)\")\n\n    # Full detail: returns Recurring objects (same as get())\n    details = client.recurring.list_details()\n    print(f\"Found {len(details)} accounts (full detail)\")\n\n    # Full detail includes nested data not available in summaries\n    for acct in details:\n        print(\n            f\"Account {acct.id}: {acct.plan_name}, \"\n            f\"{len(acct.tags)} tags, {len(acct.vehicles)} vehicles\"\n        )\n</code></pre>"},{"location":"guides/recurring/#models","title":"Models","text":""},{"location":"guides/recurring/#recurringlistitem","title":"<code>RecurringListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each recurring account.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str \\| None</code> Account name <code>balance</code> <code>float \\| None</code> Current account balance <code>sign_up_date</code> <code>str</code> Date the account was created <code>cancel_date</code> <code>str \\| None</code> Date the account was cancelled <code>billing_site_id</code> <code>int</code> ID of the billing site <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>status</code> <code>int</code> Numeric status code <code>status_name</code> <code>str</code> Human-readable status name <code>billing_site_code</code> <code>str</code> Site code of the billing site"},{"location":"guides/recurring/#recurring","title":"<code>Recurring</code>","text":"<p>Returned by <code>get()</code> and <code>list_details()</code>. Contains full account details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>is_on_trial</code> <code>bool</code> Whether the account is on trial <code>trial_amount</code> <code>float</code> Trial billing amount <code>billing_site_code</code> <code>str</code> Site code of the billing site <code>creation_site_code</code> <code>str</code> Site code where account was created <code>next_bill_date</code> <code>str</code> Next scheduled billing date <code>last_bill_date</code> <code>str \\| None</code> Most recent billing date <code>billing_amount</code> <code>float \\| None</code> Current billing amount <code>is_suspended</code> <code>bool</code> Whether the account is suspended <code>suspended_until</code> <code>str \\| None</code> Suspension end date <code>current_recurring_status_name</code> <code>str</code> Current status name <code>plan_name</code> <code>str</code> Name of the wash plan <code>additional_tag_price</code> <code>float \\| None</code> Price for additional tags <code>customer</code> <code>WashbookCustomer</code> Nested customer object <code>tags</code> <code>list[WashbookTag]</code> List of RFID tags <code>vehicles</code> <code>list[WashbookVehicle]</code> List of vehicles <code>recurring_statuses</code> <code>list[RecurringStatus]</code> Status history (see below) <code>recurring_billings</code> <code>list[RecurringBilling]</code> Billing history (see below)"},{"location":"guides/recurring/#recurringstatus","title":"<code>RecurringStatus</code>","text":"<p>Nested inside the <code>Recurring</code> model. Represents a single status history entry.</p> Field Type Description <code>status</code> <code>str</code> Status name <code>date</code> <code>str</code> Date of the status"},{"location":"guides/recurring/#recurringbilling","title":"<code>RecurringBilling</code>","text":"<p>Nested inside the <code>Recurring</code> model. Represents a single billing history entry.</p> Field Type Description <code>amount_charged</code> <code>float</code> Amount billed <code>date</code> <code>str</code> Billing date <code>last_four_cc</code> <code>str</code> Last four digits of credit card <code>credit_card_expiration_date</code> <code>str \\| None</code> Card expiration date"},{"location":"guides/recurring/#recurringstatuschange","title":"<code>RecurringStatusChange</code>","text":"<p>Returned by <code>list_status_changes()</code>. Represents a single status transition.</p> Field Type Description <code>washbook_account_id</code> <code>str</code> Associated washbook account ID <code>recurring_id</code> <code>str</code> Recurring account identifier <code>old_status</code> <code>str</code> Previous status <code>new_status</code> <code>str</code> New status <code>status_date</code> <code>str</code> Date of the status change <code>employee_name</code> <code>str</code> Employee who made the change <code>site_code</code> <code>str</code> Site where the change occurred"},{"location":"guides/recurring/#recurringmodification","title":"<code>RecurringModification</code>","text":"<p>Returned by <code>list_modifications()</code>. Extends the <code>Recurring</code> model with a modifications list.</p> <p>This model inherits all fields from <code>Recurring</code> (see above) plus:</p> Field Type Description <code>modifications</code> <code>list[RecurringModificationEntry]</code> List of modifications"},{"location":"guides/recurring/#recurringmodificationentry","title":"<code>RecurringModificationEntry</code>","text":"<p>Nested inside <code>RecurringModification</code>.</p> Field Type Description <code>name</code> <code>str</code> Modification name <code>date</code> <code>str</code> Date of the modification <code>comment</code> <code>str \\| None</code> Optional comment"},{"location":"guides/recurring/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/recurring/#churn-analysis","title":"Churn Analysis","text":"<p>Use <code>list_status_changes()</code> to analyze account churn over a date range. Each status change includes the old and new status, the date, and the employee and site responsible:</p> <pre><code>from collections import Counter\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    changes = client.recurring.list_status_changes(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Count transitions by type\n    transitions = Counter(\n        f\"{c.old_status} \u2192 {c.new_status}\" for c in changes\n    )\n    for transition, count in transitions.most_common():\n        print(f\"{transition}: {count}\")\n\n    # Find cancellations\n    cancellations = [c for c in changes if c.new_status.lower() == \"cancelled\"]\n    print(f\"\\n{len(cancellations)} cancellations this month\")\n    for c in cancellations:\n        print(f\"  Account {c.recurring_id} at {c.site_code} on {c.status_date}\")\n</code></pre>"},{"location":"guides/recurring/#billing-history-report","title":"Billing History Report","text":"<p>Use <code>list_details()</code> to build a billing summary across all accounts. Each <code>Recurring</code> object includes a <code>recurring_billings</code> list with individual charge records:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    accounts = client.recurring.list_details(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    total_revenue = 0.0\n    for acct in accounts:\n        acct_total = sum(b.amount_charged for b in acct.recurring_billings)\n        total_revenue += acct_total\n        if acct_total &gt; 0:\n            print(\n                f\"Account {acct.id} ({acct.plan_name}): \"\n                f\"${acct_total:.2f} over {len(acct.recurring_billings)} billings\"\n            )\n\n    print(f\"\\nTotal recurring revenue: ${total_revenue:.2f}\")\n</code></pre> <p>Use <code>list_details()</code> only when needed</p> <p><code>list_details()</code> returns full <code>Recurring</code> objects for every account, including nested tags, vehicles, and billing history. This is significantly heavier than <code>list()</code>. Use it only when you need billing or status history data in bulk.</p> <p>Shared nested types</p> <p>The <code>Recurring</code> model reuses <code>WashbookCustomer</code>, <code>WashbookTag</code>, and <code>WashbookVehicle</code> from the Washbooks resource. See that guide for field-level documentation of those nested types.</p> <p>Auto-pagination</p> <p>All list methods (<code>list()</code>, <code>list_status_changes()</code>, <code>list_modifications()</code>, and <code>list_details()</code>) automatically fetch all pages of results. You do not need to handle pagination manually.</p> <p>See also</p> <p>For patterns combining recurring accounts with transaction data, see the Transactions guide.</p>"},{"location":"guides/sites/","title":"Sites","text":"<p>The Sites resource provides access to the car wash site locations associated with your API credentials. Each site represents a physical car wash location with its identifying code, name, and timezone. This is a list-only resource -- there is no <code>get()</code> method for individual site detail.</p>"},{"location":"guides/sites/#methods","title":"Methods","text":""},{"location":"guides/sites/#listparams-listsite","title":"<code>list(**params) -&gt; list[Site]</code>","text":"<p>Fetch all sites. Returns a list of <code>Site</code> objects representing every car wash location associated with the API credentials.</p> <pre><code>sites = client.sites.list()\n</code></pre> <p>Not paginated</p> <p>Unlike other resources, the Sites endpoint is not paginated. It returns all sites in a single API call. The <code>list()</code> method makes exactly one request regardless of how many sites exist.</p>"},{"location":"guides/sites/#examples","title":"Examples","text":""},{"location":"guides/sites/#list-all-sites","title":"List all sites","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    for site in sites:\n        print(f\"{site.code}: {site.name} ({site.timezone})\")\n</code></pre>"},{"location":"guides/sites/#access-site-fields","title":"Access site fields","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    for site in sites:\n        print(f\"Site ID:  {site.site_id}\")\n        print(f\"Code:     {site.code}\")\n        print(f\"Name:     {site.name}\")\n        print(f\"Timezone: {site.timezone}\")\n        print()\n</code></pre>"},{"location":"guides/sites/#build-a-site-code-lookup","title":"Build a site code lookup","text":"<p>Site codes are used as filter parameters in other resources. Building a lookup dictionary can be helpful when working across multiple resources:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    sites = client.sites.list()\n\n    # Map site codes to site names\n    site_names = {site.code: site.name for site in sites}\n\n    # Use in combination with other resources\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-01\",\n    )\n\n    for txn in transactions:\n        name = site_names.get(txn.site_code, \"Unknown\")\n        print(f\"{txn.transaction_id} at {name}\")\n</code></pre>"},{"location":"guides/sites/#models","title":"Models","text":""},{"location":"guides/sites/#site","title":"<code>Site</code>","text":"<p>Returned by <code>list()</code>. Contains site location information.</p> Field Type Description <code>site_id</code> <code>int</code> Unique site identifier <code>code</code> <code>str \\| None</code> Site code (used in other API calls) <code>name</code> <code>str</code> Display name of the site <code>timezone</code> <code>str \\| None</code> Timezone of the site location <p>Site codes in other resources</p> <p>Site codes appear throughout other resources (e.g., transactions, clock entries) as a foreign key. Use <code>sites.list()</code> to retrieve the full site names and details for those codes.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"},{"location":"guides/stats/","title":"Stats","text":"<p>The Stats resource provides computed business analytics and KPIs derived from transaction data. Unlike other resources that wrap REST endpoints directly, <code>client.stats</code> fetches raw data from the API and aggregates it locally, giving you ready-to-use metrics like total sales, wash volume, new memberships, and conversion rates without writing any aggregation logic yourself.</p> <p>Rinsed alignment</p> <p>Stats calculations are designed to match Rinsed reporting as closely as possible.  Wash classification uses a combination of v2 transaction flags (<code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>) and v1 type endpoints (<code>type=wash</code>, <code>type=recurring</code>) to accurately distinguish car washes from recharges and refunds.  In validation testing across 10 days of JOLIET data, 7/10 days matched Rinsed exactly on all wash metrics, with remaining days off by only 1-2 counts.</p>"},{"location":"guides/stats/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The stats resource offers six methods. Pick the one that matches your use case:</p> Method Returns Description API Calls <code>total_sales(start, end)</code> <code>SalesResult</code> Revenue breakdown by category (recurring, retail) 1 <code>total_washes(start, end)</code> <code>WashResult</code> Wash volume breakdown (member, retail, eligible, free) 3 <code>retail_wash_count(start, end)</code> <code>int</code> Count of retail wash transactions 2 <code>new_memberships_sold(start, end)</code> <code>int</code> Count of recurring plan sales 1 <code>conversion_rate(start, end)</code> <code>ConversionResult</code> Membership conversion rate KPI 4 <code>report(start, end)</code> <code>StatsReport</code> All KPIs in a single call (most efficient) 3 <p>Use individual methods when you need a single metric. Use <code>report()</code> when you need multiple KPIs -- it makes 3 API calls instead of the 11 that would result from calling the individual methods separately.</p>"},{"location":"guides/stats/#date-range-input","title":"Date Range Input","text":"<p>All stats methods accept a <code>start</code> and <code>end</code> parameter for the date range. You can pass either an ISO-8601 date string or a Python <code>datetime</code> object:</p> <pre><code># ISO-8601 strings\nresult = client.stats.total_sales(\"2026-01-01\", \"2026-01-31\")\n\n# datetime objects\nfrom datetime import datetime\nresult = client.stats.total_sales(\n    datetime(2026, 1, 1),\n    datetime(2026, 1, 31),\n)\n</code></pre> <p>Date-only strings automatically get boundary times applied (<code>00:00:01</code> start, <code>23:59:59</code> end) in the site's local timezone, then converted to UTC.  Naive datetime objects are assumed to be UTC.  Timezone-aware datetimes are converted to UTC.  If <code>start</code> is after <code>end</code>, a <code>ValueError</code> is raised.</p>"},{"location":"guides/stats/#methods","title":"Methods","text":""},{"location":"guides/stats/#total_salesstart-end-salesresult","title":"<code>total_sales(start, end) -&gt; SalesResult</code>","text":"<p>Compute a revenue breakdown for a date range. Fetches all transactions via the enriched v2 endpoint and categorizes them into three buckets: recurring plan sales, recurring redemptions, and retail.</p> <pre><code>result = client.stats.total_sales(\"2026-01-01\", \"2026-01-31\")\n\nprint(f\"Total revenue: ${result.total:.2f} ({result.count} transactions)\")\nprint(f\"Recurring plan sales: ${result.recurring_plan_sales:.2f} ({result.recurring_plan_sales_count})\")\nprint(f\"Recurring redemptions: ${result.recurring_redemptions:.2f} ({result.recurring_redemptions_count})\")\nprint(f\"Retail: ${result.retail:.2f} ({result.retail_count})\")\n</code></pre> <p><code>SalesResult</code> fields:</p> Field Type Description <code>total</code> <code>float</code> Grand total revenue <code>count</code> <code>int</code> Total transaction count <code>recurring_plan_sales</code> <code>float</code> Revenue from recurring plan sales <code>recurring_plan_sales_count</code> <code>int</code> Number of recurring plan sale transactions <code>recurring_redemptions</code> <code>float</code> Revenue from recurring redemptions <code>recurring_redemptions_count</code> <code>int</code> Number of recurring redemption transactions <code>retail</code> <code>float</code> Revenue from retail transactions <code>retail_count</code> <code>int</code> Number of retail transactions"},{"location":"guides/stats/#total_washesstart-end-washresult","title":"<code>total_washes(start, end) -&gt; WashResult</code>","text":"<p>Compute wash volume for a date range. Uses three data sources to classify transactions accurately:</p> <ul> <li>v2 endpoint -- provides <code>is_recurring_plan_sale</code> and <code>is_recurring_plan_redemption</code> flags</li> <li>v1 <code>type=wash</code> -- identifies actual car wash transactions</li> <li>v1 <code>type=recurring</code> -- identifies recharges (monthly billing) to exclude</li> </ul> <p>Classification priority: redemption &gt; plan sale &gt; wash &gt; recharge &gt; unknown. Transactions in both <code>type=wash</code> and <code>type=recurring</code> are treated as washes. Negative-total transactions (refunds) are excluded entirely.</p> <pre><code>result = client.stats.total_washes(\"2026-01-01\", \"2026-01-31\")\n\nprint(f\"Total washes: {result.total}\")\nprint(f\"Member washes: {result.member_wash_count}\")\nprint(f\"Retail washes: {result.retail_wash_count}\")\nprint(f\"Eligible washes: {result.eligible_wash_count}\")\nprint(f\"Free washes: {result.free_wash_count}\")\n</code></pre> <p><code>WashResult</code> fields:</p> Field Type Description <code>total</code> <code>int</code> Total wash count (member + retail + plan sale washes) <code>member_wash_count</code> <code>int</code> Membership redemption washes <code>retail_wash_count</code> <code>int</code> Non-member washes (includes unknown non-negative types) <code>eligible_wash_count</code> <code>int</code> Derived: <code>total - member - free</code>. Denominator for conversion rate <code>free_wash_count</code> <code>int</code> Washes with <code>total == 0</code> (complimentary)"},{"location":"guides/stats/#retail_wash_countstart-end-int","title":"<code>retail_wash_count(start, end) -&gt; int</code>","text":"<p>Count retail wash transactions for a date range. A retail wash is a <code>type=wash</code> transaction that is neither a recurring plan sale nor a recurring redemption.</p> <pre><code>count = client.stats.retail_wash_count(\"2026-01-01\", \"2026-01-31\")\nprint(f\"Retail washes: {count}\")\n</code></pre>"},{"location":"guides/stats/#new_memberships_soldstart-end-int","title":"<code>new_memberships_sold(start, end) -&gt; int</code>","text":"<p>Count new membership sales for a date range. Fetches v2 transactions and counts those flagged as <code>is_recurring_plan_sale</code>. This captures both brand-new sign-ups and reactivations -- any transaction where a recurring plan was sold.</p> <pre><code>count = client.stats.new_memberships_sold(\"2026-01-01\", \"2026-01-31\")\nprint(f\"New memberships sold: {count}\")\n</code></pre>"},{"location":"guides/stats/#conversion_ratestart-end-conversionresult","title":"<code>conversion_rate(start, end) -&gt; ConversionResult</code>","text":"<p>Compute the membership conversion rate for a date range. Measures how effectively a site converts eligible wash customers into membership sign-ups. The rate is computed as <code>new_memberships / eligible_washes</code>.</p> <p>Eligible washes are derived from total washes: <code>total - member - free</code>. This includes retail washes with <code>total &gt; 0</code>, plan sale washes, and unknown non-negative transaction types.</p> <pre><code>result = client.stats.conversion_rate(\"2026-01-01\", \"2026-01-31\")\n\nprint(f\"Conversion rate: {result.rate:.1%}\")\nprint(f\"New memberships: {result.new_memberships}\")\nprint(f\"Eligible washes: {result.eligible_washes}\")\n</code></pre> <p>When there are zero eligible washes the rate is <code>0.0</code> (division-by-zero safe).</p> <p><code>ConversionResult</code> fields:</p> Field Type Description <code>rate</code> <code>float</code> Conversion rate as a decimal (e.g. <code>0.15</code> = 15%) <code>new_memberships</code> <code>int</code> Number of recurring plan sales <code>eligible_washes</code> <code>int</code> Eligible washes (denominator)"},{"location":"guides/stats/#reportstart-end-statsreport","title":"<code>report(start, end) -&gt; StatsReport</code>","text":"<p>Compute all KPIs for a date range in a single call. This is the most efficient way to retrieve multiple stats -- it makes 3 API calls and computes every KPI locally, compared to the 11 API calls that would result from calling <code>total_sales()</code>, <code>total_washes()</code>, <code>new_memberships_sold()</code>, and <code>conversion_rate()</code> individually.</p> <pre><code>rpt = client.stats.report(\"2026-01-01\", \"2026-01-31\")\n\nprint(f\"Period: {rpt.period_start} to {rpt.period_end}\")\nprint(f\"Revenue: ${rpt.sales.total:.2f} ({rpt.sales.count} transactions)\")\nprint(f\"Washes: {rpt.washes.total} (member: {rpt.washes.member_wash_count}, retail: {rpt.washes.retail_wash_count})\")\nprint(f\"Eligible: {rpt.washes.eligible_wash_count}, Free: {rpt.washes.free_wash_count}\")\nprint(f\"New memberships: {rpt.new_memberships}\")\nprint(f\"Conversion rate: {rpt.conversion.rate:.1%}\")\n</code></pre> <p><code>StatsReport</code> fields:</p> Field Type Description <code>sales</code> <code>SalesResult</code> Revenue breakdown (see <code>total_sales()</code> above) <code>washes</code> <code>WashResult</code> Wash volume breakdown (see <code>total_washes()</code> above) <code>new_memberships</code> <code>int</code> Count of recurring plan sales <code>conversion</code> <code>ConversionResult</code> Conversion rate KPI (see <code>conversion_rate()</code> above) <code>period_start</code> <code>str</code> ISO-8601 date string for start of report range <code>period_end</code> <code>str</code> ISO-8601 date string for end of report range"},{"location":"guides/stats/#examples","title":"Examples","text":""},{"location":"guides/stats/#monthly-performance-snapshot","title":"Monthly performance snapshot","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\",\n                   site_code=\"JOLIET\") as client:\n    rpt = client.stats.report(\"2026-01-01\", \"2026-01-31\")\n\n    print(f\"January 2026 Performance\")\n    print(f\"{'='*40}\")\n    print(f\"Revenue:       ${rpt.sales.total:&gt;10,.2f}\")\n    print(f\"  Memberships: ${rpt.sales.recurring_plan_sales:&gt;10,.2f}\")\n    print(f\"  Retail:      ${rpt.sales.retail:&gt;10,.2f}\")\n    print(f\"Washes:        {rpt.washes.total:&gt;10,}\")\n    print(f\"  Member:      {rpt.washes.member_wash_count:&gt;10,}\")\n    print(f\"  Eligible:    {rpt.washes.eligible_wash_count:&gt;10,}\")\n    print(f\"  Free:        {rpt.washes.free_wash_count:&gt;10,}\")\n    print(f\"New members:   {rpt.new_memberships:&gt;10,}\")\n    print(f\"Conversion:    {rpt.conversion.rate:&gt;9.1%}\")\n</code></pre>"},{"location":"guides/stats/#compare-two-periods","title":"Compare two periods","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\",\n                   site_code=\"JOLIET\") as client:\n    jan = client.stats.report(\"2026-01-01\", \"2026-01-31\")\n    feb = client.stats.report(\"2026-02-01\", \"2026-02-28\")\n\n    rev_change = feb.sales.total - jan.sales.total\n    wash_change = feb.washes.total - jan.washes.total\n\n    print(f\"Revenue change: ${rev_change:+,.2f}\")\n    print(f\"Wash volume change: {wash_change:+,}\")\n    print(f\"Conversion: {jan.conversion.rate:.1%} -&gt; {feb.conversion.rate:.1%}\")\n</code></pre>"},{"location":"guides/stats/#quick-single-metric-check","title":"Quick single-metric check","text":"<p>When you only need one number, use the individual methods to minimize API calls:</p> <pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\",\n                   site_code=\"JOLIET\") as client:\n    # Just need revenue? 1 API call\n    sales = client.stats.total_sales(\"2026-01-01\", \"2026-01-31\")\n    print(f\"Revenue: ${sales.total:.2f}\")\n\n    # Just need wash count? 3 API calls\n    washes = client.stats.total_washes(\"2026-01-01\", \"2026-01-31\")\n    print(f\"Washes: {washes.total}\")\n</code></pre>"},{"location":"guides/stats/#performance-tips","title":"Performance Tips","text":"<p>Use <code>report()</code> when you need multiple KPIs</p> <p>Calling <code>total_sales()</code>, <code>total_washes()</code>, <code>new_memberships_sold()</code>, and <code>conversion_rate()</code> individually results in 11 API calls because some underlying data fetches overlap. The <code>report()</code> method shares data fetches across KPIs and computes everything in just 3 API calls:</p> <ol> <li><code>transactions.list_v2()</code> -- enriched transactions with membership flags</li> <li><code>transactions.list_by_type(\"wash\")</code> -- identifies actual car washes</li> <li><code>transactions.list_by_type(\"recurring\")</code> -- identifies recharges to exclude</li> </ol> <p>Use individual methods for single metrics</p> <p>If you only need one stat, calling the individual method is more efficient than <code>report()</code>. For example, <code>total_sales()</code> makes just 1 API call, while <code>report()</code> always makes 3.</p> <p>No caching between calls</p> <p>Stats methods do not cache results between calls. Each invocation fetches fresh data from the API. If you need the same stats multiple times, store the result in a variable rather than calling the method again.</p>"},{"location":"guides/transactions/","title":"Transactions","text":"<p>The Transactions resource provides access to transaction records across all wash types. This is the most feature-rich resource in the client, offering five methods including type-filtered listing, an enriched v2 endpoint, and a batch job system for large exports. Use this resource to retrieve transaction summaries, full details with tenders and line items, and bulk data exports.</p>"},{"location":"guides/transactions/#choosing-the-right-method","title":"Choosing the Right Method","text":"<p>The Transactions resource exposes five methods. Use this table to pick the right one for your use case:</p> Method Returns Use When Caching Pagination <code>list()</code> <code>TransactionListItem</code> Quick summaries, date range queries None Auto <code>list_by_type()</code> <code>TransactionListItem</code> Filtering by wash/prepaid/recurring/etc. None Auto <code>list_v2()</code> <code>TransactionV2ListItem</code> Need customer_id, recurring flags, status 10-min cache Auto <code>get()</code> <code>Transaction</code> Full detail for a single transaction None N/A <code>load_job()</code> <code>TransactionJobItem</code> Bulk exports, full detail + v2 fields 20-min cache Auto (job-level) <p>For most day-to-day queries, start with <code>list()</code> -- it is the fastest method with no caching layer. Switch to <code>list_by_type()</code> when you only need a specific transaction type (e.g., <code>\"recurring\"</code> or <code>\"giftcard\"</code>). Use <code>list_v2()</code> when your analysis requires the enriched fields like <code>customer_id</code>, <code>is_recurring_plan_sale</code>, or <code>transaction_status</code> -- but be aware of the 10-minute cache. Call <code>get()</code> when you need the complete detail for a single transaction, including tenders, line items, and discounts. For bulk exports where you need full transaction detail on every record, use <code>load_job()</code> -- it combines the depth of <code>get()</code> with the enrichment of <code>list_v2()</code>, at the cost of a slower batch-job workflow and a 20-minute cache.</p>"},{"location":"guides/transactions/#query-parameters","title":"Query Parameters","text":"<p>The list methods (<code>list()</code>, <code>list_by_type()</code>, <code>list_v2()</code>) and <code>load_job()</code> all accept the same query parameters:</p> Parameter Type Description <code>startDate</code> <code>str \\| int</code> Start of date range \u2014 ISO 8601 string (<code>\"2026-01-15\"</code>) or Unix timestamp (<code>1736899200</code>) <code>endDate</code> <code>str \\| int</code> End of date range \u2014 ISO 8601 string (<code>\"2026-01-31\"</code>) or Unix timestamp (<code>1738281600</code>) <code>site</code> <code>str</code> Filter by site code <code>region</code> <code>str</code> Filter by region <p>Pagination is handled automatically</p> <p>The <code>limit</code> and <code>offset</code> parameters are managed by the client's auto-pagination logic -- you do not need to set these manually. For <code>load_job()</code>, <code>limit</code> and <code>offset</code> control job-level pagination (default 100 records per job page), but the client handles this transparently.</p> <p>Date conversion</p> <p>The SDK automatically converts ISO 8601 date strings to Unix timestamps before sending them to the API. You can pass either format \u2014 the SDK handles the conversion transparently.</p> <p><code>get()</code> takes no query parameters</p> <p>The <code>get()</code> method accepts only a positional <code>trans_id</code> argument and does not support any query parameters. Pass the transaction ID directly: <code>client.transactions.get(\"98765\")</code>.</p>"},{"location":"guides/transactions/#methods","title":"Methods","text":""},{"location":"guides/transactions/#listparams-listtransactionlistitem","title":"<code>list(**params) -&gt; list[TransactionListItem]</code>","text":"<p>Fetch all transactions. Returns a list of <code>TransactionListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>transactions = client.transactions.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>transactions = client.transactions.list(\n    startDate=\"2025-06-01\",\n    endDate=\"2025-06-30\",\n)\n</code></pre>"},{"location":"guides/transactions/#gettrans_id-transaction","title":"<code>get(trans_id) -&gt; Transaction</code>","text":"<p>Fetch full details for a single transaction by its ID. Returns a <code>Transaction</code> object with tenders, line items, discounts, and employee information.</p> <pre><code>transaction = client.transactions.get(\"98765\")\n</code></pre>"},{"location":"guides/transactions/#list_by_typeitem_type-params-listtransactionlistitem","title":"<code>list_by_type(item_type, **params) -&gt; list[TransactionListItem]</code>","text":"<p>Fetch all transactions of a specific type. The <code>item_type</code> parameter accepts these values:</p> <ul> <li><code>wash</code> -- standard wash transactions</li> <li><code>prepaid-wash</code> -- prepaid wash redemptions</li> <li><code>recurring</code> -- recurring membership transactions</li> <li><code>washbook</code> -- wash book transactions</li> <li><code>giftcard</code> -- gift card transactions</li> <li><code>merchandise</code> -- merchandise sales</li> <li><code>house-account</code> -- house account transactions</li> </ul> <pre><code>wash_transactions = client.transactions.list_by_type(\"wash\")\n</code></pre>"},{"location":"guides/transactions/#list_v2params-listtransactionv2listitem","title":"<code>list_v2(**params) -&gt; list[TransactionV2ListItem]</code>","text":"<p>Fetch all transactions using the v2 endpoint. Returns enriched list items with additional fields: <code>customer_id</code>, <code>is_recurring_plan_sale</code>, <code>is_recurring_plan_redemption</code>, and <code>transaction_status</code>.</p> <pre><code>transactions_v2 = client.transactions.list_v2(\n    startDate=\"2025-06-01\",\n    endDate=\"2025-06-30\",\n)\n</code></pre> <p>V2 caching</p> <p>The API caches v2 responses for 10 minutes per reporting criteria. If you need real-time data, use the standard <code>list()</code> method instead.</p>"},{"location":"guides/transactions/#load_job-poll_interval20-timeout3000-params-listtransactionjobitem","title":"<code>load_job(*, poll_interval=2.0, timeout=300.0, **params) -&gt; list[TransactionJobItem]</code>","text":"<p>Submit a batch job and auto-poll until results are ready. Returns <code>TransactionJobItem</code> objects -- full transaction details enriched with v2 fields. The method handles pagination at the job submission level, submitting as many jobs as needed to retrieve all records.</p> <pre><code>job_results = client.transactions.load_job(\n    startDate=\"2025-06-15\",\n    endDate=\"2025-06-16\",\n    site=\"JOLIET\",\n)\n</code></pre> <p>Date range limit and site parameter</p> <p>The <code>load_job()</code> method is limited to a maximum 24-hour date range per call. For longer periods, submit multiple jobs with consecutive date ranges.</p> <p>The <code>site</code> parameter is required for <code>load_job()</code> \u2014 pass it explicitly even if you set <code>site_code</code> on the client constructor.</p> <p>Job caching and polling</p> <p>Job data is cached by the API for 20 minutes. The <code>poll_interval</code> parameter controls how frequently the client checks for results (default 2 seconds), and <code>timeout</code> sets the maximum wait time per job (default 300 seconds / 5 minutes).</p>"},{"location":"guides/transactions/#examples","title":"Examples","text":""},{"location":"guides/transactions/#list-transactions-with-date-range","title":"List transactions with date range","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for txn in transactions:\n        print(\n            f\"#{txn.trans_number} (ID: {txn.trans_id}) - \"\n            f\"${txn.total:.2f} on {txn.date}\"\n        )\n</code></pre>"},{"location":"guides/transactions/#get-transaction-detail","title":"Get transaction detail","text":"<p>The detail endpoint returns the complete transaction including tenders, line items, discounts, and employee information:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    txn = client.transactions.get(\"98765\")\n\n    # Transaction summary\n    print(f\"Transaction #{txn.number} ({txn.type})\")\n    print(f\"Date: {txn.complete_date}\")\n    print(f\"Location: {txn.location_code}\")\n    print(f\"Total: ${txn.total:.2f}\")\n    print(f\"Customer: {txn.customer_name or 'N/A'}\")\n    print(f\"Cashier: {txn.employee_cashier or 'N/A'}\")\n\n    # Line items\n    print(\"\\nItems:\")\n    for item in txn.items:\n        voided = \" [VOIDED]\" if item.is_voided else \"\"\n        print(f\"  {item.name} ({item.department}): ${item.net:.2f}{voided}\")\n\n    # Payment tenders\n    print(\"\\nTenders:\")\n    for tender in txn.tenders:\n        print(f\"  {tender.tender}: ${tender.total:.2f}\")\n\n    # Discounts\n    if txn.discounts:\n        print(\"\\nDiscounts:\")\n        for disc in txn.discounts:\n            print(f\"  {disc.discount_name} on {disc.applied_to_item_name}: -${disc.discount_amount:.2f}\")\n</code></pre>"},{"location":"guides/transactions/#filter-by-transaction-type","title":"Filter by transaction type","text":"<p>Retrieve only specific transaction types to focus your analysis:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Get all recurring membership transactions\n    recurring_txns = client.transactions.list_by_type(\n        \"recurring\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(recurring_txns)} recurring transactions\")\n\n    # Get all gift card transactions\n    gc_txns = client.transactions.list_by_type(\n        \"giftcard\",\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n    print(f\"Found {len(gc_txns)} gift card transactions\")\n</code></pre>"},{"location":"guides/transactions/#use-the-v2-endpoint-for-enriched-data","title":"Use the v2 endpoint for enriched data","text":"<p>The v2 endpoint adds <code>customer_id</code>, recurring flags, and transaction status to each list item:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    transactions = client.transactions.list_v2(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for txn in transactions:\n        flags = []\n        if txn.is_recurring_plan_sale:\n            flags.append(\"recurring-sale\")\n        if txn.is_recurring_plan_redemption:\n            flags.append(\"recurring-redemption\")\n\n        flag_str = f\" [{', '.join(flags)}]\" if flags else \"\"\n        print(\n            f\"#{txn.trans_number}: ${txn.total:.2f} - \"\n            f\"Status: {txn.transaction_status}\"\n            f\"{flag_str}\"\n        )\n</code></pre>"},{"location":"guides/transactions/#batch-export-with-load_job","title":"Batch export with load_job","text":"<p>The <code>load_job()</code> method is designed for bulk data exports. It submits a batch job to the API, automatically polls for completion, and paginates through all results:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Export one day of transactions (max 24-hour range)\n    results = client.transactions.load_job(\n        startDate=\"2025-06-15\",\n        endDate=\"2025-06-16\",\n        site=\"JOLIET\",\n    )\n\n    print(f\"Exported {len(results)} transactions\")\n\n    for txn in results:\n        print(\n            f\"#{txn.number} at {txn.location_code}: \"\n            f\"${txn.total:.2f} ({txn.transaction_status})\"\n        )\n</code></pre> <p>You can customize the polling behavior:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    results = client.transactions.load_job(\n        startDate=\"2025-06-15\",\n        endDate=\"2025-06-16\",\n        site=\"JOLIET\",\n        poll_interval=5.0,   # Check every 5 seconds\n        timeout=600.0,       # Wait up to 10 minutes\n    )\n</code></pre>"},{"location":"guides/transactions/#batch-job-workflow","title":"Batch Job Workflow","text":"<p>The <code>load_job()</code> method is the most complex operation in the SDK. Under the hood, it orchestrates a multi-step batch job workflow against two API endpoints. This section explains how it works so you can understand the timing, error handling, and pagination behavior.</p>"},{"location":"guides/transactions/#how-it-works","title":"How It Works","text":"<p>Each call to <code>load_job()</code> follows a three-phase workflow: submit the job, poll for completion, and return the results.</p> <pre><code>  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  Submit Job  \u2502\u2500\u2500\u2500\u2500&gt;\u2502  Poll Status  \u2502\u2500\u2500\u2500\u2500&gt;\u2502   Return    \u2502\n  \u2502  POST        \u2502     \u2502  GET          \u2502     \u2502   Results   \u2502\n  \u2502  /load-job   \u2502     \u2502  /get-job-data\u2502     \u2502             \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n                        \u2502 Status? \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u25bc        \u25bc        \u25bc\n                 \"pass\"  \"working\"  \"fail\"\n                   \u2502        \u2502        \u2502\n                   \u2502     sleep &amp;     \u2502\n                   \u2502     retry \u2500\u2500\u2510   \u2502\n                   \u2502        ^    \u2502   \u2502\n                   \u2502        \u2514\u2500\u2500\u2500\u2500\u2518   \u2502\n                   \u25bc                 \u25bc\n               Return data     Raise APIError\n</code></pre> <ol> <li>Submit -- The client sends a <code>POST</code> request to <code>/transaction/load-job</code>    with your query parameters. The API returns a <code>hash</code> identifier for the job.</li> <li>Poll -- The client sends <code>GET</code> requests to <code>/transaction/get-job-data</code>    with the job hash, sleeping <code>poll_interval</code> seconds between attempts.</li> <li>Return -- When the status reaches <code>\"pass\"</code>, the response contains the    transaction data. The client validates each record into a    <code>TransactionJobItem</code> model and returns the full list.</li> </ol> <p>Debug logging</p> <p>Enable <code>DEBUG</code> logging on <code>sonnys_data_client</code> to see the full job lifecycle: job submission with parameters, hash returned, each poll attempt, pending/complete status transitions, and final record count.</p>"},{"location":"guides/transactions/#job-status-lifecycle","title":"Job Status Lifecycle","text":"<p>Each polling response includes a <code>status</code> field with one of three values:</p> <ul> <li><code>\"working\"</code> -- The job is still processing. The client sleeps for   <code>poll_interval</code> seconds (default 2.0) and sends another poll request.</li> <li><code>\"pass\"</code> -- The job completed successfully. Transaction data is available   in the response body.</li> <li><code>\"fail\"</code> -- The job failed on the server side. The client raises an   <code>APIError</code> with the message <code>\"Batch job failed\"</code>.</li> </ul>"},{"location":"guides/transactions/#multi-page-jobs","title":"Multi-Page Jobs","text":"<p>Pagination for <code>load_job()</code> happens at the job submission level, not within a single job response. Each <code>POST /transaction/load-job</code> with a different <code>offset</code> value submits a separate batch job. The client handles this automatically:</p> <ol> <li>The first job is submitted with <code>offset=1</code> (or your custom starting offset).</li> <li>The response includes a <code>total</code> field indicating the total number of records.</li> <li>The client calculates how many additional pages are needed based on <code>total</code>    and the <code>limit</code> (default 100 records per page).</li> <li>Each remaining page submits a new job and goes through its own submit, poll,    and return cycle.</li> </ol> <p>All results are collected and returned as a single flat list.</p>"},{"location":"guides/transactions/#timeouts-and-errors","title":"Timeouts and Errors","text":"<p>Two error conditions can occur during the batch job workflow:</p> <ul> <li><code>APIError(\"Batch job failed\")</code> -- Raised when the API returns a job   status of <code>\"fail\"</code>. This indicates a server-side error processing your   request. Retry with the same parameters or narrow your date range.</li> <li><code>APITimeoutError</code> -- Raised when a single job does not reach <code>\"pass\"</code> or   <code>\"fail\"</code> within the <code>timeout</code> period (default 300 seconds / 5 minutes).   Increase the <code>timeout</code> parameter if you expect slow processing.</li> </ul> <p>Timeout applies per job page</p> <p>The <code>timeout</code> parameter applies to each individual job page, not to the entire <code>load_job()</code> call. For example, a query returning 500 records with the default limit of 100 submits 5 separate jobs. Each job has its own 300-second timeout, so the theoretical maximum wall time is 5 x 300 = 1,500 seconds (25 minutes).</p>"},{"location":"guides/transactions/#models","title":"Models","text":""},{"location":"guides/transactions/#transactionlistitem","title":"<code>TransactionListItem</code>","text":"<p>Returned by <code>list()</code> and <code>list_by_type()</code>. Contains summary fields.</p> Field Type Description <code>trans_number</code> <code>int</code> Transaction number <code>trans_id</code> <code>str</code> Unique transaction identifier <code>total</code> <code>float</code> Transaction total amount <code>date</code> <code>str</code> Transaction date"},{"location":"guides/transactions/#transactionv2listitem","title":"<code>TransactionV2ListItem</code>","text":"<p>Returned by <code>list_v2()</code>. Extends <code>TransactionListItem</code> with enriched fields.</p> Field Type Description <code>trans_number</code> <code>int</code> Transaction number <code>trans_id</code> <code>str</code> Unique transaction identifier <code>total</code> <code>float</code> Transaction total amount <code>date</code> <code>str</code> Transaction date <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>is_recurring_plan_sale</code> <code>bool</code> Whether this is a recurring sale <code>is_recurring_plan_redemption</code> <code>bool</code> Whether this is a recurring redemption <code>transaction_status</code> <code>str</code> Transaction status"},{"location":"guides/transactions/#transaction","title":"<code>Transaction</code>","text":"<p>Returned by <code>get()</code>. Contains full transaction details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique transaction identifier <code>number</code> <code>int</code> Transaction number <code>type</code> <code>str</code> Transaction type <code>complete_date</code> <code>str</code> Date and time of the transaction <code>location_code</code> <code>str</code> Site location code <code>sales_device_name</code> <code>str</code> Name of the sales device / POS <code>total</code> <code>float</code> Transaction total amount <code>customer_name</code> <code>str \\| None</code> Customer name <code>customer_id</code> <code>str \\| None</code> Customer identifier <code>vehicle_license_plate</code> <code>str \\| None</code> Vehicle license plate <code>employee_cashier</code> <code>str \\| None</code> Cashier employee name <code>employee_greeter</code> <code>str \\| None</code> Greeter employee name <code>is_recurring_payment</code> <code>bool</code> Recurring payment flag <code>is_recurring_redemption</code> <code>bool</code> Recurring redemption flag <code>is_recurring_sale</code> <code>bool</code> Recurring sale flag <code>is_prepaid_redemption</code> <code>bool</code> Prepaid redemption flag <code>is_prepaid_sale</code> <code>bool</code> Prepaid sale flag <code>tenders</code> <code>list[TransactionTender]</code> Payment tenders (see below) <code>items</code> <code>list[TransactionItem]</code> Line items (see below) <code>discounts</code> <code>list[TransactionDiscount]</code> Applied discounts (see below)"},{"location":"guides/transactions/#transactionjobitem","title":"<code>TransactionJobItem</code>","text":"<p>Returned by <code>load_job()</code>. Extends <code>Transaction</code> with v2 enrichment fields.</p> <p>This model inherits all fields from <code>Transaction</code> (see above) plus:</p> Field Type Description <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>is_recurring_plan_sale</code> <code>bool \\| None</code> Whether this is a recurring sale <code>is_recurring_plan_redemption</code> <code>bool \\| None</code> Whether this is a recurring redemption <code>transaction_status</code> <code>str \\| None</code> Transaction status"},{"location":"guides/transactions/#transactiontender","title":"<code>TransactionTender</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>tender</code> <code>str</code> Tender type name <code>tender_sub_type</code> <code>str \\| None</code> Tender sub-type <code>amount</code> <code>float</code> Tender amount <code>change</code> <code>float</code> Change given <code>total</code> <code>float</code> Net tender total <code>reference_number</code> <code>str \\| None</code> Payment reference number <code>credit_card_last_four</code> <code>str \\| None</code> Last four digits of card <code>credit_card_expiration_date</code> <code>str \\| None</code> Card expiration date"},{"location":"guides/transactions/#transactionitem","title":"<code>TransactionItem</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>name</code> <code>str</code> Item name <code>sku</code> <code>str \\| None</code> Item SKU <code>department</code> <code>str</code> Department name <code>quantity</code> <code>int</code> Quantity sold <code>gross</code> <code>float</code> Gross amount <code>net</code> <code>float</code> Net amount <code>discount</code> <code>float</code> Discount amount <code>tax</code> <code>float</code> Tax amount <code>additional_fee</code> <code>float</code> Additional fees <code>is_voided</code> <code>bool</code> Whether the item was voided"},{"location":"guides/transactions/#transactiondiscount","title":"<code>TransactionDiscount</code>","text":"<p>Nested inside <code>Transaction</code> and <code>TransactionJobItem</code>.</p> Field Type Description <code>discount_name</code> <code>str</code> Discount name <code>discount_sku</code> <code>str \\| None</code> Discount SKU <code>applied_to_item_name</code> <code>str</code> Item the discount was applied to <code>discount_amount</code> <code>float</code> Amount discounted <code>discount_code</code> <code>str</code> Discount code"},{"location":"guides/transactions/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/transactions/#multi-day-exports","title":"Multi-Day Exports","text":"<p>Since <code>load_job()</code> is limited to a 24-hour date range per call, use a loop to export multiple days:</p> <pre><code>from datetime import date, timedelta\nfrom sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    start = date(2025, 6, 1)\n    end = date(2025, 6, 30)\n    all_results = []\n\n    current = start\n    while current &lt; end:\n        next_day = current + timedelta(days=1)\n        day_results = client.transactions.load_job(\n            startDate=current.isoformat(),\n            endDate=next_day.isoformat(),\n            site=\"JOLIET\",\n        )\n        all_results.extend(day_results)\n        current = next_day\n\n    print(f\"Exported {len(all_results)} transactions over {(end - start).days} days\")\n</code></pre> <p>Spacing requests for large exports</p> <p>For very large exports, consider adding a small <code>time.sleep()</code> between days to stay well within the rate limit. The client handles 429 retries automatically, but spacing requests reduces retry churn.</p>"},{"location":"guides/transactions/#error-handling","title":"Error Handling","text":"<p>Transaction-specific error handling patterns:</p> <pre><code>from sonnys_data_client import SonnysClient\nfrom sonnys_data_client._exceptions import (\n    APIError,\n    APITimeoutError,\n    RateLimitError,\n    ValidationError,\n)\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    try:\n        results = client.transactions.load_job(\n            startDate=\"2025-06-15\",\n            endDate=\"2025-06-16\",\n            site=\"JOLIET\",\n            timeout=600.0,\n        )\n    except APITimeoutError:\n        print(\"Job timed out \u2014 try a shorter date range or increase timeout\")\n    except APIError as e:\n        print(f\"Job failed: {e}\")\n    except RateLimitError:\n        print(\"Rate limit exceeded after max retries\")\n</code></pre> <p><code>ValidationError</code></p> <p><code>ValidationError</code> is raised when date format is invalid or parameters fail API validation. This is caught before the request is sent, so it does not count against the rate limit.</p>"},{"location":"guides/transactions/#cross-resource-lookups","title":"Cross-Resource Lookups","text":"<p>Enrich transaction data by combining with other resources:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    # Get enriched transactions with customer_id\n    transactions = client.transactions.list_v2(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    # Build customer lookup from customer_ids found in transactions\n    customer_ids = {t.customer_id for t in transactions if t.customer_id}\n    customers = {\n        c.customer_id: c\n        for c in client.customers.list()\n        if c.customer_id in customer_ids\n    }\n\n    # Enrich transactions with customer names\n    for txn in transactions:\n        if txn.customer_id and txn.customer_id in customers:\n            customer = customers[txn.customer_id]\n            print(f\"#{txn.trans_number}: ${txn.total:.2f} \u2014 {customer.first_name} {customer.last_name}\")\n</code></pre> <p>Auto-pagination</p> <p>The <code>list()</code>, <code>list_by_type()</code>, and <code>list_v2()</code> methods automatically fetch all pages of results. The <code>load_job()</code> method handles pagination at the job submission level, submitting multiple jobs as needed.</p>"},{"location":"guides/washbooks/","title":"Washbooks","text":"<p>The Washbooks resource provides access to prepaid wash book accounts. Each account tracks balances, sign-up and cancellation dates, and billing site information. The detail endpoint expands each account with customer contact info, RFID tags, associated vehicles, and recurring billing details.</p>"},{"location":"guides/washbooks/#methods","title":"Methods","text":""},{"location":"guides/washbooks/#listparams-listwashbooklistitem","title":"<code>list(**params) -&gt; list[WashbookListItem]</code>","text":"<p>Fetch all wash book accounts. Returns a list of <code>WashbookListItem</code> objects with summary fields. The client automatically paginates through all pages of results.</p> <pre><code>washbooks = client.washbooks.list()\n</code></pre> <p>You can pass optional query parameters to filter results:</p> <pre><code>washbooks = client.washbooks.list(\n    startDate=\"2025-01-01\",\n    endDate=\"2025-01-31\",\n)\n</code></pre>"},{"location":"guides/washbooks/#getaccount_id-washbook","title":"<code>get(account_id) -&gt; Washbook</code>","text":"<p>Fetch full details for a single wash book account by its ID. Returns a <code>Washbook</code> object with nested customer, tag, vehicle, and recurring billing information.</p> <pre><code>washbook = client.washbooks.get(\"12345\")\n</code></pre>"},{"location":"guides/washbooks/#examples","title":"Examples","text":""},{"location":"guides/washbooks/#list-all-wash-book-accounts","title":"List all wash book accounts","text":"<pre><code>from sonnys_data_client import SonnysClient\n\nwith SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    washbooks = client.washbooks.list()\n\n    for wb in washbooks:\n        print(f\"{wb.name} (ID: {wb.id}) - Status: {wb.status}\")\n</code></pre>"},{"location":"guides/washbooks/#filter-by-date-and-check-balances","title":"Filter by date and check balances","text":"<pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    recent = client.washbooks.list(\n        startDate=\"2025-06-01\",\n        endDate=\"2025-06-30\",\n    )\n\n    for wb in recent:\n        print(f\"Account {wb.id}: balance={wb.balance}, site={wb.billing_site_id}\")\n</code></pre>"},{"location":"guides/washbooks/#get-wash-book-detail-with-customer-info","title":"Get wash book detail with customer info","text":"<p>The detail endpoint returns rich nested data including the customer, tags, vehicles, and recurring billing information:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    # Customer information\n    print(f\"Customer: {wb.customer.first_name} {wb.customer.last_name}\")\n    print(f\"Customer ID: {wb.customer.id}\")\n\n    # Account status and balance\n    print(f\"Status: {wb.status}\")\n    print(f\"Balance: {wb.balance}\")\n</code></pre>"},{"location":"guides/washbooks/#iterate-tags-and-vehicles","title":"Iterate tags and vehicles","text":"<p>Each wash book detail includes lists of RFID tags and associated vehicles:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    # RFID tags\n    for tag in wb.tags:\n        status = \"active\" if tag.enabled else \"disabled\"\n        print(f\"Tag #{tag.number} (ID: {tag.id}) - {status}\")\n\n    # Vehicles\n    for vehicle in wb.vehicles:\n        plate = vehicle.plate or \"No plate\"\n        print(f\"Vehicle {vehicle.id}: {plate}\")\n</code></pre>"},{"location":"guides/washbooks/#access-recurring-billing-info","title":"Access recurring billing info","text":"<p>The <code>recurring_info</code> field provides current billing details and trial status:</p> <pre><code>with SonnysClient(api_id=\"your-api-id\", api_key=\"your-api-key\") as client:\n    wb = client.washbooks.get(\"12345\")\n\n    info = wb.recurring_info\n    print(f\"Billing amount: ${info.current_billable_amount:.2f}\")\n    print(f\"Next bill date: {info.next_bill_date}\")\n    print(f\"Last bill date: {info.last_bill_date}\")\n    print(f\"On trial: {info.is_on_trial}\")\n    if info.is_on_trial:\n        print(f\"Remaining trial periods: {info.remaining_trial_periods}\")\n</code></pre>"},{"location":"guides/washbooks/#models","title":"Models","text":""},{"location":"guides/washbooks/#washbooklistitem","title":"<code>WashbookListItem</code>","text":"<p>Returned by <code>list()</code>. Contains summary fields for each wash book account.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str \\| None</code> Account name <code>balance</code> <code>str</code> Current account balance <code>sign_up_date</code> <code>str</code> Date the account was created <code>cancel_date</code> <code>str \\| None</code> Date the account was cancelled <code>billing_site_id</code> <code>int</code> ID of the billing site <code>customer_id</code> <code>str \\| None</code> Associated customer identifier <code>status</code> <code>str</code> Current account status"},{"location":"guides/washbooks/#washbook","title":"<code>Washbook</code>","text":"<p>Returned by <code>get()</code>. Contains full account details with nested models.</p> Field Type Description <code>id</code> <code>str</code> Unique account identifier <code>name</code> <code>str</code> Account name <code>balance</code> <code>str \\| None</code> Current account balance <code>customer</code> <code>WashbookCustomer</code> Nested customer object (see below) <code>status</code> <code>str</code> Current account status <code>recurring_info</code> <code>WashbookRecurringInfo</code> Billing and trial info (see below) <code>tags</code> <code>list[WashbookTag]</code> List of RFID tags (see below) <code>vehicles</code> <code>list[WashbookVehicle]</code> List of vehicles (see below)"},{"location":"guides/washbooks/#washbookcustomer","title":"<code>WashbookCustomer</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str \\| None</code> Customer identifier <code>number</code> <code>str \\| None</code> Customer account number <code>first_name</code> <code>str \\| None</code> Customer first name <code>last_name</code> <code>str \\| None</code> Customer last name"},{"location":"guides/washbooks/#washbookrecurringinfo","title":"<code>WashbookRecurringInfo</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>current_billable_amount</code> <code>float</code> Current billing amount <code>next_bill_date</code> <code>str \\| None</code> Next scheduled billing date <code>last_bill_date</code> <code>str \\| None</code> Most recent billing date <code>is_on_trial</code> <code>bool</code> Whether the account is on trial <code>remaining_trial_periods</code> <code>int</code> Number of trial periods left"},{"location":"guides/washbooks/#washbooktag","title":"<code>WashbookTag</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str</code> Unique tag identifier <code>number</code> <code>str</code> Tag number <code>enabled</code> <code>bool</code> Whether the tag is active"},{"location":"guides/washbooks/#washbookvehicle","title":"<code>WashbookVehicle</code>","text":"<p>Nested inside the <code>Washbook</code> model.</p> Field Type Description <code>id</code> <code>str</code> Unique vehicle identifier <code>plate</code> <code>str \\| None</code> License plate number <p>Nested model relationships</p> <p>The <code>Washbook</code> detail model contains four nested types: <code>WashbookCustomer</code>, <code>WashbookRecurringInfo</code>, <code>WashbookTag</code>, and <code>WashbookVehicle</code>. These same nested types are also used by the Recurring Accounts resource.</p> <p>Auto-pagination</p> <p>The <code>list()</code> method automatically fetches all pages of results. You do not need to handle pagination manually -- the client will continue requesting pages until all records have been retrieved.</p> <p>Full model reference</p> <p>For the complete field definitions and type annotations, see the Models page in the API Reference.</p>"}]}